
The query:
(in same quality, make the service api (dtos and controllers) layers for all repos in this module, production ready, safely and properly cached.

 === ./src/main/java/com/jjenus/tracker/core/application/event/VehicleEventHandler.java ===
 ```.java
 package com.jjenus.tracker.core.application.event;

 import com.jjenus.tracker.shared.events.LocationDataEvent;
 import com.jjenus.tracker.shared.events.VehicleUpdatedEvent;
 import com.jjenus.tracker.shared.pubsub.EventPublisher;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 import org.springframework.jms.annotation.JmsListener;
 import org.springframework.messaging.handler.annotation.Payload;
 import org.springframework.stereotype.Component;
 import org.springframework.transaction.annotation.Transactional;

 @Component
 public class VehicleEventHandler {
     private static final Logger logger = LoggerFactory.getLogger(VehicleEventHandler.class);

     private final VehicleService vehicleService;
     private final EventPublisher eventPublisher;

     public VehicleEventHandler(VehicleService vehicleService, EventPublisher eventPublisher) {
         this.vehicleService = vehicleService;
         this.eventPublisher = eventPublisher;
     }

     @JmsListener(destination = "tracking.events.locationdataevent",
             containerFactory = "topicJmsListenerContainerFactory",
             concurrency = "1"
     )
     @Transactional
     public void handleLocationUpdate(@Payload LocationDataEvent event) {
         try {
             logger.info("Received location update for device {}", event.getDeviceId());

             // Find or create vehicle for this device
 //            String vehicleId = vehicleService.findVehicleIdForDevice(event.getDeviceId());

             // Update vehicle location
 //            vehicleService.updateVehicleLocation(vehicleId, event.getLocation());

             // Publish vehicle update event for alerting
             VehicleUpdatedEvent vehicleUpdatedEvent = new VehicleUpdatedEvent(vehicleId, event.getLocation(), event.getDeviceId());
             eventPublisher.publish(vehicleUpdatedEvent);

             logger.info("Updated vehicle {} for device {}", vehicleId, event.getDeviceId());

         } catch (Exception e) {
             logger.error("Failed to process location update for device {}",
                     event != null ? event.getDeviceId() : "unknown", e);
             throw e;
         }
     }
 }```

 === ./src/main/java/com/jjenus/tracker/core/application/ITripService.java ===
 ```.java
 package com.jjenus.tracker.core.application;

 import com.jjenus.tracker.core.domain.Trip;
 import com.jjenus.tracker.shared.domain.LocationPoint;
 import java.time.Instant;
 import java.util.List;
 import java.util.Optional;

 public interface ITripService {
     Optional<Trip> getActiveTrip(String vehicleId);
     List<Trip> getVehicleTrips(String vehicleId, Instant from, Instant to);
     float calculateTripDistance(String tripId);
     float calculateFuelConsumption(String tripId);
     void detectTripStart(LocationPoint location);
     void detectTripEnd(LocationPoint location);
 }
 ```

 === ./src/main/java/com/jjenus/tracker/core/config/CoreConfig.java ===
 ```.java
 package com.jjenus.tracker.core.config;

 import org.modelmapper.ModelMapper;
 import org.springframework.context.annotation.Bean;
 import org.springframework.context.annotation.Configuration;


 @Configuration
 public class CoreConfig {
     @Bean
     public ModelMapper modelMapper() {
         ModelMapper modelMapper = new ModelMapper();
         modelMapper.getConfiguration()
                 .setSkipNullEnabled(true)
                 .setFieldMatchingEnabled(true)
                 .setFieldAccessLevel(org.modelmapper.config.Configuration.AccessLevel.PRIVATE);
         return modelMapper;
     }
 }
 ```

 === ./src/main/java/com/jjenus/tracker/core/domain/entity/DeviceCommand.java ===
 ```.java
 package com.jjenus.tracker.core.domain.entity;

 import com.jjenus.tracker.core.domain.enums.CommandStatus;
 import com.jjenus.tracker.core.domain.enums.CommandType;
 import jakarta.persistence.*;
 import java.time.Instant;

 @Entity
 @Table(name = "device_commands")
 public class DeviceCommand {

     @Id
     @GeneratedValue(strategy = GenerationType.IDENTITY)
     @Column(name = "command_id")
     private Long commandId;

     @ManyToOne(fetch = FetchType.LAZY)
     @JoinColumn(name = "tracker_id", nullable = false)
     private Tracker tracker;

     @Enumerated(EnumType.STRING)
     @Column(name = "command_type", length = 50, nullable = false)
     private CommandType commandType;

     @Column(name = "command_data", columnDefinition = "TEXT", nullable = false)
     private String commandData;

     @Enumerated(EnumType.STRING)
     @Column(name = "status", length = 20)
     private CommandStatus status = CommandStatus.PENDING;

     @Column(name = "response_data", columnDefinition = "TEXT")
     private String responseData;

     @Column(name = "sent_at")
     private Instant sentAt;

     @Column(name = "responded_at")
     private Instant respondedAt;

     @Column(name = "retry_count")
     private Integer retryCount = 0;

     @Column(name = "max_retries")
     private Integer maxRetries = 3;

     @Column(name = "error_message", columnDefinition = "TEXT")
     private String errorMessage;

     @Column(name = "initiated_by", length = 100)
     private String initiatedBy;

     @Column(name = "created_at")
     private Instant createdAt = Instant.now();

     @Column(name = "updated_at")
     private Instant updatedAt = Instant.now();

     @PreUpdate
     protected void onUpdate() {
         this.updatedAt = Instant.now();
     }

     // Business methods
     public void markAsSent() {
         this.status = CommandStatus.SENT;
         this.sentAt = Instant.now();
     }

     public void markAsDelivered(String response) {
         this.status = CommandStatus.DELIVERED;
         this.responseData = response;
         this.respondedAt = Instant.now();
     }

     public void markAsFailed(String error) {
         this.status = CommandStatus.FAILED;
         this.errorMessage = error;
         this.respondedAt = Instant.now();
     }

     public void markAsTimeout() {
         this.status = CommandStatus.TIMEOUT;
         this.respondedAt = Instant.now();
     }

     public void incrementRetryCount() {
         this.retryCount++;
     }

     public boolean canRetry() {
         return this.status == CommandStatus.FAILED ||
                 this.status == CommandStatus.TIMEOUT &&
                         this.retryCount < this.maxRetries;
     }

     // Getters and Setters
     public Long getCommandId() { return commandId; }
     public void setCommandId(Long commandId) { this.commandId = commandId; }

     public Tracker getTracker() { return tracker; }
     public void setTracker(Tracker tracker) { this.tracker = tracker; }

     public CommandType getCommandType() { return commandType; }
     public void setCommandType(CommandType commandType) { this.commandType = commandType; }

     public String getCommandData() { return commandData; }
     public void setCommandData(String commandData) { this.commandData = commandData; }

     public CommandStatus getStatus() { return status; }
     public void setStatus(CommandStatus status) { this.status = status; }

     public String getResponseData() { return responseData; }
     public void setResponseData(String responseData) { this.responseData = responseData; }

     public Instant getSentAt() { return sentAt; }
     public void setSentAt(Instant sentAt) { this.sentAt = sentAt; }

     public Instant getRespondedAt() { return respondedAt; }
     public void setRespondedAt(Instant respondedAt) { this.respondedAt = respondedAt; }

     public Integer getRetryCount() { return retryCount; }
     public void setRetryCount(Integer retryCount) { this.retryCount = retryCount; }

     public Instant getCreatedAt() { return createdAt; }
     public void setCreatedAt(Instant createdAt) { this.createdAt = createdAt; }

     public Instant getUpdatedAt() { return updatedAt; }
     public void setUpdatedAt(Instant updatedAt) { this.updatedAt = updatedAt; }

     // Additional getters/setters
     public Integer getMaxRetries() { return maxRetries; }
     public void setMaxRetries(Integer maxRetries) { this.maxRetries = maxRetries; }

     public String getErrorMessage() { return errorMessage; }
     public void setErrorMessage(String errorMessage) { this.errorMessage = errorMessage; }

     public String getInitiatedBy() { return initiatedBy; }
     public void setInitiatedBy(String initiatedBy) { this.initiatedBy = initiatedBy; }
 }```

 === ./src/main/java/com/jjenus/tracker/core/domain/entity/TrackerAssignment.java ===
 ```.java
 package com.jjenus.tracker.core.domain.entity;

 import jakarta.persistence.*;
 import java.time.Instant;

 @Entity
 @Table(name = "tracker_assignments")
 public class TrackerAssignment {

     @Id
     @GeneratedValue(strategy = GenerationType.IDENTITY)
     private Long id;

     @ManyToOne(fetch = FetchType.LAZY)
     @JoinColumn(name = "vehicle_id", nullable = false)
     private Vehicle vehicle;

     @ManyToOne(fetch = FetchType.LAZY)
     @JoinColumn(name = "tracker_id", nullable = false)
     private Tracker tracker;

     @Column(name = "assigned_at", nullable = false)
     private Instant assignedAt;

     @Column(name = "assigned_by", length = 100)
     private String assignedBy; // User/admin who made assignment

     @Column(name = "removed_at")
     private Instant removedAt;

     @Column(name = "removed_by", length = 100)
     private String removedBy;

     @Column(name = "removal_reason", length = 200)
     private String removalReason;

     @Column(name = "is_active")
     private Boolean isActive = true;

     @Column(name = "notes", length = 500)
     private String notes;

     @PrePersist
     protected void onCreate() {
         if (assignedAt == null) {
             assignedAt = Instant.now();
         }
     }

     // Business methods
     public void deactivateAssignment(String removedBy, String reason) {
         this.isActive = false;
         this.removedAt = Instant.now();
         this.removedBy = removedBy;
         this.removalReason = reason;
     }

     // Getters and Setters
     public Long getId() { return id; }
     public void setId(Long id) { this.id = id; }

     public Vehicle getVehicle() { return vehicle; }
     public void setVehicle(Vehicle vehicle) { this.vehicle = vehicle; }

     public Tracker getTracker() { return tracker; }
     public void setTracker(Tracker tracker) { this.tracker = tracker; }

     public Instant getAssignedAt() { return assignedAt; }
     public void setAssignedAt(Instant assignedAt) { this.assignedAt = assignedAt; }

     public String getAssignedBy() { return assignedBy; }
     public void setAssignedBy(String assignedBy) { this.assignedBy = assignedBy; }

     public Instant getRemovedAt() { return removedAt; }
     public void setRemovedAt(Instant removedAt) { this.removedAt = removedAt; }

     public String getRemovedBy() { return removedBy; }
     public void setRemovedBy(String removedBy) { this.removedBy = removedBy; }

     public String getRemovalReason() { return removalReason; }
     public void setRemovalReason(String removalReason) { this.removalReason = removalReason; }

     public Boolean getIsActive() { return isActive; }
     public void setIsActive(Boolean isActive) { this.isActive = isActive; }

     public String getNotes() { return notes; }
     public void setNotes(String notes) { this.notes = notes; }
 }```

 === ./src/main/java/com/jjenus/tracker/core/domain/entity/Tracker.java ===
 ```.java
 package com.jjenus.tracker.core.domain.entity;

 import com.jjenus.tracker.core.domain.enums.TrackerStatus;
 import jakarta.persistence.*;
 import java.time.Instant;
 import java.util.ArrayList;
 import java.util.List;

 @Entity
 @Table(name = "trackers")
 public class Tracker {

     @Id
     @Column(name = "tracker_id", length = 50)
     private String trackerId;

     @Column(name = "device_id", length = 50, unique = true)
     private String deviceId;

     //    device_id == imei
 //    @Column(name = "imei", length = 20, unique = true)
 //    private String imei;

     @Column(name = "model", length = 100)
     private String model;

     @Column(name = "protocol", length = 20)
     private String protocol;

     @Column(name = "firmware_version", length = 50)
     private String firmwareVersion;

     @Column(name = "sim_number", length = 20)
     private String simNumber;

     @Column(name = "battery_level")
     private Float batteryLevel;

     @Column(name = "signal_strength")
     private Integer signalStrength;

     @Column(name = "is_online")
     private Boolean isOnline = false;

     @Column(name = "last_seen")
     private Instant lastSeen;

     @Enumerated(EnumType.STRING)
     @Column(name = "status", length = 20)
     private TrackerStatus status = TrackerStatus.ACTIVE;

     @ManyToOne(fetch = FetchType.LAZY)
     @JoinColumn(name = "vehicle_id")
     private Vehicle vehicle;

     @OneToMany(mappedBy = "tracker", cascade = CascadeType.ALL, orphanRemoval = true)
     @OrderBy("recordedAt DESC")
     private List<TrackerLocation> locations = new ArrayList<>();

     @OneToMany(mappedBy = "tracker", cascade = CascadeType.ALL, orphanRemoval = true)
     private List<TrackerRawData> rawDataEntries = new ArrayList<>();

     @OneToMany(mappedBy = "tracker", cascade = CascadeType.ALL, orphanRemoval = true)
     private List<DeviceCommand> commands = new ArrayList<>();

     @Column(name = "created_at")
     private Instant createdAt = Instant.now();

     @Column(name = "updated_at")
     private Instant updatedAt = Instant.now();

     @PreUpdate
     protected void onUpdate() {
         this.updatedAt = Instant.now();
     }

     // Business methods
     public void updateLastSeen() {
         this.lastSeen = Instant.now();
         this.isOnline = true;
     }

     public void updateBatteryLevel(Float level) {
         this.batteryLevel = level;
     }

     public void addLocation(TrackerLocation location) {
         locations.add(location);
         location.setTracker(this);
     }

     public void addRawData(TrackerRawData rawData) {
         rawDataEntries.add(rawData);
         rawData.setTracker(this);
     }

     public TrackerLocation getLatestLocation() {
         return locations.isEmpty() ? null : locations.get(0);
     }

     // Getters and Setters
     public String getTrackerId() { return trackerId; }
     public void setTrackerId(String trackerId) { this.trackerId = trackerId; }

     public String getDeviceId() { return deviceId; }
     public void setDeviceId(String deviceId) { this.deviceId = deviceId; }

 //    device_id == imei
 //    public String getImei() { return imei; }
 //    public void setImei(String imei) { this.imei = imei; }

     public String getModel() { return model; }
     public void setModel(String model) { this.model = model; }

     public String getProtocol() { return protocol; }
     public void setProtocol(String protocol) { this.protocol = protocol; }

     public Boolean getIsOnline() { return isOnline; }
     public void setIsOnline(Boolean isOnline) { this.isOnline = isOnline; }

     public Instant getLastSeen() { return lastSeen; }
     public void setLastSeen(Instant lastSeen) { this.lastSeen = lastSeen; }

     public TrackerStatus getStatus() { return status; }
     public void setStatus(TrackerStatus status) { this.status = status; }

     public Vehicle getVehicle() { return vehicle; }
     public void setVehicle(Vehicle vehicle) { this.vehicle = vehicle; }

     public List<TrackerLocation> getLocations() { return locations; }
     public void setLocations(List<TrackerLocation> locations) { this.locations = locations; }

     public Instant getCreatedAt() { return createdAt; }
     public void setCreatedAt(Instant createdAt) { this.createdAt = createdAt; }

     public Instant getUpdatedAt() { return updatedAt; }
     public void setUpdatedAt(Instant updatedAt) { this.updatedAt = updatedAt; }

     // Additional getters/setters
     public String getFirmwareVersion() { return firmwareVersion; }
     public void setFirmwareVersion(String firmwareVersion) { this.firmwareVersion = firmwareVersion; }

     public String getSimNumber() { return simNumber; }
     public void setSimNumber(String simNumber) { this.simNumber = simNumber; }

     public Float getBatteryLevel() { return batteryLevel; }
     public void setBatteryLevel(Float batteryLevel) { this.batteryLevel = batteryLevel; }

     public Integer getSignalStrength() { return signalStrength; }
     public void setSignalStrength(Integer signalStrength) { this.signalStrength = signalStrength; }

     public List<TrackerRawData> getRawDataEntries() { return rawDataEntries; }
     public void setRawDataEntries(List<TrackerRawData> rawDataEntries) { this.rawDataEntries = rawDataEntries; }

     public List<DeviceCommand> getCommands() { return commands; }
     public void setCommands(List<DeviceCommand> commands) { this.commands = commands; }
 }```

 === ./src/main/java/com/jjenus/tracker/core/domain/entity/TrackerLocation.java ===
 ```.java
 package com.jjenus.tracker.core.domain.entity;

 import jakarta.persistence.*;
 import java.time.Instant;

 @Entity
 @Table(name = "tracker_location_data")
 public class TrackerLocation {

     @Id
     @GeneratedValue(strategy = GenerationType.IDENTITY)
     @Column(name = "location_id")
     private Long locationId;

     @ManyToOne(fetch = FetchType.LAZY)
     @JoinColumn(name = "tracker_id", nullable = false)
     private Tracker tracker;

     @ManyToOne(fetch = FetchType.LAZY)
     @JoinColumn(name = "trip_id")
     private Trip trip;

     @Column(name = "latitude")
     private Double latitude;

     @Column(name = "longitude")
     private Double longitude;

     @Column(name = "speed_kmh")
     private Float speedKmh;

     @Column(name = "heading")
     private Float heading;

     @Column(name = "altitude")
     private Float altitude;

     @Column(name = "validity", length = 1)
     private String validity = "A";

     @Column(name = "odometer_km")
     private Float odometerKm;

     @Column(name = "battery_voltage")
     private Float batteryVoltage;

     @Column(name = "signal_strength")
     private Integer signalStrength;

     @Column(name = "acc_status")
     private Boolean accStatus;

     @Column(name = "engine_status", length = 20)
     private String engineStatus;

     @Column(name = "device_status", columnDefinition = "JSONB")
     private String deviceStatus;

     @Column(name = "recorded_at", nullable = false)
     private Instant recordedAt;

     @Column(name = "created_at")
     private Instant createdAt = Instant.now();

     // Constructor
     public TrackerLocation() {}

     public TrackerLocation(Double latitude, Double longitude, Float speedKmh, Instant recordedAt) {
         this.latitude = latitude;
         this.longitude = longitude;
         this.speedKmh = speedKmh;
         this.recordedAt = recordedAt;
     }

     // Business methods
     public boolean isValid() {
         return latitude != null && longitude != null &&
                latitude >= -90 && latitude <= 90 &&
                longitude >= -180 && longitude <= 180 &&
                recordedAt != null;
     }

     // Getters and Setters
     public Long getLocationId() { return locationId; }
     public void setLocationId(Long locationId) { this.locationId = locationId; }

     public Tracker getTracker() { return tracker; }
     public void setTracker(Tracker tracker) { this.tracker = tracker; }

     public Trip getTrip() { return trip; }
     public void setTrip(Trip trip) { this.trip = trip; }

     public Double getLatitude() { return latitude; }
     public void setLatitude(Double latitude) { this.latitude = latitude; }

     public Double getLongitude() { return longitude; }
     public void setLongitude(Double longitude) { this.longitude = longitude; }

     public Float getSpeedKmh() { return speedKmh; }
     public void setSpeedKmh(Float speedKmh) { this.speedKmh = speedKmh; }

     public Instant getRecordedAt() { return recordedAt; }
     public void setRecordedAt(Instant recordedAt) { this.recordedAt = recordedAt; }

     public Instant getCreatedAt() { return createdAt; }
     public void setCreatedAt(Instant createdAt) { this.createdAt = createdAt; }

     // Additional getters/setters
     public Float getHeading() { return heading; }
     public void setHeading(Float heading) { this.heading = heading; }

     public Float getAltitude() { return altitude; }
     public void setAltitude(Float altitude) { this.altitude = altitude; }

     public String getValidity() { return validity; }
     public void setValidity(String validity) { this.validity = validity; }

     public Float getOdometerKm() { return odometerKm; }
     public void setOdometerKm(Float odometerKm) { this.odometerKm = odometerKm; }

     public Float getBatteryVoltage() { return batteryVoltage; }
     public void setBatteryVoltage(Float batteryVoltage) { this.batteryVoltage = batteryVoltage; }

     public Integer getSignalStrength() { return signalStrength; }
     public void setSignalStrength(Integer signalStrength) { this.signalStrength = signalStrength; }

     public Boolean getAccStatus() { return accStatus; }
     public void setAccStatus(Boolean accStatus) { this.accStatus = accStatus; }

     public String getEngineStatus() { return engineStatus; }
     public void setEngineStatus(String engineStatus) { this.engineStatus = engineStatus; }

     public String getDeviceStatus() { return deviceStatus; }
     public void setDeviceStatus(String deviceStatus) { this.deviceStatus = deviceStatus; }
 }```

 === ./src/main/java/com/jjenus/tracker/core/domain/entity/TrackerRawData.java ===
 ```.java
 package com.jjenus.tracker.core.domain.entity;

 import jakarta.persistence.*;
 import java.time.Instant;

 @Entity
 @Table(name = "tracker_raw_data")
 public class TrackerRawData {

     @Id
     @GeneratedValue(strategy = GenerationType.IDENTITY)
     @Column(name = "raw_data_id")
     private Long rawDataId;

     @ManyToOne(fetch = FetchType.LAZY)
     @JoinColumn(name = "tracker_id", nullable = false)
     private Tracker tracker;

     @Column(name = "raw_message", columnDefinition = "TEXT", nullable = false)
     private String rawMessage;

     @Column(name = "protocol", length = 20)
     private String protocol;

     @Column(name = "source_ip", length = 45)
     private String sourceIp;

     @Column(name = "received_at")
     private Instant receivedAt = Instant.now();

     @Column(name = "processed")
     private Boolean processed = false;

     @Column(name = "processing_error", columnDefinition = "TEXT")
     private String processingError;

     @Column(name = "parsed_data", columnDefinition = "JSONB")
     private String parsedData;

     @Column(name = "created_at")
     private Instant createdAt = Instant.now();

     // Getters and Setters
     public Long getRawDataId() { return rawDataId; }
     public void setRawDataId(Long rawDataId) { this.rawDataId = rawDataId; }

     public Tracker getTracker() { return tracker; }
     public void setTracker(Tracker tracker) { this.tracker = tracker; }

     public String getRawMessage() { return rawMessage; }
     public void setRawMessage(String rawMessage) { this.rawMessage = rawMessage; }

     public String getProtocol() { return protocol; }
     public void setProtocol(String protocol) { this.protocol = protocol; }

     public String getSourceIp() { return sourceIp; }
     public void setSourceIp(String sourceIp) { this.sourceIp = sourceIp; }

     public Instant getReceivedAt() { return receivedAt; }
     public void setReceivedAt(Instant receivedAt) { this.receivedAt = receivedAt; }

     public Boolean getProcessed() { return processed; }
     public void setProcessed(Boolean processed) { this.processed = processed; }

     public Instant getCreatedAt() { return createdAt; }
     public void setCreatedAt(Instant createdAt) { this.createdAt = createdAt; }

     public String getProcessingError() { return processingError; }
     public void setProcessingError(String processingError) { this.processingError = processingError; }

     public String getParsedData() { return parsedData; }
     public void setParsedData(String parsedData) { this.parsedData = parsedData; }
 }```

 === ./src/main/java/com/jjenus/tracker/core/domain/entity/Trip.java ===
 ```.java
 package com.jjenus.tracker.core.domain.entity;

 import com.jjenus.tracker.core.domain.enums.TripEndReason;
 import com.jjenus.tracker.core.domain.enums.TripStartReason;
 import jakarta.persistence.*;
 import java.time.Duration;
 import java.time.Instant;
 import java.util.ArrayList;
 import java.util.List;

 @Entity
 @Table(name = "trips")
 public class Trip {

     @Id
     @Column(name = "trip_id", length = 50)
     private String tripId;

     @ManyToOne(fetch = FetchType.LAZY)
     @JoinColumn(name = "vehicle_id", nullable = false)
     private Vehicle vehicle;

     @OneToOne(fetch = FetchType.LAZY)
     @JoinColumn(name = "start_location_id")
     private TrackerLocation startLocation;

     @OneToOne(fetch = FetchType.LAZY)
     @JoinColumn(name = "end_location_id")
     private TrackerLocation endLocation;

     @Column(name = "start_time", nullable = false)
     private Instant startTime;

     @Column(name = "end_time")
     private Instant endTime;

     @Enumerated(EnumType.STRING)
     @Column(name = "start_reason", length = 50)
     private TripStartReason startReason;

     @Enumerated(EnumType.STRING)
     @Column(name = "end_reason", length = 50)
     private TripEndReason endReason;

     @Column(name = "acc_off_duration_seconds")
     private Integer accOffDurationSeconds;

     @Column(name = "total_distance_km")
     private Float totalDistanceKm = 0.0f;

     @Column(name = "average_speed_kmh")
     private Float averageSpeedKmh;

     @Column(name = "max_speed_kmh")
     private Float maxSpeedKmh;

     @Column(name = "idle_time_minutes")
     private Integer idleTimeMinutes;

     @Column(name = "fuel_consumed_liters")
     private Float fuelConsumedLiters;

     @Column(name = "is_active")
     private Boolean isActive = true;

     @OneToMany(mappedBy = "trip", cascade = CascadeType.ALL, orphanRemoval = true)
     @OrderBy("pointOrder ASC")
     private List<TripPoint> tripPoints = new ArrayList<>();

     @Column(name = "created_at")
     private Instant createdAt = Instant.now();

     @Column(name = "updated_at")
     private Instant updatedAt = Instant.now();

     @PreUpdate
     protected void onUpdate() {
         this.updatedAt = Instant.now();
     }

     // Business methods
     public void addLocationPoint(TrackerLocation location, Float segmentDistance) {
         TripPoint tripPoint = new TripPoint();
         tripPoint.setTrip(this);
         tripPoint.setLocation(location);
         tripPoint.setPointOrder(tripPoints.size() + 1);
         tripPoint.setSegmentDistanceKm(segmentDistance);

         tripPoints.add(tripPoint);

         // Update total distance
         this.totalDistanceKm += segmentDistance;

         // Update max speed
         if (location.getSpeedKmh() != null &&
             (this.maxSpeedKmh == null || location.getSpeedKmh() > this.maxSpeedKmh)) {
             this.maxSpeedKmh = location.getSpeedKmh();
         }
     }

     public void endTrip(TripEndReason reason, TrackerLocation endLocation) {
         this.endTime = endLocation.getRecordedAt();
         this.endLocation = endLocation;
         this.endReason = reason;
         this.isActive = false;

         // Calculate final statistics
         calculateStatistics();

         // Add final location point
         if (endLocation != null) {
             TrackerLocation lastLocation = getLastLocationPoint();
             if (lastLocation != null) {
                 Float segmentDistance = calculateDistance(lastLocation, endLocation);
                 addLocationPoint(endLocation, segmentDistance);
             }
         }
     }

     private void calculateStatistics() {
         if (startTime != null && endTime != null) {
             Duration duration = Duration.between(startTime, endTime);
             long hours = duration.toHours();

             if (hours > 0 && totalDistanceKm != null && totalDistanceKm > 0) {
                 this.averageSpeedKmh = totalDistanceKm / hours;
             }
         }
     }

     private TrackerLocation getLastLocationPoint() {
         return tripPoints.isEmpty() ? null :
                tripPoints.get(tripPoints.size() - 1).getLocation();
     }

     private Float calculateDistance(TrackerLocation loc1, TrackerLocation loc2) {
         // Simplified distance calculation (Haversine formula would be better)
         return 0.0f; // Implement actual distance calculation
     }

     public Duration getDuration() {
         if (isActive) {
             return Duration.between(startTime, Instant.now());
         } else {
             return Duration.between(startTime, endTime);
         }
     }

     // Getters and Setters
     public String getTripId() { return tripId; }
     public void setTripId(String tripId) { this.tripId = tripId; }

     public Vehicle getVehicle() { return vehicle; }
     public void setVehicle(Vehicle vehicle) { this.vehicle = vehicle; }

     public TrackerLocation getStartLocation() { return startLocation; }
     public void setStartLocation(TrackerLocation startLocation) { this.startLocation = startLocation; }

     public TrackerLocation getEndLocation() { return endLocation; }
     public void setEndLocation(TrackerLocation endLocation) { this.endLocation = endLocation; }

     public Instant getStartTime() { return startTime; }
     public void setStartTime(Instant startTime) { this.startTime = startTime; }

     public Instant getEndTime() { return endTime; }
     public void setEndTime(Instant endTime) { this.endTime = endTime; }

     public Boolean getIsActive() { return isActive; }
     public void setIsActive(Boolean isActive) { this.isActive = isActive; }

     public List<TripPoint> getTripPoints() { return tripPoints; }
     public void setTripPoints(List<TripPoint> tripPoints) { this.tripPoints = tripPoints; }

     public Instant getCreatedAt() { return createdAt; }
     public void setCreatedAt(Instant createdAt) { this.createdAt = createdAt; }

     public Instant getUpdatedAt() { return updatedAt; }
     public void setUpdatedAt(Instant updatedAt) { this.updatedAt = updatedAt; }

     // Additional getters/setters
     public TripStartReason getStartReason() { return startReason; }
     public void setStartReason(TripStartReason startReason) { this.startReason = startReason; }

     public TripEndReason getEndReason() { return endReason; }
     public void setEndReason(TripEndReason endReason) { this.endReason = endReason; }

     public Integer getAccOffDurationSeconds() { return accOffDurationSeconds; }
     public void setAccOffDurationSeconds(Integer accOffDurationSeconds) {
         this.accOffDurationSeconds = accOffDurationSeconds;
     }

     public Float getTotalDistanceKm() { return totalDistanceKm; }
     public void setTotalDistanceKm(Float totalDistanceKm) { this.totalDistanceKm = totalDistanceKm; }

     public Float getAverageSpeedKmh() { return averageSpeedKmh; }
     public void setAverageSpeedKmh(Float averageSpeedKmh) { this.averageSpeedKmh = averageSpeedKmh; }

     public Float getMaxSpeedKmh() { return maxSpeedKmh; }
     public void setMaxSpeedKmh(Float maxSpeedKmh) { this.maxSpeedKmh = maxSpeedKmh; }

     public Integer getIdleTimeMinutes() { return idleTimeMinutes; }
     public void setIdleTimeMinutes(Integer idleTimeMinutes) { this.idleTimeMinutes = idleTimeMinutes; }

     public Float getFuelConsumedLiters() { return fuelConsumedLiters; }
     public void setFuelConsumedLiters(Float fuelConsumedLiters) { this.fuelConsumedLiters = fuelConsumedLiters; }
 }```

 === ./src/main/java/com/jjenus/tracker/core/domain/entity/TripPoint.java ===
 ```.java
 package com.jjenus.tracker.core.domain.entity;

 import jakarta.persistence.*;
 import java.time.Instant;

 @Entity
 @Table(name = "trip_points")
 public class TripPoint {

     @Id
     @GeneratedValue(strategy = GenerationType.IDENTITY)
     @Column(name = "trip_point_id")
     private Long tripPointId;

     @ManyToOne(fetch = FetchType.LAZY)
     @JoinColumn(name = "trip_id", nullable = false)
     private Trip trip;

     @OneToOne(fetch = FetchType.LAZY)
     @JoinColumn(name = "location_id", nullable = false)
     private TrackerLocation location;

     @Column(name = "point_order", nullable = false)
     private Integer pointOrder;

     @Column(name = "segment_distance_km")
     private Float segmentDistanceKm;

     @Column(name = "segment_duration_minutes")
     private Float segmentDurationMinutes;

     @Column(name = "created_at")
     private Instant createdAt = Instant.now();

     // Getters and Setters
     public Long getTripPointId() { return tripPointId; }
     public void setTripPointId(Long tripPointId) { this.tripPointId = tripPointId; }

     public Trip getTrip() { return trip; }
     public void setTrip(Trip trip) { this.trip = trip; }

     public TrackerLocation getLocation() { return location; }
     public void setLocation(TrackerLocation location) { this.location = location; }

     public Integer getPointOrder() { return pointOrder; }
     public void setPointOrder(Integer pointOrder) { this.pointOrder = pointOrder; }

     public Float getSegmentDistanceKm() { return segmentDistanceKm; }
     public void setSegmentDistanceKm(Float segmentDistanceKm) { this.segmentDistanceKm = segmentDistanceKm; }

     public Instant getCreatedAt() { return createdAt; }
     public void setCreatedAt(Instant createdAt) { this.createdAt = createdAt; }

     public Float getSegmentDurationMinutes() { return segmentDurationMinutes; }
     public void setSegmentDurationMinutes(Float segmentDurationMinutes) {
         this.segmentDurationMinutes = segmentDurationMinutes;
     }
 }```

 === ./src/main/java/com/jjenus/tracker/core/domain/entity/Vehicle.java ===
 ```.java
 package com.jjenus.tracker.core.domain.entity;

 import com.jjenus.tracker.core.domain.enums.EngineState;
 import com.jjenus.tracker.core.domain.enums.TripEndReason;
 import jakarta.persistence.*;
 import java.time.Instant;
 import java.util.ArrayList;
 import java.util.List;

 @Entity
 @Table(name = "vehicles")
 public class Vehicle {

     @Id
     @Column(name = "vehicle_id", length = 50)
     private String vehicleId;

     @Column(name = "device_id", length = 50, unique = true)
     private String deviceId;

     @Column(name = "model", length = 100)
     private String model;

     @Column(name = "license_plate", length = 20)
     private String licensePlate;

     @Column(name = "vin", length = 17)
     private String vin;

     @Enumerated(EnumType.STRING)
     @Column(name = "engine_state", length = 20)
     private EngineState engineState = EngineState.OFF;

     @Column(name = "acc_status")
     private Boolean accStatus = false;

     @Column(name = "last_acc_on_time")
     private Instant lastAccOnTime;

     @Column(name = "last_acc_off_time")
     private Instant lastAccOffTime;

     @Column(name = "last_telemetry_time")
     private Instant lastTelemetryTime;

     @Column(name = "fuel_level")
     private Float fuelLevel;

     @Column(name = "odometer_km")
     private Float odometerKm;

     @Column(name = "is_fuel_cut_active")
     private Boolean fuelCutActive = false;

     @OneToOne(cascade = CascadeType.ALL)
     @JoinColumn(name = "current_location_id")
     private TrackerLocation currentLocation;

     @OneToMany(mappedBy = "vehicle", cascade = CascadeType.ALL, orphanRemoval = true)
     private List<Tracker> trackers = new ArrayList<>();

     @OneToMany(mappedBy = "vehicle", cascade = CascadeType.ALL, orphanRemoval = true)
     private List<Trip> trips = new ArrayList<>();

     @Column(name = "created_at")
     private Instant createdAt = Instant.now();

     @Column(name = "updated_at")
     private Instant updatedAt = Instant.now();

     @PreUpdate
     protected void onUpdate() {
         this.updatedAt = Instant.now();
     }

     // Business methods
     public void updateAccStatus(boolean accOn, Instant timestamp) {
         this.accStatus = accOn;

         if (accOn) {
             this.lastAccOnTime = timestamp;
         } else {
             this.lastAccOffTime = timestamp;
         }

         this.lastTelemetryTime = timestamp;
     }

     public void updateLocation(TrackerLocation location) {
         this.currentLocation = location;
         this.lastTelemetryTime = location.getRecordedAt();
     }

     public Trip getActiveTrip() {
         return trips.stream()
             .filter(Trip::getIsActive)
             .findFirst()
             .orElse(null);
     }

     public void addTrip(Trip trip) {
         trips.add(trip);
         trip.setVehicle(this);
     }

     public void endActiveTrip(TripEndReason reason, TrackerLocation endLocation) {
         Trip activeTrip = getActiveTrip();
         if (activeTrip != null) {
             activeTrip.endTrip(reason, endLocation);
         }
     }

     // Getters and Setters
     public String getVehicleId() { return vehicleId; }
     public void setVehicleId(String vehicleId) { this.vehicleId = vehicleId; }

     public String getDeviceId() { return deviceId; }
     public void setDeviceId(String deviceId) { this.deviceId = deviceId; }

     public String getModel() { return model; }
     public void setModel(String model) { this.model = model; }

     public EngineState getEngineState() { return engineState; }
     public void setEngineState(EngineState engineState) { this.engineState = engineState; }

     public Boolean getAccStatus() { return accStatus; }
     public void setAccStatus(Boolean accStatus) { this.accStatus = accStatus; }

     public Instant getLastAccOnTime() { return lastAccOnTime; }
     public void setLastAccOnTime(Instant lastAccOnTime) { this.lastAccOnTime = lastAccOnTime; }

     public Instant getLastAccOffTime() { return lastAccOffTime; }
     public void setLastAccOffTime(Instant lastAccOffTime) { this.lastAccOffTime = lastAccOffTime; }

     public Instant getLastTelemetryTime() { return lastTelemetryTime; }
     public void setLastTelemetryTime(Instant lastTelemetryTime) { this.lastTelemetryTime = lastTelemetryTime; }

     public TrackerLocation getCurrentLocation() { return currentLocation; }
     public void setCurrentLocation(TrackerLocation currentLocation) { this.currentLocation = currentLocation; }

     public List<Trip> getTrips() { return trips; }
     public void setTrips(List<Trip> trips) { this.trips = trips; }

     public Instant getCreatedAt() { return createdAt; }
     public void setCreatedAt(Instant createdAt) { this.createdAt = createdAt; }

     public Instant getUpdatedAt() { return updatedAt; }
     public void setUpdatedAt(Instant updatedAt) { this.updatedAt = updatedAt; }

     // Additional getters/setters
     public String getLicensePlate() { return licensePlate; }
     public void setLicensePlate(String licensePlate) { this.licensePlate = licensePlate; }

     public String getVin() { return vin; }
     public void setVin(String vin) { this.vin = vin; }

     public Float getFuelLevel() { return fuelLevel; }
     public void setFuelLevel(Float fuelLevel) { this.fuelLevel = fuelLevel; }

     public Float getOdometerKm() { return odometerKm; }
     public void setOdometerKm(Float odometerKm) { this.odometerKm = odometerKm; }

     public Boolean getFuelCutActive() { return fuelCutActive; }
     public void setFuelCutActive(Boolean fuelCutActive) { this.fuelCutActive = fuelCutActive; }

     public void addTracker(Tracker tracker) {
         trackers.add(tracker);
         tracker.setVehicle(this);
     }

     public void removeTracker(Tracker tracker) {
         trackers.remove(tracker);
         tracker.setVehicle(null);
     }

     public Tracker getActiveTracker() {
         return trackers.stream()
                 .filter(t -> Boolean.TRUE.equals(t.getIsOnline()))
                 .findFirst()
                 .orElse(null);
     }

     // Getters and setters
     public List<Tracker> getTrackers() { return trackers; }
     public void setTrackers(List<Tracker> trackers) { this.trackers = trackers; }
 }```

 === ./src/main/java/com/jjenus/tracker/core/domain/enums/CommandStatus.java ===
 ```.java
 package com.jjenus.tracker.core.domain.enums;

 public enum CommandStatus {
     PENDING,
     SENT,
     DELIVERED,
     FAILED,
     TIMEOUT,
     CANCELLED
 }
 ```

 === ./src/main/java/com/jjenus/tracker/core/domain/enums/CommandType.java ===
 ```.java
 package com.jjenus.tracker.core.domain.enums;

 public enum CommandType {
     // GT06 Protocol Commands
     FUEL_CUT("Cut fuel supply"),
     FUEL_RESTORE("Restore fuel supply"),
     ENGINE_START("Start engine"),
     ENGINE_STOP("Stop engine"),
     SET_GEOFENCE("Configure geofence"),
     SET_OVERSPEED_LIMIT("Set speed limit"),
     SET_HEARTBEAT_INTERVAL("Set heartbeat interval"),
     SET_IP_PORT("Configure server IP/port"),
     SET_APN("Configure APN settings"),
     REBOOT_DEVICE("Reboot device"),
     FACTORY_RESET("Factory reset"),
     READ_STATUS("Read device status"),
     UPDATE_FIRMWARE("Update firmware"),

     // General Commands
     LOCATION_REQUEST("Request immediate location"),
     HISTORY_REQUEST("Request location history"),
     SET_WORKING_MODE("Set working mode"),
     SET_ALARM_MODE("Set alarm mode"),
     SET_CENTER_NUMBER("Set center phone number"),
     SET_ADMIN_NUMBER("Set admin numbers"),
     CHANGE_PASSWORD("Change device password");

     private final String description;

     CommandType(String description) {
         this.description = description;
     }

     public String getDescription() {
         return description;
     }
 }
 ```

 === ./src/main/java/com/jjenus/tracker/core/domain/enums/EngineState.java ===
 ```.java
 package com.jjenus.tracker.core.domain.enums;

 public enum EngineState {
     OFF,
     ON,
     IDLE,
     MOVING,
     AWAITING_CUTOFF,
     FUEL_CUT_ACTIVE
 }
 ```

 === ./src/main/java/com/jjenus/tracker/core/domain/enums/TrackerStatus.java ===
 ```.java
 package com.jjenus.tracker.core.domain.enums;

 public enum TrackerStatus {
     ACTIVE,
     INACTIVE,
     MAINTENANCE,
     DECOMMISSIONED,
     STOLEN
 }```

 === ./src/main/java/com/jjenus/tracker/core/domain/enums/TripEndReason.java ===
 ```.java
 package com.jjenus.tracker.core.domain.enums;

 public enum TripEndReason {
     ACC_OFF,
     TIMEOUT,
     MANUAL,
     CONNECTION_LOST,
     GEOFENCE_EXIT,
     FUEL_CUT
 }```

 === ./src/main/java/com/jjenus/tracker/core/domain/enums/TripStartReason.java ===
 ```.java
 package com.jjenus.tracker.core.domain.enums;

 public enum TripStartReason {
     ACC_ON,
     MANUAL,
     AUTO_DETECTED,
     SCHEDULED
 }```

 === ./src/main/java/com/jjenus/tracker/core/domain/FuelCutRequestedEvent.java ===
 ```.java
 package com.jjenus.tracker.core.domain;

 import com.jjenus.tracker.shared.pubsub.DomainEvent;

 public class FuelCutRequestedEvent extends DomainEvent {
     private final String vehicleId;
     private final String deviceId;

     public FuelCutRequestedEvent(String vehicleId, String deviceId) {
         this.vehicleId = vehicleId;
         this.deviceId = deviceId;
     }

     public String getVehicleId() { return vehicleId; }
     public String getDeviceId() { return deviceId; }
 }
 ```

 === ./src/main/java/com/jjenus/tracker/core/domain/FuelStatus.java ===
 ```.java
 package com.jjenus.tracker.core.domain;

 import java.time.Instant;

 public record FuelStatus(
     float currentLevel,
     float lastConsumption,
     Instant lastUpdated
 ) {
     public boolean isLow() {
         return currentLevel < 15.0f;
     }

     public boolean isEmpty() {
         return currentLevel < 5.0f;
     }
 }
 ```

 === ./src/main/java/com/jjenus/tracker/core/domain/Trip.java ===
 ```.java
 package com.jjenus.tracker.core.domain;

 import com.jjenus.tracker.shared.domain.LocationPoint;

 import java.time.Duration;
 import java.time.Instant;
 import java.util.*;

 public class Trip {
     private final String tripId;
     private final String vehicleId;
     private final Instant startTime;
     private Instant endTime;
     private LocationPoint startLocation;
     private LocationPoint endLocation;
     private final List<LocationPoint> routePoints;
     private float totalDistance;

     public Trip(String vehicleId, LocationPoint startLocation) {
         this.tripId = "TRIP_" + vehicleId + "_" + UUID.randomUUID().toString().substring(0, 8);
         this.vehicleId = vehicleId;
         this.startTime = startLocation.timestamp();
         this.startLocation = startLocation;
         this.routePoints = new ArrayList<>();
         this.routePoints.add(startLocation);
         this.totalDistance = 0.0f;
     }

     public void addLocation(LocationPoint location) {
         if (!routePoints.isEmpty()) {
             LocationPoint lastPoint = routePoints.get(routePoints.size() - 1);
             totalDistance += lastPoint.distanceTo(location);
         }
         routePoints.add(location);
     }

     public void end(LocationPoint endLocation) {
         this.endTime = endLocation.timestamp(); // Use the location's timestamp!
         this.endLocation = endLocation;
         addLocation(endLocation);
     }

     public Duration getDuration() {
         if (endTime == null) {
             // Active trip - duration from start to now
             return Duration.between(startTime, Instant.now());
         } else {
             // Ended trip - fixed duration between start and end timestamps
             return Duration.between(startTime, endTime);
         }
     }

     public float getAverageSpeed() {
         Duration duration = getDuration();
         long seconds = duration.getSeconds();
         if (seconds == 0) return 0.0f;

         // Speed = distance / time (convert seconds to hours)
         return totalDistance / (seconds / 3600.0f);
     }

     // Getters
     public String getTripId() { return tripId; }
     public String getVehicleId() { return vehicleId; }
     public Instant getStartTime() { return startTime; }
     public Instant getEndTime() { return endTime; }
     public LocationPoint getStartLocation() { return startLocation; }
     public LocationPoint getEndLocation() { return endLocation; }
     public List<LocationPoint> getRoutePoints() {
         return Collections.unmodifiableList(routePoints);
     }
     public float getTotalDistance() { return totalDistance; }
     public boolean isActive() { return endTime == null; }

     @Override
     public String toString() {
         return "Trip{" +
                 "tripId='" + tripId + '\'' +
                 ", vehicleId='" + vehicleId + '\'' +
                 ", startTime=" + startTime +
                 ", endTime=" + endTime +
                 ", totalDistance=" + totalDistance +
                 ", isActive=" + isActive() +
                 '}';
     }

     @Override
     public boolean equals(Object o) {
         if (this == o) return true;
         if (o == null || getClass() != o.getClass()) return false;
         Trip trip = (Trip) o;
         return Objects.equals(tripId, trip.tripId);
     }

     @Override
     public int hashCode() {
         return Objects.hash(tripId);
     }
 }```

 === ./src/main/java/com/jjenus/tracker/core/domain/Vehicle.java ===
 ```.java
 package com.jjenus.tracker.core.domain;

 import com.jjenus.tracker.core.domain.enums.EngineState;
 import com.jjenus.tracker.core.exception.TripException;
 import com.jjenus.tracker.core.exception.VehicleException;
 import com.jjenus.tracker.shared.domain.LocationPoint;

 import java.time.Duration;
 import java.time.Instant;
 import java.util.ArrayList;
 import java.util.List;

 public class Vehicle {
     private final String vehicleId;
     private String deviceId;
     private LocationPoint currentLocation;
     private EngineState engineState;
     private FuelStatus fuelStatus;
     private boolean isFuelCutActive;
     private Instant lastMovementTime;
     private Trip activeTrip;
     private final List<String> recentAlerts;

     public Vehicle(String vehicleId) {
         this.vehicleId = vehicleId;
         this.engineState = EngineState.OFF;
         this.isFuelCutActive = false;
         this.currentLocation = new LocationPoint(0.0, 0.0, 0.0f, Instant.now());
         this.fuelStatus = new FuelStatus(100.0f, 0.0f, Instant.now());
         this.recentAlerts = new ArrayList<>();
     }

     public void processNewTelemetry(LocationPoint newLocation) {
         if (!newLocation.isValid()) {
             throw VehicleException.invalidLocationData();
         }

         this.currentLocation = newLocation;

         if (newLocation.speedKmh() > 0) {
             this.engineState = EngineState.MOVING;
             this.lastMovementTime = Instant.now();

             if (this.activeTrip == null) {
                 startTrip(newLocation);
             }
         } else if (this.engineState == EngineState.MOVING) {
             this.engineState = EngineState.IDLE;
             this.lastMovementTime = Instant.now();
         }

         if (this.engineState == EngineState.MOVING && this.activeTrip != null) {
             this.activeTrip.addLocation(newLocation);
         }
     }

     private void startTrip(LocationPoint startLocation) {
         if (this.activeTrip != null) {
             throw com.jjenus.tracker.core.exception.TripException.alreadyActive(vehicleId);
         }
         this.activeTrip = new Trip(this.vehicleId, startLocation);
         System.out.println("DOMAIN EVENT: Trip started for vehicle " + vehicleId);
     }

     public void endTrip(LocationPoint endLocation) {
         if (this.activeTrip == null) {
             throw TripException.notActive(vehicleId);
         }
         this.activeTrip.end(endLocation);
         System.out.println("DOMAIN EVENT: Trip ended for vehicle " + vehicleId);
         this.activeTrip = null;
     }

     public void issueFuelCutOffCommand() {
         if (this.currentLocation.speedKmh() > 10) {
             throw VehicleException.fuelCutNotAllowedWhileMoving(this.currentLocation.speedKmh());
         }

         if (this.isFuelCutActive) {
             throw VehicleException.fuelCutAlreadyActive();
         }

         this.isFuelCutActive = true;
         this.engineState = EngineState.FUEL_CUT_ACTIVE;

         System.out.println("DOMAIN EVENT: Fuel cut requested for vehicle " + vehicleId);
     }

     public void issueFuelRestoreCommand() {
         this.isFuelCutActive = false;

         if (this.currentLocation.speedKmh() > 0) {
             this.engineState = EngineState.MOVING;
         } else {
             this.engineState = EngineState.ON;
         }

         System.out.println("DOMAIN EVENT: Fuel restore requested for vehicle " + vehicleId);
     }

     public Duration getIdleDuration() {
         if (this.lastMovementTime == null || this.engineState != EngineState.IDLE) {
             return Duration.ZERO;
         }
         return Duration.between(this.lastMovementTime, Instant.now());
     }

     public void addAlert(String alertMessage) {
         this.recentAlerts.add(Instant.now() + ": " + alertMessage);
         if (this.recentAlerts.size() > 100) {
             this.recentAlerts.remove(0);
         }
     }

     public String getVehicleId() { return vehicleId; }
     public String getDeviceId() { return deviceId; }
     public LocationPoint getCurrentLocation() { return currentLocation; }
     public EngineState getEngineState() { return engineState; }
     public FuelStatus getFuelStatus() { return fuelStatus; }
     public boolean isFuelCutActive() { return isFuelCutActive; }
     public Trip getActiveTrip() { return activeTrip; }
     public List<String> getRecentAlerts() { return new ArrayList<>(recentAlerts); }

     protected void setDeviceId(String deviceId) { this.deviceId = deviceId; }
     protected void setFuelStatus(FuelStatus fuelStatus) { this.fuelStatus = fuelStatus; }
 }
 ```

 === ./src/main/java/com/jjenus/tracker/core/exception/TripException.java ===
 ```.java
 package com.jjenus.tracker.core.exception;

 import com.jjenus.tracker.shared.exception.BusinessRuleException;

 public class TripException extends BusinessRuleException {

     public TripException(String errorCode, String message) {
         super(errorCode, message);
     }

     public TripException(String errorCode, String message, Throwable cause) {
         super(errorCode, message, cause);
     }

     public static TripException alreadyActive(String vehicleId) {
         return new TripException(
             "TRIP_ALREADY_ACTIVE",
             String.format("Vehicle '%s' already has an active trip", vehicleId)
         );
     }

     public static TripException notActive(String vehicleId) {
         return new TripException(
             "TRIP_NOT_ACTIVE",
             String.format("Vehicle '%s' does not have an active trip", vehicleId)
         );
     }

     public static TripException notFound(String tripId) {
         return new TripException(
             "TRIP_NOT_FOUND",
             String.format("Trip with ID '%s' not found", tripId)
         );
     }

     public static TripException invalidDuration() {
         return new TripException(
             "TRIP_INVALID_DURATION",
             "Trip duration cannot be negative"
         );
     }
 }
 ```

 === ./src/main/java/com/jjenus/tracker/core/exception/VehicleException.java ===
 ```.java
 package com.jjenus.tracker.core.exception;

 import com.jjenus.tracker.shared.exception.BusinessRuleException;

 public class VehicleException extends BusinessRuleException {

     public VehicleException(String errorCode, String message) {
         super(errorCode, message);
     }

     public VehicleException(String errorCode, String message, Throwable cause) {
         super(errorCode, message, cause);
     }

     // Specific vehicle exceptions
     public static VehicleException fuelCutNotAllowedWhileMoving(float speed) {
         return new VehicleException(
             "VEHICLE_FUEL_CUT_MOVING",
             String.format("Cannot cut fuel while moving at %.1f km/h. Maximum allowed: 10 km/h", speed)
         );
     }

     public static VehicleException fuelCutAlreadyActive() {
         return new VehicleException(
             "VEHICLE_FUEL_CUT_ACTIVE",
             "Fuel cut is already active for this vehicle"
         );
     }

     public static VehicleException invalidLocationData() {
         return new VehicleException(
             "VEHICLE_INVALID_LOCATION",
             "Invalid location data provided"
         );
     }

     public static VehicleException notFound(String vehicleId) {
         return new VehicleException(
             "VEHICLE_NOT_FOUND",
             String.format("Vehicle with ID '%s' not found", vehicleId)
         );
     }

     public static VehicleException deviceAlreadyAssigned(String deviceId) {
         return new VehicleException(
             "VEHICLE_DEVICE_ASSIGNED",
             String.format("Device with ID '%s' is already assigned to another vehicle", deviceId)
         );
     }
 }
 ```

 === ./src/main/java/com/jjenus/tracker/core/infrastructure/repository/DeviceCommandRepository.java ===
 ```.java
 package com.jjenus.tracker.core.infrastructure.repository;

 import com.jjenus.tracker.core.domain.enums.CommandStatus;
 import com.jjenus.tracker.core.domain.entity.DeviceCommand;
 import org.springframework.data.domain.Page;
 import org.springframework.data.domain.Pageable;
 import org.springframework.data.jpa.repository.JpaRepository;
 import org.springframework.data.jpa.repository.Modifying;
 import org.springframework.data.jpa.repository.Query;
 import org.springframework.data.repository.query.Param;
 import org.springframework.stereotype.Repository;
 import org.springframework.transaction.annotation.Transactional;

 import java.time.Instant;
 import java.util.List;

 @Repository
 public interface DeviceCommandRepository extends JpaRepository<DeviceCommand, Long> {

     Page<DeviceCommand> findByTrackerTrackerId(String trackerId, Pageable pageable);

     List<DeviceCommand> findByStatus(CommandStatus status);

     List<DeviceCommand> findByTrackerTrackerIdAndStatus(String trackerId, CommandStatus status);

     @Query("SELECT dc FROM DeviceCommand dc WHERE dc.status IN ('PENDING', 'FAILED', 'TIMEOUT') " +
             "AND dc.retryCount < dc.maxRetries " +
             "AND dc.createdAt >= :cutoffTime " +
             "ORDER BY dc.createdAt")
     List<DeviceCommand> findPendingAndRetryableCommands(@Param("cutoffTime") Instant cutoffTime);

     @Query("SELECT dc FROM DeviceCommand dc WHERE dc.tracker.deviceId = :deviceId " +
             "AND dc.status IN ('SENT', 'DELIVERED') " +
             "ORDER BY dc.sentAt DESC LIMIT 10")
     List<DeviceCommand> findRecentCommandsByDeviceId(@Param("deviceId") String deviceId);

     @Query("SELECT COUNT(dc) FROM DeviceCommand dc WHERE dc.status = 'PENDING' " +
             "AND dc.tracker.trackerId = :trackerId")
     Long countPendingCommands(@Param("trackerId") String trackerId);

     @Transactional
     @Modifying
     @Query("UPDATE DeviceCommand dc SET dc.status = 'CANCELLED', dc.updatedAt = :now " +
             "WHERE dc.commandId = :commandId AND dc.status = 'PENDING'")
     int cancelPendingCommand(@Param("commandId") Long commandId, @Param("now") Instant now);

     @Transactional
     @Modifying
     @Query("DELETE FROM DeviceCommand dc WHERE dc.createdAt < :cutoffTime " +
             "AND dc.status IN ('DELIVERED', 'CANCELLED', 'FAILED')")
     int cleanupOldCommands(@Param("cutoffTime") Instant cutoffTime);
 }
 ```

 === ./src/main/java/com/jjenus/tracker/core/infrastructure/repository/TrackerLocationRepository.java ===
 ```.java
 package com.jjenus.tracker.core.infrastructure.repository;

 import com.jjenus.tracker.core.domain.entity.TrackerLocation;
 import org.springframework.data.domain.Page;
 import org.springframework.data.domain.Pageable;
 import org.springframework.data.jpa.repository.JpaRepository;
 import org.springframework.data.jpa.repository.Query;
 import org.springframework.data.repository.query.Param;
 import org.springframework.stereotype.Repository;

 import java.time.Instant;
 import java.util.List;

 @Repository
 public interface TrackerLocationRepository extends JpaRepository<TrackerLocation, Long> {

     List<TrackerLocation> findByTrackerTrackerIdOrderByRecordedAtDesc(String trackerId);

     Page<TrackerLocation> findByTrackerTrackerId(String trackerId, Pageable pageable);

     @Query("SELECT tl FROM TrackerLocation tl WHERE tl.tracker.trackerId = :trackerId " +
            "AND tl.recordedAt BETWEEN :startTime AND :endTime " +
            "ORDER BY tl.recordedAt")
     List<TrackerLocation> findByTrackerAndTimeRange(
         @Param("trackerId") String trackerId,
         @Param("startTime") Instant startTime,
         @Param("endTime") Instant endTime);

     @Query("SELECT tl FROM TrackerLocation tl WHERE tl.tracker.deviceId = :deviceId " +
            "ORDER BY tl.recordedAt DESC LIMIT 1")
     TrackerLocation findLatestByDeviceId(@Param("deviceId") String deviceId);

     @Query("SELECT COUNT(tl) FROM TrackerLocation tl WHERE tl.tracker.trackerId = :trackerId")
     Long countByTrackerId(@Param("trackerId") String trackerId);

     @Query("SELECT tl FROM TrackerLocation tl WHERE tl.accStatus = false " +
            "AND tl.recordedAt >= :startTime")
     List<TrackerLocation> findAccOffEvents(@Param("startTime") Instant startTime);
 }```

 === ./src/main/java/com/jjenus/tracker/core/infrastructure/repository/TrackerRawDataRepository.java ===
 ```.java
 package com.jjenus.tracker.core.infrastructure.repository;

 import com.jjenus.tracker.core.domain.entity.TrackerRawData;
 import org.springframework.data.domain.Page;
 import org.springframework.data.domain.Pageable;
 import org.springframework.data.jpa.repository.JpaRepository;
 import org.springframework.data.jpa.repository.Modifying;
 import org.springframework.data.jpa.repository.Query;
 import org.springframework.data.repository.query.Param;
 import org.springframework.stereotype.Repository;
 import org.springframework.transaction.annotation.Transactional;

 import java.time.Instant;
 import java.util.List;

 @Repository
 public interface TrackerRawDataRepository extends JpaRepository<TrackerRawData, Long> {

     Page<TrackerRawData> findByTrackerTrackerId(String trackerId, Pageable pageable);

     List<TrackerRawData> findByProcessed(boolean processed);

     List<TrackerRawData> findByReceivedAtBetween(Instant startTime, Instant endTime);

     @Query("SELECT COUNT(trd) FROM TrackerRawData trd WHERE trd.processed = false")
     Long countUnprocessed();

     @Transactional
     @Modifying
     @Query("UPDATE TrackerRawData trd SET trd.processed = true, trd.parsedData = :parsedData " +
            "WHERE trd.rawDataId = :rawDataId")
     int markAsProcessed(@Param("rawDataId") Long rawDataId, @Param("parsedData") String parsedData);

     @Transactional
     @Modifying
     @Query("UPDATE TrackerRawData trd SET trd.processed = false, trd.processingError = :error " +
            "WHERE trd.rawDataId = :rawDataId")
     int markAsFailed(@Param("rawDataId") Long rawDataId, @Param("error") String error);

     @Transactional
     @Modifying
     @Query("DELETE FROM TrackerRawData trd WHERE trd.receivedAt < :cutoffTime")
     int deleteOldRecords(@Param("cutoffTime") Instant cutoffTime);
 }```

 === ./src/main/java/com/jjenus/tracker/core/infrastructure/repository/TrackerRepository.java ===
 ```.java
 package com.jjenus.tracker.core.infrastructure.repository;

 import com.jjenus.tracker.core.domain.entity.Tracker;
 import com.jjenus.tracker.core.domain.enums.TrackerStatus;
 import org.springframework.data.jpa.repository.JpaRepository;
 import org.springframework.data.jpa.repository.Query;
 import org.springframework.data.repository.query.Param;
 import org.springframework.stereotype.Repository;

 import java.time.Instant;
 import java.util.List;
 import java.util.Optional;

 @Repository
 public interface TrackerRepository extends JpaRepository<Tracker, String> {

     Optional<Tracker> findByDeviceId(String deviceId);

 //    Optional<Tracker> findByImei(String imei);

     List<Tracker> findByIsOnline(boolean isOnline);

     List<Tracker> findByStatus(TrackerStatus status);

     @Query("SELECT t FROM Tracker t WHERE t.lastSeen < :cutoffTime AND t.isOnline = true")
     List<Tracker> findStaleConnections(@Param("cutoffTime") Instant cutoffTime);

     @Query("SELECT t FROM Tracker t WHERE t.batteryLevel < :threshold")
     List<Tracker> findTrackersWithLowBattery(@Param("threshold") float threshold);

     boolean existsByDeviceId(String deviceId);

 //    boolean existsByImei(String imei);
 }```

 === ./src/main/java/com/jjenus/tracker/core/infrastructure/repository/TripRepository.java ===
 ```.java
 package com.jjenus.tracker.core.infrastructure.repository;

 import com.jjenus.tracker.core.domain.entity.Trip;
 import com.jjenus.tracker.core.domain.enums.TripEndReason;
 import org.springframework.data.domain.Page;
 import org.springframework.data.domain.Pageable;
 import org.springframework.data.jpa.repository.JpaRepository;
 import org.springframework.data.jpa.repository.Query;
 import org.springframework.data.repository.query.Param;
 import org.springframework.stereotype.Repository;

 import java.time.Instant;
 import java.util.List;
 import java.util.Optional;

 @Repository
 public interface TripRepository extends JpaRepository<Trip, String> {

     List<Trip> findByVehicleVehicleId(String vehicleId);

     Optional<Trip> findByVehicleVehicleIdAndIsActive(String vehicleId, boolean isActive);

     List<Trip> findByVehicleVehicleIdAndStartTimeBetween(
         String vehicleId, Instant startTime, Instant endTime);

     List<Trip> findByIsActive(boolean isActive);

     @Query("SELECT t FROM Trip t WHERE t.vehicle.vehicleId = :vehicleId " +
            "AND t.endReason = :endReason " +
            "AND t.endTime >= :startTime")
     List<Trip> findTripsByEndReason(
         @Param("vehicleId") String vehicleId,
         @Param("endReason") TripEndReason endReason,
         @Param("startTime") Instant startTime);

     @Query("SELECT t FROM Trip t WHERE t.vehicle.vehicleId = :vehicleId " +
            "AND t.isActive = false " +
            "AND t.totalDistanceKm > :minDistance " +
            "ORDER BY t.endTime DESC")
     Page<Trip> findRecentCompletedTrips(
         @Param("vehicleId") String vehicleId,
         @Param("minDistance") float minDistance,
         Pageable pageable);

     @Query("SELECT SUM(t.totalDistanceKm) FROM Trip t " +
            "WHERE t.vehicle.vehicleId = :vehicleId " +
            "AND t.isActive = false " +
            "AND t.endTime BETWEEN :startTime AND :endTime")
     Float getTotalDistanceForPeriod(
         @Param("vehicleId") String vehicleId,
         @Param("startTime") Instant startTime,
         @Param("endTime") Instant endTime);
 }```

 === ./src/main/java/com/jjenus/tracker/core/infrastructure/repository/VehicleRepository.java ===
 ```.java
 package com.jjenus.tracker.core.infrastructure.repository;

 import com.jjenus.tracker.core.domain.entity.Vehicle;
 import org.springframework.data.jpa.repository.JpaRepository;
 import org.springframework.data.jpa.repository.Query;
 import org.springframework.data.repository.query.Param;
 import org.springframework.stereotype.Repository;

 import java.time.Instant;
 import java.util.List;
 import java.util.Optional;

 @Repository
 public interface VehicleRepository extends JpaRepository<Vehicle, String> {

     Optional<Vehicle> findByDeviceId(String deviceId);

     Optional<Vehicle> findByLicensePlate(String licensePlate);

     List<Vehicle> findByEngineState(String engineState);

     @Query("SELECT v FROM Vehicle v WHERE v.lastTelemetryTime < :cutoffTime AND v.accStatus = true")
     List<Vehicle> findVehiclesWithStaleTelemetry(@Param("cutoffTime") Instant cutoffTime);

     @Query("SELECT v FROM Vehicle v WHERE EXISTS (SELECT t FROM v.trips t WHERE t.isActive = true)")
     List<Vehicle> findVehiclesWithActiveTrips();

     @Query("SELECT v FROM Vehicle v WHERE v.fuelCutActive = true")
     List<Vehicle> findVehiclesWithActiveFuelCut();

     boolean existsByDeviceId(String deviceId);

     boolean existsByLicensePlate(String licensePlate);
 }```)


 whats done so far:
 (I'll create a complete, production-ready API layer with proper caching for all repositories in the core module. I'll structure it with clear separation of concerns, proper DTOs, and Spring Cache annotations.

  ## **1. DTO Layer**

  ### **Vehicle DTOs**

  ```java
  // === VehicleRequest.java ===
  package com.jjenus.tracker.core.api.dto;

  import jakarta.validation.constraints.NotBlank;
  import jakarta.validation.constraints.Pattern;
  import jakarta.validation.constraints.Size;
  import lombok.Data;
  import org.hibernate.validator.constraints.Range;

  import java.time.Instant;

  @Data
  public class VehicleRequest {
      @NotBlank(message = "Vehicle ID is required")
      @Size(min = 3, max = 50, message = "Vehicle ID must be 3-50 characters")
      private String vehicleId;

      @Size(max = 50, message = "Device ID must be max 50 characters")
      private String deviceId;

      @Size(max = 100, message = "Model must be max 100 characters")
      private String model;

      @Size(max = 20, message = "License plate must be max 20 characters")
      private String licensePlate;

      @Size(max = 17, message = "VIN must be max 17 characters")
      private String vin;

      private Float fuelLevel;

      @Range(min = 0, max = 999999, message = "Odometer must be between 0-999,999")
      private Float odometerKm;
  }

  // === VehicleResponse.java ===
  package com.jjenus.tracker.core.api.dto;

  import com.fasterxml.jackson.annotation.JsonFormat;
  import com.jjenus.tracker.core.domain.enums.EngineState;
  import lombok.Data;

  import java.time.Instant;

  @Data
  public class VehicleResponse {
      private String vehicleId;
      private String deviceId;
      private String model;
      private String licensePlate;
      private String vin;
      private EngineState engineState;
      private Boolean accStatus;
      private Float fuelLevel;
      private Float odometerKm;
      private Boolean fuelCutActive;

      private LocationResponse currentLocation;

      @JsonFormat(pattern = "yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", timezone = "UTC")
      private Instant lastAccOnTime;

      @JsonFormat(pattern = "yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", timezone = "UTC")
      private Instant lastAccOffTime;

      @JsonFormat(pattern = "yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", timezone = "UTC")
      private Instant lastTelemetryTime;

      @JsonFormat(pattern = "yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", timezone = "UTC")
      private Instant createdAt;

      @JsonFormat(pattern = "yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", timezone = "UTC")
      private Instant updatedAt;
  }

  // === VehicleUpdateRequest.java ===
  package com.jjenus.tracker.core.api.dto;

  import jakarta.validation.constraints.Size;
  import lombok.Data;
  import org.hibernate.validator.constraints.Range;

  @Data
  public class VehicleUpdateRequest {
      @Size(max = 100, message = "Model must be max 100 characters")
      private String model;

      @Size(max = 20, message = "License plate must be max 20 characters")
      private String licensePlate;

      @Size(max = 17, message = "VIN must be max 17 characters")
      private String vin;

      @Range(min = 0, max = 100, message = "Fuel level must be 0-100%")
      private Float fuelLevel;

      @Range(min = 0, max = 999999, message = "Odometer must be between 0-999,999")
      private Float odometerKm;

      private Boolean fuelCutActive;
  }

  // === VehicleSearchRequest.java ===
  package com.jjenus.tracker.core.api.dto;

  import lombok.Data;
  import org.springframework.data.domain.Sort;

  import java.time.Instant;

  @Data
  public class VehicleSearchRequest {
      private Integer page = 0;
      private Integer size = 20;
      private String sortBy = "vehicleId";
      private Sort.Direction sortDirection = Sort.Direction.ASC;
      private String search;
      private String engineState;
      private Boolean accStatus;
      private Boolean fuelCutActive;
      private Boolean hasActiveTrip;
      private Instant lastTelemetryBefore;
      private Instant lastTelemetryAfter;
  }
  ```

  ### **Tracker DTOs**

  ```java
  // === TrackerRequest.java ===
  package com.jjenus.tracker.core.api.dto;

  import jakarta.validation.constraints.NotBlank;
  import jakarta.validation.constraints.Size;
  import lombok.Data;

  @Data
  public class TrackerRequest {
      @NotBlank(message = "Tracker ID is required")
      @Size(min = 3, max = 50, message = "Tracker ID must be 3-50 characters")
      private String trackerId;

      @NotBlank(message = "Device ID is required")
      @Size(max = 50, message = "Device ID must be max 50 characters")
      private String deviceId;

      @Size(max = 100, message = "Model must be max 100 characters")
      private String model;

      @Size(max = 20, message = "Protocol must be max 20 characters")
      private String protocol;

      @Size(max = 50, message = "Firmware version must be max 50 characters")
      private String firmwareVersion;

      @Size(max = 20, message = "SIM number must be max 20 characters")
      private String simNumber;

      private String vehicleId;
  }

  // === TrackerResponse.java ===
  package com.jjenus.tracker.core.api.dto;

  import com.fasterxml.jackson.annotation.JsonFormat;
  import com.jjenus.tracker.core.domain.enums.TrackerStatus;
  import lombok.Data;

  import java.time.Instant;

  @Data
  public class TrackerResponse {
      private String trackerId;
      private String deviceId;
      private String model;
      private String protocol;
      private String firmwareVersion;
      private String simNumber;
      private Float batteryLevel;
      private Integer signalStrength;
      private Boolean isOnline;
      private TrackerStatus status;
      private String vehicleId;

      @JsonFormat(pattern = "yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", timezone = "UTC")
      private Instant lastSeen;

      @JsonFormat(pattern = "yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", timezone = "UTC")
      private Instant createdAt;

      @JsonFormat(pattern = "yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", timezone = "UTC")
      private Instant updatedAt;
  }

  // === TrackerUpdateRequest.java ===
  package com.jjenus.tracker.core.api.dto;

  import jakarta.validation.constraints.Size;
  import lombok.Data;
  import org.hibernate.validator.constraints.Range;

  @Data
  public class TrackerUpdateRequest {
      @Size(max = 100, message = "Model must be max 100 characters")
      private String model;

      @Size(max = 20, message = "Protocol must be max 20 characters")
      private String protocol;

      @Size(max = 50, message = "Firmware version must be max 50 characters")
      private String firmwareVersion;

      @Size(max = 20, message = "SIM number must be max 20 characters")
      private String simNumber;

      @Range(min = 0, max = 100, message = "Battery level must be 0-100%")
      private Float batteryLevel;

      @Range(min = 0, max = 5, message = "Signal strength must be 0-5")
      private Integer signalStrength;

      private Boolean isOnline;
      private String vehicleId;
  }

  // === TrackerStatusRequest.java ===
  package com.jjenus.tracker.core.api.dto;

  import lombok.Data;
  import org.hibernate.validator.constraints.Range;

  @Data
  public class TrackerStatusRequest {
      @Range(min = 0, max = 100, message = "Battery level must be 0-100%")
      private Float batteryLevel;

      @Range(min = 0, max = 5, message = "Signal strength must be 0-5")
      private Integer signalStrength;

      private Boolean isOnline;
  }
  ```

  ### **Trip DTOs**

  ```java
  // === TripResponse.java ===
  package com.jjenus.tracker.core.api.dto;

  import com.fasterxml.jackson.annotation.JsonFormat;
  import com.jjenus.tracker.core.domain.enums.TripEndReason;
  import com.jjenus.tracker.core.domain.enums.TripStartReason;
  import lombok.Data;

  import java.time.Duration;
  import java.time.Instant;

  @Data
  public class TripResponse {
      private String tripId;
      private String vehicleId;
      private LocationResponse startLocation;
      private LocationResponse endLocation;
      private TripStartReason startReason;
      private TripEndReason endReason;

      @JsonFormat(pattern = "yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", timezone = "UTC")
      private Instant startTime;

      @JsonFormat(pattern = "yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", timezone = "UTC")
      private Instant endTime;

      private Integer accOffDurationSeconds;
      private Float totalDistanceKm;
      private Float averageSpeedKmh;
      private Float maxSpeedKmh;
      private Integer idleTimeMinutes;
      private Float fuelConsumedLiters;
      private Boolean isActive;
      private Duration duration;

      @JsonFormat(pattern = "yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", timezone = "UTC")
      private Instant createdAt;

      @JsonFormat(pattern = "yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", timezone = "UTC")
      private Instant updatedAt;
  }

  // === TripSearchRequest.java ===
  package com.jjenus.tracker.core.api.dto;

  import lombok.Data;
  import org.springframework.data.domain.Sort;

  import java.time.Instant;

  @Data
  public class TripSearchRequest {
      private Integer page = 0;
      private Integer size = 20;
      private String sortBy = "startTime";
      private Sort.Direction sortDirection = Sort.Direction.DESC;
      private String vehicleId;
      private Boolean isActive;
      private TripEndReason endReason;
      private Instant startTimeFrom;
      private Instant startTimeTo;
      private Instant endTimeFrom;
      private Instant endTimeTo;
      private Float minDistance;
      private Float maxDistance;
  }

  // === TripStatisticsResponse.java ===
  package com.jjenus.tracker.core.api.dto;

  import lombok.Data;

  import java.time.Instant;

  @Data
  public class TripStatisticsResponse {
      private String vehicleId;
      private Instant periodStart;
      private Instant periodEnd;
      private Integer totalTrips;
      private Float totalDistanceKm;
      private Float averageDistanceKm;
      private Float averageSpeedKmh;
      private Float totalFuelConsumedLiters;
      private Float averageFuelConsumption;
      private Integer totalIdleTimeMinutes;
      private Duration totalDuration;
  }
  ```

  ### **Location & Command DTOs**

  ```java
  // === LocationResponse.java ===
  package com.jjenus.tracker.core.api.dto;

  import com.fasterxml.jackson.annotation.JsonFormat;
  import lombok.Data;

  import java.time.Instant;

  @Data
  public class LocationResponse {
      private Double latitude;
      private Double longitude;
      private Float speedKmh;
      private Float heading;
      private Float altitude;
      private String validity;
      private Float odometerKm;
      private Float batteryVoltage;
      private Integer signalStrength;
      private Boolean accStatus;
      private String engineStatus;
      private String deviceStatus;

      @JsonFormat(pattern = "yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", timezone = "UTC")
      private Instant recordedAt;

      @JsonFormat(pattern = "yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", timezone = "UTC")
      private Instant createdAt;
  }

  // === LocationSearchRequest.java ===
  package com.jjenus.tracker.core.api.dto;

  import lombok.Data;
  import org.springframework.data.domain.Sort;

  import java.time.Instant;

  @Data
  public class LocationSearchRequest {
      private Integer page = 0;
      private Integer size = 20;
      private String sortBy = "recordedAt";
      private Sort.Direction sortDirection = Sort.Direction.DESC;
      private String trackerId;
      private String vehicleId;
      private Instant fromTime;
      private Instant toTime;
      private Boolean accStatus;
      private Float minSpeed;
      private Float maxSpeed;
      private Boolean validOnly = true;
  }

  // === DeviceCommandRequest.java ===
  package com.jjenus.tracker.core.api.dto;

  import com.jjenus.tracker.core.domain.enums.CommandType;
  import jakarta.validation.constraints.NotBlank;
  import jakarta.validation.constraints.NotNull;
  import lombok.Data;

  @Data
  public class DeviceCommandRequest {
      @NotBlank(message = "Tracker ID is required")
      private String trackerId;

      @NotNull(message = "Command type is required")
      private CommandType commandType;

      @NotBlank(message = "Command data is required")
      private String commandData;

      private String initiatedBy;
      private Integer maxRetries = 3;
  }

  // === DeviceCommandResponse.java ===
  package com.jjenus.tracker.core.api.dto;

  import com.fasterxml.jackson.annotation.JsonFormat;
  import com.jjenus.tracker.core.domain.enums.CommandStatus;
  import com.jjenus.tracker.core.domain.enums.CommandType;
  import lombok.Data;

  import java.time.Instant;

  @Data
  public class DeviceCommandResponse {
      private Long commandId;
      private String trackerId;
      private CommandType commandType;
      private String commandData;
      private CommandStatus status;
      private String responseData;
      private String errorMessage;
      private Integer retryCount;
      private Integer maxRetries;
      private String initiatedBy;

      @JsonFormat(pattern = "yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", timezone = "UTC")
      private Instant sentAt;

      @JsonFormat(pattern = "yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", timezone = "UTC")
      private Instant respondedAt;

      @JsonFormat(pattern = "yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", timezone = "UTC")
      private Instant createdAt;

      @JsonFormat(pattern = "yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", timezone = "UTC")
      private Instant updatedAt;
  }

  // === PagedResponse.java ===
  package com.jjenus.tracker.core.api.dto;

  import lombok.Data;
  import org.springframework.data.domain.Page;

  import java.util.List;

  @Data
  public class PagedResponse<T> {
      private List<T> content;
      private int pageNumber;
      private int pageSize;
      private long totalElements;
      private int totalPages;
      private boolean first;
      private boolean last;
      private boolean empty;

      public PagedResponse(Page<T> page) {
          this.content = page.getContent();
          this.pageNumber = page.getNumber();
          this.pageSize = page.getSize();
          this.totalElements = page.getTotalElements();
          this.totalPages = page.getTotalPages();
          this.first = page.isFirst();
          this.last = page.isLast();
          this.empty = page.isEmpty();
      }
  }
  ```

  ## **2. Query Services (Cached Read Operations)**

  ### **VehicleQueryService.java**

  ```java
  package com.jjenus.tracker.core.application.service;

  import com.jjenus.tracker.core.api.dto.*;
  import com.jjenus.tracker.core.domain.entity.Vehicle;
  import com.jjenus.tracker.core.exception.VehicleException;
  import com.jjenus.tracker.core.infrastructure.repository.VehicleRepository;
  import lombok.RequiredArgsConstructor;
  import lombok.extern.slf4j.Slf4j;
  import org.modelmapper.ModelMapper;
  import org.springframework.cache.annotation.Cacheable;
  import org.springframework.data.domain.Page;
  import org.springframework.data.domain.PageRequest;
  import org.springframework.data.domain.Pageable;
  import org.springframework.data.domain.Sort;
  import org.springframework.data.jpa.domain.Specification;
  import org.springframework.stereotype.Service;
  import org.springframework.transaction.annotation.Transactional;
  import org.springframework.util.StringUtils;

  import java.time.Instant;
  import java.util.List;
  import java.util.stream.Collectors;

  @Slf4j
  @Service
  @Transactional(readOnly = true)
  @RequiredArgsConstructor
  public class VehicleQueryService {

      private final VehicleRepository vehicleRepository;
      private final ModelMapper modelMapper;

      @Cacheable(value = "vehicles", key = "#vehicleId", unless = "#result == null")
      public VehicleResponse getVehicle(String vehicleId) {
          log.debug("Cache miss - Fetching vehicle: {}", vehicleId);
          Vehicle vehicle = vehicleRepository.findById(vehicleId)
                  .orElseThrow(() -> VehicleException.notFound(vehicleId));
          return toResponse(vehicle);
      }

      @Cacheable(value = "vehicles", key = "'byDevice_' + #deviceId", unless = "#result == null")
      public VehicleResponse getVehicleByDeviceId(String deviceId) {
          log.debug("Cache miss - Fetching vehicle by device: {}", deviceId);
          Vehicle vehicle = vehicleRepository.findByDeviceId(deviceId)
                  .orElseThrow(() -> VehicleException.notFound("Device: " + deviceId));
          return toResponse(vehicle);
      }

      @Cacheable(value = "vehicles", key = "'search_' + #request.hashCode()")
      public PagedResponse<VehicleResponse> searchVehicles(VehicleSearchRequest request) {
          log.debug("Cache miss - Searching vehicles: {}", request);

          Specification<Vehicle> spec = Specification.where(null);

          if (StringUtils.hasText(request.getSearch())) {
              spec = spec.and((root, query, cb) ->
                  cb.or(
                      cb.like(cb.lower(root.get("vehicleId")), "%" + request.getSearch().toLowerCase() + "%"),
                      cb.like(cb.lower(root.get("licensePlate")), "%" + request.getSearch().toLowerCase() + "%"),
                      cb.like(cb.lower(root.get("model")), "%" + request.getSearch().toLowerCase() + "%"),
                      cb.like(cb.lower(root.get("vin")), "%" + request.getSearch().toLowerCase() + "%")
                  )
              );
          }

          if (StringUtils.hasText(request.getEngineState())) {
              spec = spec.and((root, query, cb) ->
                  cb.equal(root.get("engineState"), request.getEngineState())
              );
          }

          if (request.getAccStatus() != null) {
              spec = spec.and((root, query, cb) ->
                  cb.equal(root.get("accStatus"), request.getAccStatus())
              );
          }

          if (request.getFuelCutActive() != null) {
              spec = spec.and((root, query, cb) ->
                  cb.equal(root.get("fuelCutActive"), request.getFuelCutActive())
              );
          }

          if (request.getLastTelemetryBefore() != null) {
              spec = spec.and((root, query, cb) ->
                  cb.lessThan(root.get("lastTelemetryTime"), request.getLastTelemetryBefore())
              );
          }

          if (request.getLastTelemetryAfter() != null) {
              spec = spec.and((root, query, cb) ->
                  cb.greaterThan(root.get("lastTelemetryTime"), request.getLastTelemetryAfter())
              );
          }

          Pageable pageable = PageRequest.of(
              request.getPage(),
              request.getSize(),
              Sort.by(request.getSortDirection(), request.getSortBy())
          );

          Page<Vehicle> page = vehicleRepository.findAll(spec, pageable);
          return new PagedResponse<>(page.map(this::toResponse));
      }

      @Cacheable(value = "vehicleStats", key = "'activeTrips'")
      public List<VehicleResponse> getVehiclesWithActiveTrips() {
          log.debug("Cache miss - Fetching vehicles with active trips");
          return vehicleRepository.findVehiclesWithActiveTrips().stream()
                  .map(this::toResponse)
                  .collect(Collectors.toList());
      }

      @Cacheable(value = "vehicleStats", key = "'fuelCutActive'")
      public List<VehicleResponse> getVehiclesWithActiveFuelCut() {
          log.debug("Cache miss - Fetching vehicles with active fuel cut");
          return vehicleRepository.findVehiclesWithActiveFuelCut().stream()
                  .map(this::toResponse)
                  .collect(Collectors.toList());
      }

      @Cacheable(value = "vehicleStats", key = "'staleTelemetry_' + #cutoffTime")
      public List<VehicleResponse> getVehiclesWithStaleTelemetry(Instant cutoffTime) {
          log.debug("Cache miss - Fetching vehicles with stale telemetry");
          return vehicleRepository.findVehiclesWithStaleTelemetry(cutoffTime).stream()
                  .map(this::toResponse)
                  .collect(Collectors.toList());
      }

      @Cacheable(value = "vehicles", key = "'exists_' + #vehicleId")
      public boolean exists(String vehicleId) {
          return vehicleRepository.existsById(vehicleId);
      }

      @Cacheable(value = "vehicles", key = "'deviceExists_' + #deviceId")
      public boolean deviceExists(String deviceId) {
          return vehicleRepository.existsByDeviceId(deviceId);
      }

      @Cacheable(value = "vehicles", key = "'plateExists_' + #licensePlate")
      public boolean licensePlateExists(String licensePlate) {
          return vehicleRepository.existsByLicensePlate(licensePlate);
      }

      private VehicleResponse toResponse(Vehicle vehicle) {
          VehicleResponse response = modelMapper.map(vehicle, VehicleResponse.class);

          // Map current location if present
          if (vehicle.getCurrentLocation() != null) {
              response.setCurrentLocation(modelMapper.map(vehicle.getCurrentLocation(), LocationResponse.class));
          }

          return response;
      }
  }
  ```

  ### **TrackerQueryService.java**

  ```java
  package com.jjenus.tracker.core.application.service;

  import com.jjenus.tracker.core.api.dto.*;
  import com.jjenus.tracker.core.domain.entity.Tracker;
  import com.jjenus.tracker.core.infrastructure.repository.TrackerRepository;
  import lombok.RequiredArgsConstructor;
  import lombok.extern.slf4j.Slf4j;
  import org.modelmapper.ModelMapper;
  import org.springframework.cache.annotation.Cacheable;
  import org.springframework.data.domain.Page;
  import org.springframework.data.domain.PageRequest;
  import org.springframework.data.domain.Pageable;
  import org.springframework.data.domain.Sort;
  import org.springframework.stereotype.Service;
  import org.springframework.transaction.annotation.Transactional;

  import java.time.Instant;
  import java.util.List;
  import java.util.stream.Collectors;

  @Slf4j
  @Service
  @Transactional(readOnly = true)
  @RequiredArgsConstructor
  public class TrackerQueryService {

      private final TrackerRepository trackerRepository;
      private final ModelMapper modelMapper;

      @Cacheable(value = "trackers", key = "#trackerId", unless = "#result == null")
      public TrackerResponse getTracker(String trackerId) {
          log.debug("Cache miss - Fetching tracker: {}", trackerId);
          Tracker tracker = trackerRepository.findById(trackerId)
                  .orElseThrow(() -> new IllegalArgumentException("Tracker not found: " + trackerId));
          return toResponse(tracker);
      }

      @Cacheable(value = "trackers", key = "'byDevice_' + #deviceId", unless = "#result == null")
      public TrackerResponse getTrackerByDeviceId(String deviceId) {
          log.debug("Cache miss - Fetching tracker by device: {}", deviceId);
          Tracker tracker = trackerRepository.findByDeviceId(deviceId)
                  .orElseThrow(() -> new IllegalArgumentException("Tracker not found for device: " + deviceId));
          return toResponse(tracker);
      }

      @Cacheable(value = "trackers", key = "'online'")
      public List<TrackerResponse> getOnlineTrackers() {
          log.debug("Cache miss - Fetching online trackers");
          return trackerRepository.findByIsOnline(true).stream()
                  .map(this::toResponse)
                  .collect(Collectors.toList());
      }

      @Cacheable(value = "trackers", key = "'staleConnections_' + #cutoffTime")
      public List<TrackerResponse> getStaleConnections(Instant cutoffTime) {
          log.debug("Cache miss - Fetching stale connections");
          return trackerRepository.findStaleConnections(cutoffTime).stream()
                  .map(this::toResponse)
                  .collect(Collectors.toList());
      }

      @Cacheable(value = "trackers", key = "'lowBattery_' + #threshold")
      public List<TrackerResponse> getTrackersWithLowBattery(float threshold) {
          log.debug("Cache miss - Fetching trackers with low battery");
          return trackerRepository.findTrackersWithLowBattery(threshold).stream()
                  .map(this::toResponse)
                  .collect(Collectors.toList());
      }

      @Cacheable(value = "trackers", key = "'exists_' + #trackerId")
      public boolean exists(String trackerId) {
          return trackerRepository.existsById(trackerId);
      }

      @Cacheable(value = "trackers", key = "'deviceExists_' + #deviceId")
      public boolean deviceExists(String deviceId) {
          return trackerRepository.existsByDeviceId(deviceId);
      }

      private TrackerResponse toResponse(Tracker tracker) {
          TrackerResponse response = modelMapper.map(tracker, TrackerResponse.class);

          // Map vehicle ID if present
          if (tracker.getVehicle() != null) {
              response.setVehicleId(tracker.getVehicle().getVehicleId());
          }

          return response;
      }
  }
  ```

  ### **TripQueryService.java**

  ```java
  package com.jjenus.tracker.core.application.service;

  import com.jjenus.tracker.core.api.dto.*;
  import com.jjenus.tracker.core.domain.entity.Trip;
  import com.jjenus.tracker.core.exception.TripException;
  import com.jjenus.tracker.core.infrastructure.repository.TripRepository;
  import lombok.RequiredArgsConstructor;
  import lombok.extern.slf4j.Slf4j;
  import org.modelmapper.ModelMapper;
  import org.springframework.cache.annotation.Cacheable;
  import org.springframework.data.domain.Page;
  import org.springframework.data.domain.PageRequest;
  import org.springframework.data.domain.Pageable;
  import org.springframework.data.domain.Sort;
  import org.springframework.stereotype.Service;
  import org.springframework.transaction.annotation.Transactional;
  import org.springframework.util.StringUtils;

  import java.time.Duration;
  import java.time.Instant;
  import java.util.List;
  import java.util.stream.Collectors;

  @Slf4j
  @Service
  @Transactional(readOnly = true)
  @RequiredArgsConstructor
  public class TripQueryService {

      private final TripRepository tripRepository;
      private final ModelMapper modelMapper;
      private final LocationQueryService locationQueryService;

      @Cacheable(value = "trips", key = "#tripId", unless = "#result == null")
      public TripResponse getTrip(String tripId) {
          log.debug("Cache miss - Fetching trip: {}", tripId);
          Trip trip = tripRepository.findById(tripId)
                  .orElseThrow(() -> TripException.notFound(tripId));
          return toResponse(trip);
      }

      @Cacheable(value = "trips", key = "'active_' + #vehicleId", unless = "#result == null")
      public TripResponse getActiveTrip(String vehicleId) {
          log.debug("Cache miss - Fetching active trip for vehicle: {}", vehicleId);
          Trip trip = tripRepository.findByVehicleVehicleIdAndIsActive(vehicleId, true)
                  .orElseThrow(() -> TripException.notActive(vehicleId));
          return toResponse(trip);
      }

      @Cacheable(value = "trips", key = "'vehicle_' + #vehicleId")
      public List<TripResponse> getVehicleTrips(String vehicleId) {
          log.debug("Cache miss - Fetching trips for vehicle: {}", vehicleId);
          return tripRepository.findByVehicleVehicleId(vehicleId).stream()
                  .map(this::toResponse)
                  .collect(Collectors.toList());
      }

      @Cacheable(value = "tripsPaged", key = "'search_' + #request.hashCode()")
      public PagedResponse<TripResponse> searchTrips(TripSearchRequest request) {
          log.debug("Cache miss - Searching trips: {}", request);

          Pageable pageable = PageRequest.of(
              request.getPage(),
              request.getSize(),
              Sort.by(request.getSortDirection(), request.getSortBy())
          );

          Page<Trip> page;

          if (StringUtils.hasText(request.getVehicleId())) {
              if (request.getStartTimeFrom() != null && request.getStartTimeTo() != null) {
                  page = tripRepository.findByVehicleVehicleIdAndStartTimeBetween(
                      request.getVehicleId(),
                      request.getStartTimeFrom(),
                      request.getStartTimeTo(),
                      pageable
                  );
              } else {
                  page = tripRepository.findByVehicleVehicleId(request.getVehicleId(), pageable);
              }
          } else {
              page = tripRepository.findAll(pageable);
          }

          return new PagedResponse<>(page.map(this::toResponse));
      }

      @Cacheable(value = "trips", key = "'activeTrips'")
      public List<TripResponse> getActiveTrips() {
          log.debug("Cache miss - Fetching all active trips");
          return tripRepository.findByIsActive(true).stream()
                  .map(this::toResponse)
                  .collect(Collectors.toList());
      }

      @Cacheable(value = "tripStats", key = "'vehicleStats_' + #vehicleId + '_' + #startTime + '_' + #endTime")
      public TripStatisticsResponse getTripStatistics(String vehicleId, Instant startTime, Instant endTime) {
          log.debug("Cache miss - Fetching trip statistics for vehicle: {}", vehicleId);

          List<Trip> trips = tripRepository.findByVehicleVehicleIdAndStartTimeBetween(
              vehicleId, startTime, endTime);

          TripStatisticsResponse stats = new TripStatisticsResponse();
          stats.setVehicleId(vehicleId);
          stats.setPeriodStart(startTime);
          stats.setPeriodEnd(endTime);
          stats.setTotalTrips(trips.size());

          float totalDistance = 0;
          float totalFuel = 0;
          int totalIdleTime = 0;
          Duration totalDuration = Duration.ZERO;

          for (Trip trip : trips) {
              if (trip.getTotalDistanceKm() != null) {
                  totalDistance += trip.getTotalDistanceKm();
              }
              if (trip.getFuelConsumedLiters() != null) {
                  totalFuel += trip.getFuelConsumedLiters();
              }
              if (trip.getIdleTimeMinutes() != null) {
                  totalIdleTime += trip.getIdleTimeMinutes();
              }
              if (trip.getStartTime() != null && trip.getEndTime() != null) {
                  totalDuration = totalDuration.plus(Duration.between(trip.getStartTime(), trip.getEndTime()));
              }
          }

          stats.setTotalDistanceKm(totalDistance);
          stats.setTotalFuelConsumedLiters(totalFuel);
          stats.setTotalIdleTimeMinutes(totalIdleTime);
          stats.setTotalDuration(totalDuration);

          if (trips.size() > 0) {
              stats.setAverageDistanceKm(totalDistance / trips.size());
              stats.setAverageFuelConsumption(totalFuel / trips.size());

              if (totalDuration.toHours() > 0) {
                  stats.setAverageSpeedKmh(totalDistance / totalDuration.toHours());
              }
          }

          return stats;
      }

      @Cacheable(value = "tripStats", key = "'distance_' + #vehicleId + '_' + #startTime + '_' + #endTime")
      public Float getTotalDistanceForPeriod(String vehicleId, Instant startTime, Instant endTime) {
          log.debug("Cache miss - Fetching total distance for vehicle: {}", vehicleId);
          Float distance = tripRepository.getTotalDistanceForPeriod(vehicleId, startTime, endTime);
          return distance != null ? distance : 0.0f;
      }

      private TripResponse toResponse(Trip trip) {
          TripResponse response = modelMapper.map(trip, TripResponse.class);
          response.setVehicleId(trip.getVehicle().getVehicleId());

          // Map locations if present
          if (trip.getStartLocation() != null) {
              response.setStartLocation(modelMapper.map(trip.getStartLocation(), LocationResponse.class));
          }
          if (trip.getEndLocation() != null) {
              response.setEndLocation(modelMapper.map(trip.getEndLocation(), LocationResponse.class));
          }

          // Calculate duration
          if (trip.getStartTime() != null) {
              if (trip.getEndTime() != null) {
                  response.setDuration(Duration.between(trip.getStartTime(), trip.getEndTime()));
              } else {
                  response.setDuration(Duration.between(trip.getStartTime(), Instant.now()));
              }
          }

          return response;
      }
  }
  ```

  ### **LocationQueryService.java**

  ```java
  package com.jjenus.tracker.core.application.service;

  import com.jjenus.tracker.core.api.dto.LocationResponse;
  import com.jjenus.tracker.core.api.dto.LocationSearchRequest;
  import com.jjenus.tracker.core.api.dto.PagedResponse;
  import com.jjenus.tracker.core.domain.entity.TrackerLocation;
  import com.jjenus.tracker.core.infrastructure.repository.TrackerLocationRepository;
  import lombok.RequiredArgsConstructor;
  import lombok.extern.slf4j.Slf4j;
  import org.modelmapper.ModelMapper;
  import org.springframework.cache.annotation.Cacheable;
  import org.springframework.data.domain.Page;
  import org.springframework.data.domain.PageRequest;
  import org.springframework.data.domain.Pageable;
  import org.springframework.data.domain.Sort;
  import org.springframework.data.jpa.domain.Specification;
  import org.springframework.stereotype.Service;
  import org.springframework.transaction.annotation.Transactional;
  import org.springframework.util.StringUtils;

  import javax.persistence.criteria.Predicate;
  import java.time.Instant;
  import java.util.ArrayList;
  import java.util.List;

  @Slf4j
  @Service
  @Transactional(readOnly = true)
  @RequiredArgsConstructor
  public class LocationQueryService {

      private final TrackerLocationRepository locationRepository;
      private final ModelMapper modelMapper;

      @Cacheable(value = "locations", key = "#locationId", unless = "#result == null")
      public LocationResponse getLocation(Long locationId) {
          log.debug("Cache miss - Fetching location: {}", locationId);
          TrackerLocation location = locationRepository.findById(locationId)
                  .orElseThrow(() -> new IllegalArgumentException("Location not found: " + locationId));
          return toResponse(location);
      }

      @Cacheable(value = "locations", key = "'tracker_' + #trackerId")
      public List<LocationResponse> getTrackerLocations(String trackerId) {
          log.debug("Cache miss - Fetching locations for tracker: {}", trackerId);
          return locationRepository.findByTrackerTrackerIdOrderByRecordedAtDesc(trackerId).stream()
                  .map(this::toResponse)
                  .toList();
      }

      @Cacheable(value = "locationsPaged", key = "'search_' + #request.hashCode()")
      public PagedResponse<LocationResponse> searchLocations(LocationSearchRequest request) {
          log.debug("Cache miss - Searching locations: {}", request);

          Specification<TrackerLocation> spec = (root, query, cb) -> {
              List<Predicate> predicates = new ArrayList<>();

              if (StringUtils.hasText(request.getTrackerId())) {
                  predicates.add(cb.equal(root.get("tracker").get("trackerId"), request.getTrackerId()));
              }

              if (request.getFromTime() != null) {
                  predicates.add(cb.greaterThanOrEqualTo(root.get("recordedAt"), request.getFromTime()));
              }

              if (request.getToTime() != null) {
                  predicates.add(cb.lessThanOrEqualTo(root.get("recordedAt"), request.getToTime()));
              }

              if (request.getAccStatus() != null) {
                  predicates.add(cb.equal(root.get("accStatus"), request.getAccStatus()));
              }

              if (request.getMinSpeed() != null) {
                  predicates.add(cb.greaterThanOrEqualTo(root.get("speedKmh"), request.getMinSpeed()));
              }

              if (request.getMaxSpeed() != null) {
                  predicates.add(cb.lessThanOrEqualTo(root.get("speedKmh"), request.getMaxSpeed()));
              }

              if (Boolean.TRUE.equals(request.getValidOnly())) {
                  predicates.add(cb.isNotNull(root.get("latitude")));
                  predicates.add(cb.isNotNull(root.get("longitude")));
                  predicates.add(cb.equal(root.get("validity"), "A"));
              }

              return cb.and(predicates.toArray(new Predicate[0]));
          };

          Pageable pageable = PageRequest.of(
              request.getPage(),
              request.getSize(),
              Sort.by(request.getSortDirection(), request.getSortBy())
          );

          Page<TrackerLocation> page = locationRepository.findAll(spec, pageable);
          return new PagedResponse<>(page.map(this::toResponse));
      }

      @Cacheable(value = "locations", key = "'latestDevice_' + #deviceId", unless = "#result == null")
      public LocationResponse getLatestLocationByDeviceId(String deviceId) {
          log.debug("Cache miss - Fetching latest location for device: {}", deviceId);
          TrackerLocation location = locationRepository.findLatestByDeviceId(deviceId);
          return location != null ? toResponse(location) : null;
      }

      @Cacheable(value = "locationStats", key = "'trackerCount_' + #trackerId")
      public Long getLocationCountByTracker(String trackerId) {
          log.debug("Cache miss - Fetching location count for tracker: {}", trackerId);
          return locationRepository.countByTrackerId(trackerId);
      }

      @Cacheable(value = "locations", key = "'accOffEvents_' + #startTime")
      public List<LocationResponse> getAccOffEvents(Instant startTime) {
          log.debug("Cache miss - Fetching ACC off events from: {}", startTime);
          return locationRepository.findAccOffEvents(startTime).stream()
                  .map(this::toResponse)
                  .toList();
      }

      private LocationResponse toResponse(TrackerLocation location) {
          return modelMapper.map(location, LocationResponse.class);
      }
  }
  ```

  ### **DeviceCommandQueryService.java**

  ```java
  package com.jjenus.tracker.core.application.service;

  import com.jjenus.tracker.core.api.dto.DeviceCommandResponse;
  import com.jjenus.tracker.core.api.dto.PagedResponse;
  import com.jjenus.tracker.core.domain.entity.DeviceCommand;
  import com.jjenus.tracker.core.domain.enums.CommandStatus;
  import com.jjenus.tracker.core.infrastructure.repository.DeviceCommandRepository;
  import lombok.RequiredArgsConstructor;
  import lombok.extern.slf4j.Slf4j;
  import org.modelmapper.ModelMapper;
  import org.springframework.cache.annotation.Cacheable;
  import org.springframework.data.domain.Page;
  import org.springframework.data.domain.PageRequest;
  import org.springframework.data.domain.Pageable;
  import org.springframework.data.domain.Sort;
  import org.springframework.stereotype.Service;
  import org.springframework.transaction.annotation.Transactional;

  import java.time.Instant;
  import java.util.List;
  import java.util.stream.Collectors;

  @Slf4j
  @Service
  @Transactional(readOnly = true)
  @RequiredArgsConstructor
  public class DeviceCommandQueryService {

      private final DeviceCommandRepository commandRepository;
      private final ModelMapper modelMapper;

      @Cacheable(value = "commands", key = "#commandId", unless = "#result == null")
      public DeviceCommandResponse getCommand(Long commandId) {
          log.debug("Cache miss - Fetching command: {}", commandId);
          DeviceCommand command = commandRepository.findById(commandId)
                  .orElseThrow(() -> new IllegalArgumentException("Command not found: " + commandId));
          return toResponse(command);
      }

      @Cacheable(value = "commands", key = "'tracker_' + #trackerId + '_' + #page + '_' + #size")
      public PagedResponse<DeviceCommandResponse> getCommandsByTracker(String trackerId, int page, int size) {
          log.debug("Cache miss - Fetching commands for tracker: {}", trackerId);

          Pageable pageable = PageRequest.of(page, size, Sort.by(Sort.Direction.DESC, "createdAt"));
          Page<DeviceCommand> commands = commandRepository.findByTrackerTrackerId(trackerId, pageable);

          return new PagedResponse<>(commands.map(this::toResponse));
      }

      @Cacheable(value = "commands", key = "'status_' + #status")
      public List<DeviceCommandResponse> getCommandsByStatus(CommandStatus status) {
          log.debug("Cache miss - Fetching commands by status: {}", status);
          return commandRepository.findByStatus(status).stream()
                  .map(this::toResponse)
                  .collect(Collectors.toList());
      }

      @Cacheable(value = "commands", key = "'trackerStatus_' + #trackerId + '_' + #status")
      public List<DeviceCommandResponse> getCommandsByTrackerAndStatus(String trackerId, CommandStatus status) {
          log.debug("Cache miss - Fetching commands for tracker {} with status {}", trackerId, status);
          return commandRepository.findByTrackerTrackerIdAndStatus(trackerId, status).stream()
                  .map(this::toResponse)
                  .collect(Collectors.toList());
      }

      @Cacheable(value = "commands", key = "'pendingRetryable_' + #cutoffTime")
      public List<DeviceCommandResponse> getPendingAndRetryableCommands(Instant cutoffTime) {
          log.debug("Cache miss - Fetching pending and retryable commands");
          return commandRepository.findPendingAndRetryableCommands(cutoffTime).stream()
                  .map(this::toResponse)
                  .collect(Collectors.toList());
      }

      @Cacheable(value = "commands", key = "'recentDevice_' + #deviceId")
      public List<DeviceCommandResponse> getRecentCommandsByDeviceId(String deviceId) {
          log.debug("Cache miss - Fetching recent commands for device: {}", deviceId);
          return commandRepository.findRecentCommandsByDeviceId(deviceId).stream()
                  .map(this::toResponse)
                  .collect(Collectors.toList());
      }

      @Cacheable(value = "commandStats", key = "'pendingCount_' + #trackerId")
      public Long getPendingCommandCount(String trackerId) {
          log.debug("Cache miss - Fetching pending command count for tracker: {}", trackerId);
          return commandRepository.countPendingCommands(trackerId);
      }

      private DeviceCommandResponse toResponse(DeviceCommand command) {
          DeviceCommandResponse response = modelMapper.map(command, DeviceCommandResponse.class);
          response.setTrackerId(command.getTracker().getTrackerId());
          return response;
      }
  }
  ```

  ## **3. Command Services (Write Operations)**

  ### **VehicleCommandService.java**

  ```java
  package com.jjenus.tracker.core.application.service;

  import com.jjenus.tracker.core.api.dto.VehicleRequest;
  import com.jjenus.tracker.core.api.dto.VehicleResponse;
  import com.jjenus.tracker.core.api.dto.VehicleUpdateRequest;
  import com.jjenus.tracker.core.domain.entity.Vehicle;
  import com.jjenus.tracker.core.exception.VehicleException;
  import com.jjenus.tracker.core.infrastructure.repository.VehicleRepository;
  import lombok.RequiredArgsConstructor;
  import lombok.extern.slf4j.Slf4j;
  import org.modelmapper.ModelMapper;
  import org.springframework.cache.annotation.CacheEvict;
  import org.springframework.cache.annotation.Caching;
  import org.springframework.stereotype.Service;
  import org.springframework.transaction.annotation.Transactional;

  @Slf4j
  @Service
  @Transactional
  @RequiredArgsConstructor
  public class VehicleCommandService {

      private final VehicleRepository vehicleRepository;
      private final VehicleQueryService vehicleQueryService;
      private final ModelMapper modelMapper;

      @Caching(evict = {
          @CacheEvict(value = "vehicles", key = "#request.vehicleId"),
          @CacheEvict(value = "vehicles", key = "'byDevice_' + #request.deviceId", condition = "#request.deviceId != null"),
          @CacheEvict(value = "vehicles", key = "'search_*'"),
          @CacheEvict(value = "vehicleStats", allEntries = true)
      })
      public VehicleResponse createVehicle(VehicleRequest request) {
          log.info("Creating vehicle: {}", request.getVehicleId());

          validateVehicleCreation(request);

          Vehicle vehicle = modelMapper.map(request, Vehicle.class);
          Vehicle saved = vehicleRepository.save(vehicle);

          log.info("Vehicle created: {}", saved.getVehicleId());
          return vehicleQueryService.getVehicle(saved.getVehicleId());
      }

      @Caching(evict = {
          @CacheEvict(value = "vehicles", key = "#vehicleId"),
          @CacheEvict(value = "vehicles", key = "'byDevice_*'", condition = "#request.deviceId != null"),
          @CacheEvict(value = "vehicles", key = "'search_*'"),
          @CacheEvict(value = "vehicleStats", allEntries = true)
      })
      public VehicleResponse updateVehicle(String vehicleId, VehicleUpdateRequest request) {
          log.info("Updating vehicle: {}", vehicleId);

          Vehicle vehicle = vehicleRepository.findById(vehicleId)
                  .orElseThrow(() -> VehicleException.notFound(vehicleId));

          if (request.getModel() != null) {
              vehicle.setModel(request.getModel());
          }

          if (request.getLicensePlate() != null) {
              vehicle.setLicensePlate(request.getLicensePlate());
          }

          if (request.getVin() != null) {
              vehicle.setVin(request.getVin());
          }

          if (request.getFuelLevel() != null) {
              vehicle.setFuelLevel(request.getFuelLevel());
          }

          if (request.getOdometerKm() != null) {
              vehicle.setOdometerKm(request.getOdometerKm());
          }

          if (request.getFuelCutActive() != null) {
              vehicle.setFuelCutActive(request.getFuelCutActive());
          }

          Vehicle saved = vehicleRepository.save(vehicle);

          log.info("Vehicle updated: {}", saved.getVehicleId());
          return vehicleQueryService.getVehicle(saved.getVehicleId());
      }

      @Caching(evict = {
          @CacheEvict(value = "vehicles", key = "#vehicleId"),
          @CacheEvict(value = "vehicles", key = "'byDevice_*'"),
          @CacheEvict(value = "vehicles", key = "'search_*'"),
          @CacheEvict(value = "vehicleStats", allEntries = true)
      })
      public void deleteVehicle(String vehicleId) {
          log.info("Deleting vehicle: {}", vehicleId);

          if (!vehicleRepository.existsById(vehicleId)) {
              throw VehicleException.notFound(vehicleId);
          }

          vehicleRepository.deleteById(vehicleId);
          log.info("Vehicle deleted: {}", vehicleId);
      }

      @Caching(evict = {
          @CacheEvict(value = "vehicles", key = "#vehicleId"),
          @CacheEvict(value = "vehicleStats", allEntries = true)
      })
      public void updateVehicleStatus(String vehicleId, String deviceId, boolean online) {
          log.info("Updating vehicle {} status to online={}", vehicleId, online);

          Vehicle vehicle = vehicleRepository.findById(vehicleId)
                  .orElseThrow(() -> VehicleException.notFound(vehicleId));

          // Update logic here

          vehicleRepository.save(vehicle);
      }

      private void validateVehicleCreation(VehicleRequest request) {
          if (vehicleRepository.existsById(request.getVehicleId())) {
              throw new IllegalArgumentException("Vehicle with ID " + request.getVehicleId() + " already exists");
          }

          if (request.getDeviceId() != null && vehicleRepository.existsByDeviceId(request.getDeviceId())) {
              throw VehicleException.deviceAlreadyAssigned(request.getDeviceId());
          }

          if (request.getLicensePlate() != null && vehicleRepository.existsByLicensePlate(request.getLicensePlate())) {
              throw new IllegalArgumentException("Vehicle with license plate " + request.getLicensePlate() + " already exists");
          }
      }
  }
  ```

  ### **TrackerCommandService.java**

  ```java
  package com.jjenus.tracker.core.application.service;

  import com.jjenus.tracker.core.api.dto.TrackerRequest;
  import com.jjenus.tracker.core.api.dto.TrackerResponse;
  import com.jjenus.tracker.core.api.dto.TrackerStatusRequest;
  import com.jjenus.tracker.core.api.dto.TrackerUpdateRequest;
  import com.jjenus.tracker.core.domain.entity.Tracker;
  import com.jjenus.tracker.core.domain.entity.Vehicle;
  import com.jjenus.tracker.core.infrastructure.repository.TrackerRepository;
  import com.jjenus.tracker.core.infrastructure.repository.VehicleRepository;
  import lombok.RequiredArgsConstructor;
  import lombok.extern.slf4j.Slf4j;
  import org.modelmapper.ModelMapper;
  import org.springframework.cache.annotation.CacheEvict;
  import org.springframework.cache.annotation.Caching;
  import org.springframework.stereotype.Service;
  import org.springframework.transaction.annotation.Transactional;

  import java.time.Instant;

  @Slf4j
  @Service
  @Transactional
  @RequiredArgsConstructor
  public class TrackerCommandService {

      private final TrackerRepository trackerRepository;
      private final VehicleRepository vehicleRepository;
      private final TrackerQueryService trackerQueryService;
      private final ModelMapper modelMapper;

      @Caching(evict = {
          @CacheEvict(value = "trackers", key = "#request.trackerId"),
          @CacheEvict(value = "trackers", key = "'byDevice_' + #request.deviceId"),
          @CacheEvict(value = "trackers", key = "'online'"),
          @CacheEvict(value = "vehicles", condition = "#request.vehicleId != null",
                     key = "'byDevice_' + #request.deviceId")
      })
      public TrackerResponse createTracker(TrackerRequest request) {
          log.info("Creating tracker: {}", request.getTrackerId());

          validateTrackerCreation(request);

          Tracker tracker = modelMapper.map(request, Tracker.class);

          if (request.getVehicleId() != null) {
              Vehicle vehicle = vehicleRepository.findById(request.getVehicleId())
                      .orElseThrow(() -> new IllegalArgumentException("Vehicle not found: " + request.getVehicleId()));
              tracker.setVehicle(vehicle);
          }

          Tracker saved = trackerRepository.save(tracker);

          log.info("Tracker created: {}", saved.getTrackerId());
          return trackerQueryService.getTracker(saved.getTrackerId());
      }

      @Caching(evict = {
          @CacheEvict(value = "trackers", key = "#trackerId"),
          @CacheEvict(value = "trackers", key = "'byDevice_*'"),
          @CacheEvict(value = "trackers", key = "'online'"),
          @CacheEvict(value = "vehicles", condition = "#request.vehicleId != null",
                     key = "'byDevice_*'")
      })
      public TrackerResponse updateTracker(String trackerId, TrackerUpdateRequest request) {
          log.info("Updating tracker: {}", trackerId);

          Tracker tracker = trackerRepository.findById(trackerId)
                  .orElseThrow(() -> new IllegalArgumentException("Tracker not found: " + trackerId));

          if (request.getModel() != null) {
              tracker.setModel(request.getModel());
          }

          if (request.getProtocol() != null) {
              tracker.setProtocol(request.getProtocol());
          }

          if (request.getFirmwareVersion() != null) {
              tracker.setFirmwareVersion(request.getFirmwareVersion());
          }

          if (request.getSimNumber() != null) {
              tracker.setSimNumber(request.getSimNumber());
          }

          if (request.getBatteryLevel() != null) {
              tracker.setBatteryLevel(request.getBatteryLevel());
          }

          if (request.getSignalStrength() != null) {
              tracker.setSignalStrength(request.getSignalStrength());
          }

          if (request.getIsOnline() != null) {
              tracker.setIsOnline(request.getIsOnline());
              if (request.getIsOnline()) {
                  tracker.setLastSeen(Instant.now());
              }
          }

          if (request.getVehicleId() != null) {
              Vehicle vehicle = vehicleRepository.findById(request.getVehicleId())
                      .orElseThrow(() -> new IllegalArgumentException("Vehicle not found: " + request.getVehicleId()));
              tracker.setVehicle(vehicle);
          }

          Tracker saved = trackerRepository.save(tracker);

          log.info("Tracker updated: {}", saved.getTrackerId());
          return trackerQueryService.getTracker(saved.getTrackerId());
      }

      @Caching(evict = {
          @CacheEvict(value = "trackers", key = "#trackerId"),
          @CacheEvict(value = "trackers", key = "'byDevice_*'"),
          @CacheEvict(value = "trackers", key = "'online'")
      })
      public void deleteTracker(String trackerId) {
          log.info("Deleting tracker: {}", trackerId);

          if (!trackerRepository.existsById(trackerId)) {
              throw new IllegalArgumentException("Tracker not found: " + trackerId);
          }

          trackerRepository.deleteById(trackerId);
          log.info("Tracker deleted: {}", trackerId);
      }

      @Caching(evict = {
          @CacheEvict(value = "trackers", key = "#trackerId"),
          @CacheEvict(value = "trackers", key = "'byDevice_*'"),
          @CacheEvict(value = "trackers", key = "'online'"),
          @CacheEvict(value = "trackers", key = "'lowBattery_*'")
      })
      public TrackerResponse updateTrackerStatus(String trackerId, TrackerStatusRequest request) {
          log.info("Updating tracker {} status", trackerId);

          Tracker tracker = trackerRepository.findById(trackerId)
                  .orElseThrow(() -> new IllegalArgumentException("Tracker not found: " + trackerId));

          if (request.getBatteryLevel() != null) {
              tracker.setBatteryLevel(request.getBatteryLevel());
          }

          if (request.getSignalStrength() != null) {
              tracker.setSignalStrength(request.getSignalStrength());
          }

          if (request.getIsOnline() != null) {
              tracker.setIsOnline(request.getIsOnline());
              if (request.getIsOnline()) {
                  tracker.updateLastSeen();
              }
          }

          Tracker saved = trackerRepository.save(tracker);

          log.info("Tracker status updated: {}", saved.getTrackerId());
          return trackerQueryService.getTracker(saved.getTrackerId());
      }

      @Caching(evict = {
          @CacheEvict(value = "trackers", key = "'staleConnections_*'"),
          @CacheEvict(value = "trackers", key = "'online'")
      })
      public void markStaleTrackersOffline(Instant cutoffTime) {
          log.info("Marking stale trackers offline before {}", cutoffTime);

          var staleTrackers = trackerRepository.findStaleConnections(cutoffTime);
          for (Tracker tracker : staleTrackers) {
              tracker.setIsOnline(false);
          }

          trackerRepository.saveAll(staleTrackers);
          log.info("Marked {} trackers offline", staleTrackers.size());
      }

      private void validateTrackerCreation(TrackerRequest request) {
          if (trackerRepository.existsById(request.getTrackerId())) {
              throw new IllegalArgumentException("Tracker with ID " + request.getTrackerId() + " already exists");
          }

          if (trackerRepository.existsByDeviceId(request.getDeviceId())) {
              throw new IllegalArgumentException("Tracker with device ID " + request.getDeviceId() + " already exists");
          }
      }
  }
  ```

  ### **TripCommandService.java**

  ```java
  package com.jjenus.tracker.core.application.service;

  import com.jjenus.tracker.core.api.dto.TripResponse;
  import com.jjenus.tracker.core.domain.entity.Trip;
  import com.jjenus.tracker.core.domain.entity.Vehicle;
  import com.jjenus.tracker.core.domain.enums.TripEndReason;
  import com.jjenus.tracker.core.domain.enums.TripStartReason;
  import com.jjenus.tracker.core.exception.TripException;
  import com.jjenus.tracker.core.infrastructure.repository.TripRepository;
  import lombok.RequiredArgsConstructor;
  import lombok.extern.slf4j.Slf4j;
  import org.springframework.cache.annotation.CacheEvict;
  import org.springframework.cache.annotation.Caching;
  import org.springframework.stereotype.Service;
  import org.springframework.transaction.annotation.Transactional;

  import java.time.Instant;
  import java.util.UUID;

  @Slf4j
  @Service
  @Transactional
  @RequiredArgsConstructor
  public class TripCommandService {

      private final TripRepository tripRepository;
      private final TripQueryService tripQueryService;

      @Caching(evict = {
          @CacheEvict(value = "trips", key = "'active_' + #vehicleId"),
          @CacheEvict(value = "trips", key = "'activeTrips'"),
          @CacheEvict(value = "trips", key = "'search_*'"),
          @CacheEvict(value = "tripStats", allEntries = true),
          @CacheEvict(value = "vehicleStats", key = "'activeTrips'")
      })
      public TripResponse startTrip(Vehicle vehicle, TripStartReason reason, Instant startTime) {
          log.info("Starting trip for vehicle: {}", vehicle.getVehicleId());

          if (tripRepository.findByVehicleVehicleIdAndIsActive(vehicle.getVehicleId(), true).isPresent()) {
              throw TripException.alreadyActive(vehicle.getVehicleId());
          }

          Trip trip = new Trip();
          trip.setTripId(generateTripId(vehicle.getVehicleId()));
          trip.setVehicle(vehicle);
          trip.setStartTime(startTime);
          trip.setStartReason(reason);
          trip.setIsActive(true);

          if (vehicle.getCurrentLocation() != null) {
              trip.setStartLocation(vehicle.getCurrentLocation());
          }

          Trip saved = tripRepository.save(trip);

          log.info("Trip started: {}", saved.getTripId());
          return tripQueryService.getTrip(saved.getTripId());
      }

      @Caching(evict = {
          @CacheEvict(value = "trips", key = "#tripId"),
          @CacheEvict(value = "trips", key = "'active_' + #vehicleId"),
          @CacheEvict(value = "trips", key = "'activeTrips'"),
          @CacheEvict(value = "trips", key = "'search_*'"),
          @CacheEvict(value = "tripStats", allEntries = true),
          @CacheEvict(value = "vehicleStats", key = "'activeTrips'")
      })
      public TripResponse endTrip(String tripId, TripEndReason reason) {
          log.info("Ending trip: {}", tripId);

          Trip trip = tripRepository.findById(tripId)
                  .orElseThrow(() -> TripException.notFound(tripId));

          if (!trip.getIsActive()) {
              throw new IllegalStateException("Trip " + tripId + " is not active");
          }

          trip.setEndTime(Instant.now());
          trip.setEndReason(reason);
          trip.setIsActive(false);

          Trip saved = tripRepository.save(trip);

          log.info("Trip ended: {}", saved.getTripId());
          return tripQueryService.getTrip(saved.getTripId());
      }

      @Caching(evict = {
          @CacheEvict(value = "trips", key = "'active_' + #vehicleId"),
          @CacheEvict(value = "trips", key = "'activeTrips'"),
          @CacheEvict(value = "trips", key = "'search_*'"),
          @CacheEvict(value = "tripStats", allEntries = true),
          @CacheEvict(value = "vehicleStats", key = "'activeTrips'")
      })
      public void endActiveTripForVehicle(String vehicleId, TripEndReason reason) {
          log.info("Ending active trip for vehicle: {}", vehicleId);

          Trip activeTrip = tripRepository.findByVehicleVehicleIdAndIsActive(vehicleId, true)
                  .orElseThrow(() -> TripException.notActive(vehicleId));

          activeTrip.setEndTime(Instant.now());
          activeTrip.setEndReason(reason);
          activeTrip.setIsActive(false);

          tripRepository.save(activeTrip);
          log.info("Active trip ended for vehicle: {}", vehicleId);
      }

      @Caching(evict = {
          @CacheEvict(value = "trips", key = "#tripId"),
          @CacheEvict(value = "trips", key = "'search_*'"),
          @CacheEvict(value = "tripStats", allEntries = true)
      })
      public void updateTripDistance(String tripId, float distanceKm) {
          log.info("Updating distance for trip: {} to {} km", tripId, distanceKm);

          Trip trip = tripRepository.findById(tripId)
                  .orElseThrow(() -> TripException.notFound(tripId));

          trip.setTotalDistanceKm(distanceKm);
          tripRepository.save(trip);

          log.info("Trip distance updated: {}", tripId);
      }

      @Caching(evict = {
          @CacheEvict(value = "trips", key = "#tripId"),
          @CacheEvict(value = "trips", key = "'search_*'"),
          @CacheEvict(value = "tripStats", allEntries = true)
      })
      public void updateTripFuelConsumption(String tripId, float fuelLiters) {
          log.info("Updating fuel consumption for trip: {} to {} liters", tripId, fuelLiters);

          Trip trip = tripRepository.findById(tripId)
                  .orElseThrow(() -> TripException.notFound(tripId));

          trip.setFuelConsumedLiters(fuelLiters);
          tripRepository.save(trip);

          log.info("Trip fuel consumption updated: {}", tripId);
      }

      private String generateTripId(String vehicleId) {
          return "TRIP_" + vehicleId + "_" + Instant.now().toEpochMilli() + "_" +
                 UUID.randomUUID().toString().substring(0, 8);
      }
  }
  ```

  ### **DeviceCommandCommandService.java**

  ```java
  package com.jjenus.tracker.core.application.service;

  import com.jjenus.tracker.core.api.dto.DeviceCommandRequest;
  import com.jjenus.tracker.core.api.dto.DeviceCommandResponse;
  import com.jjenus.tracker.core.domain.entity.DeviceCommand;
  import com.jjenus.tracker.core.domain.entity.Tracker;
  import com.jjenus.tracker.core.domain.enums.CommandStatus;
  import com.jjenus.tracker.core.infrastructure.repository.DeviceCommandRepository;
  import com.jjenus.tracker.core.infrastructure.repository.TrackerRepository;
  import lombok.RequiredArgsConstructor;
  import lombok.extern.slf4j.Slf4j;
  import org.modelmapper.ModelMapper;
  import org.springframework.cache.annotation.CacheEvict;
  import org.springframework.cache.annotation.Caching;
  import org.springframework.stereotype.Service;
  import org.springframework.transaction.annotation.Transactional;

  import java.time.Instant;
  import java.util.List;

  @Slf4j
  @Service
  @Transactional
  @RequiredArgsConstructor
  public class DeviceCommandCommandService {

      private final DeviceCommandRepository commandRepository;
      private final TrackerRepository trackerRepository;
      private final DeviceCommandQueryService commandQueryService;
      private final ModelMapper modelMapper;

      @Caching(evict = {
          @CacheEvict(value = "commands", key = "'tracker_' + #request.trackerId + '_*'"),
          @CacheEvict(value = "commands", key = "'status_PENDING'"),
          @CacheEvict(value = "commands", key = "'trackerStatus_' + #request.trackerId + '_PENDING'"),
          @CacheEvict(value = "commandStats", key = "'pendingCount_' + #request.trackerId")
      })
      public DeviceCommandResponse createCommand(DeviceCommandRequest request) {
          log.info("Creating command for tracker: {}", request.getTrackerId());

          Tracker tracker = trackerRepository.findById(request.getTrackerId())
                  .orElseThrow(() -> new IllegalArgumentException("Tracker not found: " + request.getTrackerId()));

          DeviceCommand command = modelMapper.map(request, DeviceCommand.class);
          command.setTracker(tracker);
          command.setStatus(CommandStatus.PENDING);

          DeviceCommand saved = commandRepository.save(command);

          log.info("Command created: {} for tracker: {}", saved.getCommandId(), tracker.getTrackerId());
          return commandQueryService.getCommand(saved.getCommandId());
      }

      @Caching(evict = {
          @CacheEvict(value = "commands", key = "#commandId"),
          @CacheEvict(value = "commands", key = "'tracker_*'"),
          @CacheEvict(value = "commands", key = "'status_*'"),
          @CacheEvict(value = "commands", key = "'trackerStatus_*'"),
          @CacheEvict(value = "commandStats", allEntries = true)
      })
      public DeviceCommandResponse markAsSent(Long commandId) {
          log.info("Marking command as sent: {}", commandId);

          DeviceCommand command = commandRepository.findById(commandId)
                  .orElseThrow(() -> new IllegalArgumentException("Command not found: " + commandId));

          command.markAsSent();
          DeviceCommand saved = commandRepository.save(command);

          log.info("Command marked as sent: {}", commandId);
          return commandQueryService.getCommand(saved.getCommandId());
      }

      @Caching(evict = {
          @CacheEvict(value = "commands", key = "#commandId"),
          @CacheEvict(value = "commands", key = "'tracker_*'"),
          @CacheEvict(value = "commands", key = "'status_*'"),
          @CacheEvict(value = "commands", key = "'trackerStatus_*'"),
          @CacheEvict(value = "commands", key = "'recentDevice_*'"),
          @CacheEvict(value = "commandStats", allEntries = true)
      })
      public DeviceCommandResponse markAsDelivered(Long commandId, String response) {
          log.info("Marking command as delivered: {}", commandId);

          DeviceCommand command = commandRepository.findById(commandId)
                  .orElseThrow(() -> new IllegalArgumentException("Command not found: " + commandId));

          command.markAsDelivered(response);
          DeviceCommand saved = commandRepository.save(command);

          log.info("Command marked as delivered: {}", commandId);
          return commandQueryService.getCommand(saved.getCommandId());
      }

      @Caching(evict = {
          @CacheEvict(value = "commands", key = "#commandId"),
          @CacheEvict(value = "commands", key = "'tracker_*'"),
          @CacheEvict(value = "commands", key = "'status_*'"),
          @CacheEvict(value = "commands", key = "'trackerStatus_*'"),
          @CacheEvict(value = "commands", key = "'pendingRetryable_*'"),
          @CacheEvict(value = "commandStats", allEntries = true)
      })
      public DeviceCommandResponse markAsFailed(Long commandId, String error) {
          log.info("Marking command as failed: {}", commandId);

          DeviceCommand command = commandRepository.findById(commandId)
                  .orElseThrow(() -> new IllegalArgumentException("Command not found: " + commandId));

          command.markAsFailed(error);
          DeviceCommand saved = commandRepository.save(command);

          log.info("Command marked as failed: {}", commandId);
          return commandQueryService.getCommand(saved.getCommandId());
      }

      @Caching(evict = {
          @CacheEvict(value = "commands", key = "#commandId"),
          @CacheEvict(value = "commands", key = "'tracker_*'"),
          @CacheEvict(value = "commands", key = "'status_*'"),
          @CacheEvict(value = "commands", key = "'trackerStatus_*'"),
          @CacheEvict(value = "commandStats", allEntries = true)
      })
      public DeviceCommandResponse retryCommand(Long commandId) {
          log.info("Retrying command: {}", commandId);

          DeviceCommand command = commandRepository.findById(commandId)
                  .orElseThrow(() -> new IllegalArgumentException("Command not found: " + commandId));

          if (!command.canRetry()) {
              throw new IllegalStateException("Command cannot be retried");
          }

          command.incrementRetryCount();
          command.setStatus(CommandStatus.PENDING);
          DeviceCommand saved = commandRepository.save(command);

          log.info("Command retry initiated: {}", commandId);
          return commandQueryService.getCommand(saved.getCommandId());
      }

      @Caching(evict = {
          @CacheEvict(value = "commands", key = "#commandId"),
          @CacheEvict(value = "commands", key = "'tracker_*'"),
          @CacheEvict(value = "commands", key = "'status_*'"),
          @CacheEvict(value = "commands", key = "'trackerStatus_*'"),
          @CacheEvict(value = "commandStats", allEntries = true)
      })
      public void cancelCommand(Long commandId) {
          log.info("Cancelling command: {}", commandId);

          int updated = commandRepository.cancelPendingCommand(commandId, Instant.now());
          if (updated == 0) {
              throw new IllegalArgumentException("Cannot cancel non-pending command: " + commandId);
          }

          log.info("Command cancelled: {}", commandId);
      }

      @Caching(evict = {
          @CacheEvict(value = "commands", allEntries = true),
          @CacheEvict(value = "commandStats", allEntries = true)
      })
      public int cleanupOldCommands(Instant cutoffTime) {
          log.info("Cleaning up old commands before: {}", cutoffTime);

          int deleted = commandRepository.cleanupOldCommands(cutoffTime);
          log.info("Cleaned up {} old commands", deleted);
          return deleted;
      }

      public void processRetryableCommands(Instant cutoffTime) {
          log.info("Processing retryable commands");

          List<DeviceCommand> retryableCommands = commandRepository.findPendingAndRetryableCommands(cutoffTime);

          for (DeviceCommand command : retryableCommands) {
              if (command.canRetry()) {
                  command.incrementRetryCount();
                  command.setStatus(CommandStatus.PENDING);
                  log.debug("Command {} marked for retry", command.getCommandId());
              }
          }

          commandRepository.saveAll(retryableCommands);
          log.info("Processed {} retryable commands", retryableCommands.size());
      }
  }
  ```

  ### **LocationCommandService.java**

  ```java
  package com.jjenus.tracker.core.application.service;

  import com.jjenus.tracker.core.api.dto.LocationResponse;
  import com.jjenus.tracker.core.domain.entity.Tracker;
  import com.jjenus.tracker.core.domain.entity.TrackerLocation;
  import com.jjenus.tracker.core.domain.entity.Vehicle;
  import com.jjenus.tracker.core.infrastructure.repository.TrackerLocationRepository;
  import com.jjenus.tracker.core.infrastructure.repository.TrackerRepository;
  import com.jjenus.tracker.core.infrastructure.repository.VehicleRepository;
  import lombok.RequiredArgsConstructor;
  import lombok.extern.slf4j.Slf4j;
  import org.modelmapper.ModelMapper;
  import org.springframework.cache.annotation.CacheEvict;
  import org.springframework.cache.annotation.Caching;
  import org.springframework.stereotype.Service;
  import org.springframework.transaction.annotation.Transactional;

  import java.time.Instant;

  @Slf4j
  @Service
  @Transactional
  @RequiredArgsConstructor
  public class LocationCommandService {

      private final TrackerLocationRepository locationRepository;
      private final TrackerRepository trackerRepository;
      private final VehicleRepository vehicleRepository;
      private final LocationQueryService locationQueryService;
      private final ModelMapper modelMapper;

      @Caching(evict = {
          @CacheEvict(value = "locations", key = "'tracker_' + #trackerId"),
          @CacheEvict(value = "locations", key = "'latestDevice_' + #deviceId"),
          @CacheEvict(value = "locationsPaged", key = "'search_*'"),
          @CacheEvict(value = "locations", key = "'accOffEvents_*'"),
          @CacheEvict(value = "vehicles", key = "#vehicleId", condition = "#vehicleId != null"),
          @CacheEvict(value = "vehicles", key = "'byDevice_' + #deviceId", condition = "#vehicleId != null"),
          @CacheEvict(value = "trips", key = "'active_' + #vehicleId", condition = "#vehicleId != null")
      })
      public LocationResponse recordLocation(String trackerId, String deviceId, Double latitude,
                                            Double longitude, Float speedKmh, Instant recordedAt) {
          log.debug("Recording location for tracker: {} at [{}, {}]", trackerId, latitude, longitude);

          Tracker tracker = trackerRepository.findById(trackerId)
                  .orElseThrow(() -> new IllegalArgumentException("Tracker not found: " + trackerId));

          TrackerLocation location = new TrackerLocation(latitude, longitude, speedKmh, recordedAt);
          location.setTracker(tracker);
          location.setValidity(location.isValid() ? "A" : "V");

          // Update tracker last seen
          tracker.updateLastSeen();
          trackerRepository.save(tracker);

          // Update vehicle location if assigned
          String vehicleId = null;
          if (tracker.getVehicle() != null) {
              vehicleId = tracker.getVehicle().getVehicleId();
              Vehicle vehicle = tracker.getVehicle();
              vehicle.updateLocation(location);
              vehicleRepository.save(vehicle);
          }

          TrackerLocation saved = locationRepository.save(location);

          log.info("Location recorded: {} for tracker: {}", saved.getLocationId(), trackerId);
          return locationQueryService.getLocation(saved.getLocationId());
      }

      @Caching(evict = {
          @CacheEvict(value = "locations", key = "#locationId"),
          @CacheEvict(value = "locations", key = "'tracker_*'"),
          @CacheEvict(value = "locationsPaged", key = "'search_*'"),
          @CacheEvict(value = "locationStats", key = "'trackerCount_*'")
      })
      public void deleteLocation(Long locationId) {
          log.info("Deleting location: {}", locationId);

          if (!locationRepository.existsById(locationId)) {
              throw new IllegalArgumentException("Location not found: " + locationId);
          }

          locationRepository.deleteById(locationId);
          log.info("Location deleted: {}", locationId);
      }

      @Caching(evict = {
          @CacheEvict(value = "locations", allEntries = true),
          @CacheEvict(value = "locationsPaged", allEntries = true),
          @CacheEvict(value = "locationStats", allEntries = true)
      })
      public int cleanupOldLocations(Instant cutoffTime) {
          log.info("Cleaning up old locations before: {}", cutoffTime);

          // In production, use batch delete or archive instead
          int deleted =)

please continue from LocationCommandService and complete the rest