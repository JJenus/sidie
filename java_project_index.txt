=== ./alerting/src/main/java/com/jjenus/tracker/alerting/application/AlertEventHandler.java ===
```.java
package com.jjenus.tracker.alerting.application;

import com.jjenus.tracker.core.domain.VehicleUpdatedEvent;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.jms.annotation.JmsListener;
import org.springframework.stereotype.Component;

@Component
public class AlertEventHandler {
    private static final Logger logger = LoggerFactory.getLogger(AlertEventHandler.class);
    
    private final AlertingEngine alertingEngine;
    
    public AlertEventHandler(AlertingEngine alertingEngine) {
        this.alertingEngine = alertingEngine;
    }
    
    @JmsListener(destination = "tracking.events.vehicleupdatedevent",
                containerFactory = "jmsListenerContainerFactory",
                subscription = "alert-processing")
    public void handleVehicleUpdate(VehicleUpdatedEvent event) {
        try {
            logger.debug("Processing vehicle update for {}", event.getVehicle().getVehicleId());
            
            alertingEngine.processVehicleUpdate(event.getVehicle(), event.getNewLocation());
            
        } catch (Exception e) {
            logger.error("Failed to process vehicle update for {}", 
                        event.getVehicle().getVehicleId(), e);
            throw e;
        }
    }
}```

=== ./alerting/src/main/java/com/jjenus/tracker/alerting/application/AlertRuleEvaluationService.java ===
```.java
package com.jjenus.tracker.alerting.application;

import com.jjenus.tracker.alerting.domain.IAlertRule;
import com.jjenus.tracker.alerting.domain.AlertEvent;
import com.jjenus.tracker.core.domain.Vehicle;
import com.jjenus.tracker.shared.domain.LocationPoint;
import org.springframework.stereotype.Service;

@Service
public class AlertRuleEvaluationService {

    public AlertEvent evaluateRule(IAlertRule rule, Vehicle vehicle, LocationPoint location) {
        // Handle null parameters
        if (rule == null || vehicle == null || location == null) {
            return null;
        }
        return rule.evaluate(vehicle, location);
    }

    public boolean validateRuleConfiguration(IAlertRule rule) {
        if (rule == null) return false;

        String ruleKey = rule.getRuleKey();
        String ruleName = rule.getRuleName();

        // More comprehensive validation
        if (ruleKey == null || ruleKey.trim().isEmpty()) return false;
        if (ruleName == null || ruleName.trim().isEmpty()) return false;

        // Validate that ruleKey doesn't contain invalid characters
        if (!ruleKey.matches("^[a-zA-Z0-9_]+$")) return false;

        // Validate priority is reasonable
        int priority = rule.getPriority();
        return priority >= 1 && priority <= 100;
    }
}```

=== ./alerting/src/main/java/com/jjenus/tracker/alerting/application/AlertingEngine.java ===
```.java
package com.jjenus.tracker.alerting.application;

import com.jjenus.tracker.alerting.domain.IAlertRule;
import com.jjenus.tracker.alerting.domain.AlertEvent;
import com.jjenus.tracker.core.domain.Vehicle;
import com.jjenus.tracker.shared.domain.LocationPoint;
import com.jjenus.tracker.shared.exception.ValidationException;
import com.jjenus.tracker.shared.pubsub.EventPublisher;
import com.jjenus.tracker.alerting.exception.AlertException;
import org.springframework.stereotype.Component;

import java.util.List;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.Comparator;

@Component
public class AlertingEngine {
    private final List<IAlertRule> activeRules;
    private final EventPublisher eventPublisher;
    private final AlertRuleEvaluationService evaluationService;

    public AlertingEngine(EventPublisher eventPublisher,
                         AlertRuleEvaluationService evaluationService) {
        this.activeRules = new CopyOnWriteArrayList<>();
        this.eventPublisher = eventPublisher;
        this.evaluationService = evaluationService;
    }

    public void processVehicleUpdate(Vehicle vehicle, LocationPoint newLocation) {
        if (vehicle == null || newLocation == null) {
            throw new com.jjenus.tracker.shared.exception.ValidationException(
                "ALERT_INVALID_INPUT",
                "Vehicle and location cannot be null"
            );
        }

        List<IAlertRule> sortedRules = activeRules.stream()
            .filter(IAlertRule::isEnabled)
            .sorted(Comparator.comparingInt(IAlertRule::getPriority).reversed())
            .toList();

        for (IAlertRule rule : sortedRules) {
            try {
                AlertEvent alert = evaluationService.evaluateRule(rule, vehicle, newLocation);

                if (alert != null) {
                    System.out.println("Alert triggered: " + alert.getRuleKey() +
                                     " for vehicle " + vehicle.getVehicleId());

                    eventPublisher.publish(alert);

                    vehicle.addAlert(alert.getMessage());
                }
            } catch (AlertException e) {
                System.err.println("Alert evaluation error for rule " + rule.getRuleKey() + ": " + e.getMessage());
                throw e;
            } catch (Exception e) {
                System.err.println("Unexpected error evaluating rule " + rule.getRuleKey() + ": " + e.getMessage());
                throw AlertException.evaluationError(rule.getRuleKey(), e.getMessage());
            }
        }
    }

    public void registerRule(IAlertRule rule) {
        if (rule == null) {
            throw new ValidationException(
                "ALERT_RULE_NULL",
                "Alert rule cannot be null"
            );
        }

        boolean ruleExists = activeRules.stream()
            .anyMatch(r -> r.getRuleKey().equals(rule.getRuleKey()));

        if (ruleExists) {
            throw AlertException.ruleAlreadyExists(rule.getRuleKey());
        }

        if (!evaluationService.validateRuleConfiguration(rule)) {
            throw AlertException.invalidConfiguration(rule.getRuleKey(), "Invalid configuration");
        }

        activeRules.add(rule);
        System.out.println("Registered rule: " + rule.getRuleName());
    }

    public void unregisterRule(String ruleKey) {
        boolean removed = activeRules.removeIf(rule -> rule.getRuleKey().equals(ruleKey));
        if (!removed) {
            throw AlertException.ruleNotFound(ruleKey);
        }
        System.out.println("Unregistered rule: " + ruleKey);
    }

    public List<IAlertRule> getActiveRules() {
        return List.copyOf(activeRules);
    }

    public void clearRules() {
        activeRules.clear();
        System.out.println("Cleared all alert rules");
    }
}
```

=== ./alerting/src/main/java/com/jjenus/tracker/alerting/domain/AlertEvent.java ===
```.java
package com.jjenus.tracker.alerting.domain;

import com.jjenus.tracker.shared.domain.LocationPoint;
import com.jjenus.tracker.shared.pubsub.DomainEvent;
import java.time.Instant;

public class AlertEvent extends DomainEvent {
    private final String ruleKey;
    private final String vehicleId;
    private final String message;
    private final AlertSeverity severity;
    private final Instant alertTimestamp;
    private final LocationPoint location;
    
    public AlertEvent(String ruleKey, String vehicleId, String message, 
                     AlertSeverity severity, LocationPoint location) {
        this.ruleKey = ruleKey;
        this.vehicleId = vehicleId;
        this.message = message;
        this.severity = severity;
        this.alertTimestamp = Instant.now();
        this.location = location;
    }
    
    public String getRuleKey() { return ruleKey; }
    public String getVehicleId() { return vehicleId; }
    public String getMessage() { return message; }
    public AlertSeverity getSeverity() { return severity; }
    public Instant getAlertTimestamp() { return alertTimestamp; }
    public LocationPoint getLocation() { return location; }
}
```

=== ./alerting/src/main/java/com/jjenus/tracker/alerting/domain/AlertSeverity.java ===
```.java
package com.jjenus.tracker.alerting.domain;

public enum AlertSeverity {
    INFO,
    WARNING,
    CRITICAL
}
```

=== ./alerting/src/main/java/com/jjenus/tracker/alerting/domain/GeofenceExitRule.java ===
```.java
package com.jjenus.tracker.alerting.domain;

import com.jjenus.tracker.core.domain.Vehicle;
import com.jjenus.tracker.shared.domain.LocationPoint;
import java.awt.geom.Path2D;
import java.util.List;

public class GeofenceExitRule implements IAlertRule {
    private final String ruleKey;
    private final String ruleName;
    private final String geofenceId;
    private final List<LocationPoint> boundaryPoints;
    private boolean enabled;
    private final int priority;
    private boolean wasInside;
    
    public GeofenceExitRule(String ruleKey, String geofenceId, 
                           List<LocationPoint> boundaryPoints) {
        this.ruleKey = ruleKey;
        this.ruleName = "Geofence Exit Rule";
        this.geofenceId = geofenceId;
        this.boundaryPoints = boundaryPoints;
        this.enabled = true;
        this.priority = 3;
        this.wasInside = false;
    }
    
    @Override
    public AlertEvent evaluate(Vehicle vehicle, LocationPoint newLocation) {
        if (!enabled) return null;
        
        boolean isInside = isPointInPolygon(newLocation);
        AlertEvent alert = null;
        
        if (wasInside && !isInside) {
            String message = String.format(
                "Vehicle %s exited geofence %s",
                vehicle.getVehicleId(),
                geofenceId
            );
            
            alert = new AlertEvent(
                ruleKey,
                vehicle.getVehicleId(),
                message,
                AlertSeverity.WARNING,
                newLocation
            );
        }
        
        wasInside = isInside;
        return alert;
    }
    
    private boolean isPointInPolygon(LocationPoint point) {
        if (boundaryPoints.size() < 3) return false;
        
        Path2D polygon = new Path2D.Double();
        polygon.moveTo(boundaryPoints.get(0).longitude(), 
                      boundaryPoints.get(0).latitude());
        
        for (int i = 1; i < boundaryPoints.size(); i++) {
            polygon.lineTo(boundaryPoints.get(i).longitude(), 
                          boundaryPoints.get(i).latitude());
        }
        polygon.closePath();
        
        return polygon.contains(point.longitude(), point.latitude());
    }
    
    @Override
    public String getRuleKey() { return ruleKey; }
    
    @Override
    public String getRuleName() { return ruleName; }
    
    @Override
    public boolean isEnabled() { return enabled; }
    
    @Override
    public void setEnabled(boolean enabled) { this.enabled = enabled; }
    
    @Override
    public int getPriority() { return priority; }
    
    public String getGeofenceId() { return geofenceId; }
}
```

=== ./alerting/src/main/java/com/jjenus/tracker/alerting/domain/IAlertRule.java ===
```.java
package com.jjenus.tracker.alerting.domain;

import com.jjenus.tracker.core.domain.Vehicle;
import com.jjenus.tracker.shared.domain.LocationPoint;

public interface IAlertRule {
    AlertEvent evaluate(Vehicle vehicle, LocationPoint newLocation);
    String getRuleKey();
    String getRuleName();
    boolean isEnabled();
    void setEnabled(boolean enabled);
    int getPriority();
}

```

=== ./alerting/src/main/java/com/jjenus/tracker/alerting/domain/IdleTimeRule.java ===
```.java
package com.jjenus.tracker.alerting.domain;

import com.jjenus.tracker.core.domain.Vehicle;
import com.jjenus.tracker.shared.domain.LocationPoint;
import java.time.Duration;

public class IdleTimeRule implements IAlertRule {
    private final String ruleKey;
    private final String ruleName;
    private final Duration maxIdleTime;
    private boolean enabled;
    private final int priority;
    
    public IdleTimeRule(String ruleKey, Duration maxIdleTime) {
        this.ruleKey = ruleKey;
        this.ruleName = "Idle Time Rule";
        this.maxIdleTime = maxIdleTime;
        this.enabled = true;
        this.priority = 1;
    }
    
    @Override
    public AlertEvent evaluate(Vehicle vehicle, LocationPoint newLocation) {
        if (!enabled) return null;
        
        Duration idleDuration = vehicle.getIdleDuration();
        
        if (idleDuration.compareTo(maxIdleTime) > 0) {
            String message = String.format(
                "Vehicle %s has been idle for %d minutes (max allowed: %d minutes)",
                vehicle.getVehicleId(),
                idleDuration.toMinutes(),
                maxIdleTime.toMinutes()
            );
            
            return new AlertEvent(
                ruleKey,
                vehicle.getVehicleId(),
                message,
                AlertSeverity.INFO,
                newLocation
            );
        }
        return null;
    }
    
    @Override
    public String getRuleKey() { return ruleKey; }
    
    @Override
    public String getRuleName() { return ruleName; }
    
    @Override
    public boolean isEnabled() { return enabled; }
    
    @Override
    public void setEnabled(boolean enabled) { this.enabled = enabled; }
    
    @Override
    public int getPriority() { return priority; }
    
    public Duration getMaxIdleTime() { return maxIdleTime; }
}
```

=== ./alerting/src/main/java/com/jjenus/tracker/alerting/domain/MaxSpeedRule.java ===
```.java
package com.jjenus.tracker.alerting.domain;

import com.jjenus.tracker.core.domain.Vehicle;
import com.jjenus.tracker.shared.domain.LocationPoint;

public class MaxSpeedRule implements IAlertRule {
    private final String ruleKey;
    private final String ruleName;
    private final float thresholdSpeed;
    private boolean enabled;
    private final int priority;

    public MaxSpeedRule(String ruleKey, float thresholdSpeed) {
        this.ruleKey = ruleKey;
        this.ruleName = "Maximum Speed Rule";
        this.thresholdSpeed = thresholdSpeed;
        this.enabled = true;
        this.priority = 2;
    }

    @Override
    public AlertEvent evaluate(Vehicle vehicle, LocationPoint newLocation) {
        // Handle null parameters
        if (!enabled || vehicle == null || newLocation == null) {
            return null;
        }

        // Handle potential null speed
        float speed = newLocation.speedKmh();

        if (speed > thresholdSpeed) {
            String message = String.format(
                    "Vehicle %s exceeded speed limit of %.1f km/h. Current speed: %.1f km/h",
                    vehicle.getVehicleId(),
                    thresholdSpeed,
                    speed
            );

            AlertSeverity severity = speed > thresholdSpeed * 1.5 ?
                    AlertSeverity.CRITICAL : AlertSeverity.WARNING;

            return new AlertEvent(
                    ruleKey,
                    vehicle.getVehicleId(),
                    message,
                    severity,
                    newLocation
            );
        }
        return null;
    }

    @Override
    public String getRuleKey() { return ruleKey; }

    @Override
    public String getRuleName() { return ruleName; }

    @Override
    public boolean isEnabled() { return enabled; }

    @Override
    public void setEnabled(boolean enabled) { this.enabled = enabled; }

    @Override
    public int getPriority() { return priority; }

    public float getThresholdSpeed() { return thresholdSpeed; }
}```

=== ./alerting/src/main/java/com/jjenus/tracker/alerting/exception/AlertException.java ===
```.java
package com.jjenus.tracker.alerting.exception;

import com.jjenus.tracker.shared.exception.BusinessRuleException;

public class AlertException extends BusinessRuleException {

    public AlertException(String errorCode, String message) {
        super(errorCode, message);
    }

    public AlertException(String errorCode, String message, Throwable cause) {
        super(errorCode, message, cause);
    }

    public static AlertException ruleNotFound(String ruleKey) {
        return new AlertException(
            "ALERT_RULE_NOT_FOUND",
            String.format("Alert rule with key '%s' not found", ruleKey)
        );
    }

    public static AlertException ruleAlreadyExists(String ruleKey) {
        return new AlertException(
            "ALERT_RULE_EXISTS",
            String.format("Alert rule with key '%s' already exists", ruleKey)
        );
    }

    public static AlertException invalidConfiguration(String ruleKey, String detail) {
        return new AlertException(
            "ALERT_INVALID_CONFIG",
            String.format("Invalid configuration for rule '%s': %s", ruleKey, detail)
        );
    }

    public static AlertException geofenceNotFound(String geofenceId) {
        return new AlertException(
            "ALERT_GEOFENCE_NOT_FOUND",
            String.format("Geofence with ID '%s' not found", geofenceId)
        );
    }

    public static AlertException evaluationError(String ruleKey, String detail) {
        return new AlertException(
            "ALERT_EVALUATION_ERROR",
            String.format("Error evaluating rule '%s': %s", ruleKey, detail)
        );
    }
}
```

=== ./core-tracking/src/main/java/com/jjenus/tracker/core/application/ITripService.java ===
```.java
package com.jjenus.tracker.core.application;

import com.jjenus.tracker.core.domain.Trip;
import com.jjenus.tracker.shared.domain.LocationPoint;
import java.time.Instant;
import java.util.List;
import java.util.Optional;

public interface ITripService {
    Optional<Trip> getActiveTrip(String vehicleId);
    List<Trip> getVehicleTrips(String vehicleId, Instant from, Instant to);
    float calculateTripDistance(String tripId);
    float calculateFuelConsumption(String tripId);
    void detectTripStart(LocationPoint location);
    void detectTripEnd(LocationPoint location);
}
```

=== ./core-tracking/src/main/java/com/jjenus/tracker/core/application/VehicleCommandService.java ===
```.java
package com.jjenus.tracker.core.application;

import com.jjenus.tracker.core.domain.Vehicle;
import com.jjenus.tracker.shared.domain.LocationPoint;
import com.jjenus.tracker.core.domain.VehicleUpdatedEvent;
import com.jjenus.tracker.core.domain.FuelCutRequestedEvent;
import com.jjenus.tracker.core.infrastructure.IVehicleRepository;
import com.jjenus.tracker.shared.pubsub.EventPublisher;
import com.jjenus.tracker.core.exception.VehicleException;
import com.jjenus.tracker.shared.exception.ValidationException;
import org.springframework.stereotype.Service;

@Service
public class VehicleCommandService {
    private final IVehicleRepository vehicleRepository;
    private final EventPublisher eventPublisher;

    public VehicleCommandService(IVehicleRepository vehicleRepository,
                                 EventPublisher eventPublisher) {
        this.vehicleRepository = vehicleRepository;
        this.eventPublisher = eventPublisher;
    }

    public void handleFuelCutRequest(String vehicleId) {
        try {
            Vehicle vehicle = vehicleRepository.findById(vehicleId)
                .orElseThrow(() -> VehicleException.notFound(vehicleId));

            vehicle.issueFuelCutOffCommand();
            vehicleRepository.save(vehicle);

            // Publish DOMAIN EVENT, not device command
            FuelCutRequestedEvent event = new FuelCutRequestedEvent(
                vehicle.getVehicleId(),
                vehicle.getDeviceId()
            );
            eventPublisher.publish(event);

            System.out.println("Fuel cut command processed for vehicle " + vehicleId);

        } catch (VehicleException e) {
            System.err.println("Fuel cut validation failed for vehicle " + vehicleId + ": " + e.getMessage());
            throw e;
        } catch (Exception e) {
            System.err.println("Failed to process fuel cut for vehicle " + vehicleId + ": " + e.getMessage());
            throw new ValidationException("FUEL_CUT_PROCESS_ERROR",
                "Failed to process fuel cut for vehicle " + vehicleId, e);
        }
    }

    public void handleFuelRestoreRequest(String vehicleId) {
        try {
            Vehicle vehicle = vehicleRepository.findById(vehicleId)
                .orElseThrow(() -> VehicleException.notFound(vehicleId));

            vehicle.issueFuelRestoreCommand();
            vehicleRepository.save(vehicle);

            System.out.println("Fuel restore command processed for vehicle " + vehicleId);

        } catch (VehicleException e) {
            System.err.println("Fuel restore failed for vehicle " + vehicleId + ": " + e.getMessage());
            throw e;
        } catch (Exception e) {
            System.err.println("Failed to restore fuel for vehicle " + vehicleId + ": " + e.getMessage());
            throw new ValidationException("FUEL_RESTORE_PROCESS_ERROR",
                "Failed to restore fuel for vehicle " + vehicleId, e);
        }
    }

    public void updateVehicleLocation(String vehicleId, LocationPoint location) {
        try {
            Vehicle vehicle = vehicleRepository.findById(vehicleId)
                .orElseThrow(() -> VehicleException.notFound(vehicleId));

            vehicle.processNewTelemetry(location);
            vehicleRepository.save(vehicle);

            VehicleUpdatedEvent event = new VehicleUpdatedEvent(vehicle, location);
            eventPublisher.publish(event);

            System.out.println("Updated location for vehicle " + vehicleId + ": " +
                             location.latitude() + ", " + location.longitude());

        } catch (VehicleException e) {
            System.err.println("Location update failed for vehicle " + vehicleId + ": " + e.getMessage());
            throw e;
        } catch (Exception e) {
            System.err.println("Failed to update location for vehicle " + vehicleId + ": " + e.getMessage());
            throw new ValidationException("LOCATION_UPDATE_ERROR",
                "Failed to update location for vehicle " + vehicleId, e);
        }
    }
}
```

=== ./core-tracking/src/main/java/com/jjenus/tracker/core/application/VehicleEventHandler.java ===
```.java
package com.jjenus.tracker.core.application;

import com.jjenus.tracker.shared.domain.LocationDataEvent;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.jms.annotation.JmsListener;
import org.springframework.stereotype.Component;

@Component
public class VehicleEventHandler {
    private static final Logger logger = LoggerFactory.getLogger(VehicleEventHandler.class);
    
    private final VehicleCommandService vehicleCommandService;
    
    public VehicleEventHandler(VehicleCommandService vehicleCommandService) {
        this.vehicleCommandService = vehicleCommandService;
    }
    
    @JmsListener(destination = "tracking.events.locationdataevent", 
                containerFactory = "jmsListenerContainerFactory",
                subscription = "vehicle-location-updates")
    public void handleLocationUpdate(LocationDataEvent event) {
        try {
            logger.debug("Processing location update for device {}", event.getDeviceId());
            
            // Map device to vehicle (in production, this would come from a repository)
            String vehicleId = "VEH_" + event.getDeviceId();
            
            vehicleCommandService.updateVehicleLocation(vehicleId, event.getLocation());
            
        } catch (Exception e) {
            logger.error("Failed to process location update for device {}", event.getDeviceId(), e);
            throw e; // Let JMS handle retry/DLQ
        }
    }
}```

=== ./core-tracking/src/main/java/com/jjenus/tracker/core/application/VehicleQueryService.java ===
```.java
package com.jjenus.tracker.core.application;

import com.jjenus.tracker.core.domain.Vehicle;
import com.jjenus.tracker.shared.domain.LocationPoint;
import com.jjenus.tracker.core.infrastructure.IVehicleRepository;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.Optional;

@Service
public class VehicleQueryService {
    private final IVehicleRepository vehicleRepository;
    
    public VehicleQueryService(IVehicleRepository vehicleRepository) {
        this.vehicleRepository = vehicleRepository;
    }
    
    public Optional<Vehicle> getVehicleById(String vehicleId) {
        return vehicleRepository.findById(vehicleId);
    }
    
    public List<Vehicle> getAllVehicles() {
        return vehicleRepository.findAll();
    }
    
    public Optional<LocationPoint> getCurrentLocation(String vehicleId) {
        return vehicleRepository.findById(vehicleId)
            .map(Vehicle::getCurrentLocation);
    }
    
    public boolean isVehicleMoving(String vehicleId) {
        return vehicleRepository.findById(vehicleId)
            .map(vehicle -> vehicle.getCurrentLocation().speedKmh() > 0)
            .orElse(false);
    }
    
    public Optional<Float> getVehicleSpeed(String vehicleId) {
        return vehicleRepository.findById(vehicleId)
            .map(vehicle -> vehicle.getCurrentLocation().speedKmh());
    }
}
```

=== ./core-tracking/src/main/java/com/jjenus/tracker/core/domain/EngineState.java ===
```.java
package com.jjenus.tracker.core.domain;

public enum EngineState {
    OFF,
    ON,
    IDLE,
    MOVING,
    AWAITING_CUTOFF,
    FUEL_CUT_ACTIVE
}
```

=== ./core-tracking/src/main/java/com/jjenus/tracker/core/domain/FuelCutRequestedEvent.java ===
```.java
package com.jjenus.tracker.core.domain;

import com.jjenus.tracker.shared.pubsub.DomainEvent;

public class FuelCutRequestedEvent extends DomainEvent {
    private final String vehicleId;
    private final String deviceId;

    public FuelCutRequestedEvent(String vehicleId, String deviceId) {
        this.vehicleId = vehicleId;
        this.deviceId = deviceId;
    }

    public String getVehicleId() { return vehicleId; }
    public String getDeviceId() { return deviceId; }
}
```

=== ./core-tracking/src/main/java/com/jjenus/tracker/core/domain/FuelStatus.java ===
```.java
package com.jjenus.tracker.core.domain;

import java.time.Instant;

public record FuelStatus(
    float currentLevel,
    float lastConsumption,
    Instant lastUpdated
) {
    public boolean isLow() {
        return currentLevel < 15.0f;
    }
    
    public boolean isEmpty() {
        return currentLevel < 5.0f;
    }
}
```

=== ./core-tracking/src/main/java/com/jjenus/tracker/core/domain/Trip.java ===
```.java
package com.jjenus.tracker.core.domain;

import com.jjenus.tracker.shared.domain.LocationPoint;

import java.time.Duration;
import java.time.Instant;
import java.util.*;

public class Trip {
    private final String tripId;
    private final String vehicleId;
    private final Instant startTime;
    private Instant endTime;
    private LocationPoint startLocation;
    private LocationPoint endLocation;
    private final List<LocationPoint> routePoints;
    private float totalDistance;

    public Trip(String vehicleId, LocationPoint startLocation) {
        this.tripId = "TRIP_" + vehicleId + "_" + UUID.randomUUID().toString().substring(0, 8);
        this.vehicleId = vehicleId;
        this.startTime = startLocation.timestamp();
        this.startLocation = startLocation;
        this.routePoints = new ArrayList<>();
        this.routePoints.add(startLocation);
        this.totalDistance = 0.0f;
    }

    public void addLocation(LocationPoint location) {
        if (!routePoints.isEmpty()) {
            LocationPoint lastPoint = routePoints.get(routePoints.size() - 1);
            totalDistance += lastPoint.distanceTo(location);
        }
        routePoints.add(location);
    }

    public void end(LocationPoint endLocation) {
        this.endTime = endLocation.timestamp(); // Use the location's timestamp!
        this.endLocation = endLocation;
        addLocation(endLocation);
    }

    public Duration getDuration() {
        if (endTime == null) {
            // Active trip - duration from start to now
            return Duration.between(startTime, Instant.now());
        } else {
            // Ended trip - fixed duration between start and end timestamps
            return Duration.between(startTime, endTime);
        }
    }

    public float getAverageSpeed() {
        Duration duration = getDuration();
        long seconds = duration.getSeconds();
        if (seconds == 0) return 0.0f;

        // Speed = distance / time (convert seconds to hours)
        return totalDistance / (seconds / 3600.0f);
    }

    // Getters
    public String getTripId() { return tripId; }
    public String getVehicleId() { return vehicleId; }
    public Instant getStartTime() { return startTime; }
    public Instant getEndTime() { return endTime; }
    public LocationPoint getStartLocation() { return startLocation; }
    public LocationPoint getEndLocation() { return endLocation; }
    public List<LocationPoint> getRoutePoints() {
        return Collections.unmodifiableList(routePoints);
    }
    public float getTotalDistance() { return totalDistance; }
    public boolean isActive() { return endTime == null; }

    @Override
    public String toString() {
        return "Trip{" +
                "tripId='" + tripId + '\'' +
                ", vehicleId='" + vehicleId + '\'' +
                ", startTime=" + startTime +
                ", endTime=" + endTime +
                ", totalDistance=" + totalDistance +
                ", isActive=" + isActive() +
                '}';
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Trip trip = (Trip) o;
        return Objects.equals(tripId, trip.tripId);
    }

    @Override
    public int hashCode() {
        return Objects.hash(tripId);
    }
}```

=== ./core-tracking/src/main/java/com/jjenus/tracker/core/domain/Vehicle.java ===
```.java
package com.jjenus.tracker.core.domain;

import com.jjenus.tracker.core.exception.TripException;
import com.jjenus.tracker.core.exception.VehicleException;
import com.jjenus.tracker.shared.domain.LocationPoint;

import java.time.Duration;
import java.time.Instant;
import java.util.ArrayList;
import java.util.List;

public class Vehicle {
    private final String vehicleId;
    private String deviceId;
    private LocationPoint currentLocation;
    private EngineState engineState;
    private FuelStatus fuelStatus;
    private boolean isFuelCutActive;
    private Instant lastMovementTime;
    private Trip activeTrip;
    private final List<String> recentAlerts;

    public Vehicle(String vehicleId) {
        this.vehicleId = vehicleId;
        this.engineState = EngineState.OFF;
        this.isFuelCutActive = false;
        this.currentLocation = new LocationPoint(0.0, 0.0, 0.0f, Instant.now());
        this.fuelStatus = new FuelStatus(100.0f, 0.0f, Instant.now());
        this.recentAlerts = new ArrayList<>();
    }

    public void processNewTelemetry(LocationPoint newLocation) {
        if (!newLocation.isValid()) {
            throw VehicleException.invalidLocationData();
        }

        this.currentLocation = newLocation;

        if (newLocation.speedKmh() > 0) {
            this.engineState = EngineState.MOVING;
            this.lastMovementTime = Instant.now();

            if (this.activeTrip == null) {
                startTrip(newLocation);
            }
        } else if (this.engineState == EngineState.MOVING) {
            this.engineState = EngineState.IDLE;
            this.lastMovementTime = Instant.now();
        }

        if (this.engineState == EngineState.MOVING && this.activeTrip != null) {
            this.activeTrip.addLocation(newLocation);
        }
    }

    private void startTrip(LocationPoint startLocation) {
        if (this.activeTrip != null) {
            throw com.jjenus.tracker.core.exception.TripException.alreadyActive(vehicleId);
        }
        this.activeTrip = new Trip(this.vehicleId, startLocation);
        System.out.println("DOMAIN EVENT: Trip started for vehicle " + vehicleId);
    }

    public void endTrip(LocationPoint endLocation) {
        if (this.activeTrip == null) {
            throw TripException.notActive(vehicleId);
        }
        this.activeTrip.end(endLocation);
        System.out.println("DOMAIN EVENT: Trip ended for vehicle " + vehicleId);
        this.activeTrip = null;
    }

    public void issueFuelCutOffCommand() {
        if (this.currentLocation.speedKmh() > 10) {
            throw VehicleException.fuelCutNotAllowedWhileMoving(this.currentLocation.speedKmh());
        }

        if (this.isFuelCutActive) {
            throw VehicleException.fuelCutAlreadyActive();
        }

        this.isFuelCutActive = true;
        this.engineState = EngineState.FUEL_CUT_ACTIVE;

        System.out.println("DOMAIN EVENT: Fuel cut requested for vehicle " + vehicleId);
    }

    public void issueFuelRestoreCommand() {
        this.isFuelCutActive = false;

        if (this.currentLocation.speedKmh() > 0) {
            this.engineState = EngineState.MOVING;
        } else {
            this.engineState = EngineState.ON;
        }

        System.out.println("DOMAIN EVENT: Fuel restore requested for vehicle " + vehicleId);
    }

    public Duration getIdleDuration() {
        if (this.lastMovementTime == null || this.engineState != EngineState.IDLE) {
            return Duration.ZERO;
        }
        return Duration.between(this.lastMovementTime, Instant.now());
    }

    public void addAlert(String alertMessage) {
        this.recentAlerts.add(Instant.now() + ": " + alertMessage);
        if (this.recentAlerts.size() > 100) {
            this.recentAlerts.remove(0);
        }
    }

    public String getVehicleId() { return vehicleId; }
    public String getDeviceId() { return deviceId; }
    public LocationPoint getCurrentLocation() { return currentLocation; }
    public EngineState getEngineState() { return engineState; }
    public FuelStatus getFuelStatus() { return fuelStatus; }
    public boolean isFuelCutActive() { return isFuelCutActive; }
    public Trip getActiveTrip() { return activeTrip; }
    public List<String> getRecentAlerts() { return new ArrayList<>(recentAlerts); }

    protected void setDeviceId(String deviceId) { this.deviceId = deviceId; }
    protected void setFuelStatus(FuelStatus fuelStatus) { this.fuelStatus = fuelStatus; }
}
```

=== ./core-tracking/src/main/java/com/jjenus/tracker/core/domain/VehicleUpdatedEvent.java ===
```.java
package com.jjenus.tracker.core.domain;

import com.jjenus.tracker.shared.pubsub.DomainEvent;
import com.jjenus.tracker.shared.domain.LocationPoint;

public class VehicleUpdatedEvent extends DomainEvent {
    private final Vehicle vehicle;
    private final LocationPoint newLocation;

    public VehicleUpdatedEvent(Vehicle vehicle, LocationPoint newLocation) {
        this.vehicle = vehicle;
        this.newLocation = newLocation;
    }

    public Vehicle getVehicle() { return vehicle; }
    public LocationPoint getNewLocation() { return newLocation; }
}
```

=== ./core-tracking/src/main/java/com/jjenus/tracker/core/exception/TripException.java ===
```.java
package com.jjenus.tracker.core.exception;

import com.jjenus.tracker.shared.exception.BusinessRuleException;

public class TripException extends BusinessRuleException {

    public TripException(String errorCode, String message) {
        super(errorCode, message);
    }

    public TripException(String errorCode, String message, Throwable cause) {
        super(errorCode, message, cause);
    }

    public static TripException alreadyActive(String vehicleId) {
        return new TripException(
            "TRIP_ALREADY_ACTIVE",
            String.format("Vehicle '%s' already has an active trip", vehicleId)
        );
    }

    public static TripException notActive(String vehicleId) {
        return new TripException(
            "TRIP_NOT_ACTIVE",
            String.format("Vehicle '%s' does not have an active trip", vehicleId)
        );
    }

    public static TripException notFound(String tripId) {
        return new TripException(
            "TRIP_NOT_FOUND",
            String.format("Trip with ID '%s' not found", tripId)
        );
    }

    public static TripException invalidDuration() {
        return new TripException(
            "TRIP_INVALID_DURATION",
            "Trip duration cannot be negative"
        );
    }
}
```

=== ./core-tracking/src/main/java/com/jjenus/tracker/core/exception/VehicleException.java ===
```.java
package com.jjenus.tracker.core.exception;

import com.jjenus.tracker.shared.exception.BusinessRuleException;

public class VehicleException extends BusinessRuleException {

    public VehicleException(String errorCode, String message) {
        super(errorCode, message);
    }

    public VehicleException(String errorCode, String message, Throwable cause) {
        super(errorCode, message, cause);
    }

    // Specific vehicle exceptions
    public static VehicleException fuelCutNotAllowedWhileMoving(float speed) {
        return new VehicleException(
            "VEHICLE_FUEL_CUT_MOVING",
            String.format("Cannot cut fuel while moving at %.1f km/h. Maximum allowed: 10 km/h", speed)
        );
    }

    public static VehicleException fuelCutAlreadyActive() {
        return new VehicleException(
            "VEHICLE_FUEL_CUT_ACTIVE",
            "Fuel cut is already active for this vehicle"
        );
    }

    public static VehicleException invalidLocationData() {
        return new VehicleException(
            "VEHICLE_INVALID_LOCATION",
            "Invalid location data provided"
        );
    }

    public static VehicleException notFound(String vehicleId) {
        return new VehicleException(
            "VEHICLE_NOT_FOUND",
            String.format("Vehicle with ID '%s' not found", vehicleId)
        );
    }

    public static VehicleException deviceAlreadyAssigned(String deviceId) {
        return new VehicleException(
            "VEHICLE_DEVICE_ASSIGNED",
            String.format("Device with ID '%s' is already assigned to another vehicle", deviceId)
        );
    }
}
```

=== ./core-tracking/src/main/java/com/jjenus/tracker/core/infrastructure/IVehicleRepository.java ===
```.java
package com.jjenus.tracker.core.infrastructure;

import com.jjenus.tracker.core.domain.Vehicle;
import java.util.List;
import java.util.Optional;

public interface IVehicleRepository {
    Optional<Vehicle> findById(String vehicleId);
    List<Vehicle> findAll();
    void save(Vehicle vehicle);
    void delete(String vehicleId);
    boolean exists(String vehicleId);
}
```

=== ./core-tracking/src/main/java/com/jjenus/tracker/core/infrastructure/InMemoryVehicleRepository.java ===
```.java
package com.jjenus.tracker.core.infrastructure;

import com.jjenus.tracker.core.domain.Vehicle;
import org.springframework.stereotype.Repository;

import java.util.Map;
import java.util.List;
import java.util.Optional;
import java.util.concurrent.ConcurrentHashMap;

@Repository
public class InMemoryVehicleRepository implements IVehicleRepository {
    private final Map<String, Vehicle> vehicles = new ConcurrentHashMap<>();
    
    @Override
    public Optional<Vehicle> findById(String vehicleId) {
        return Optional.ofNullable(vehicles.get(vehicleId));
    }
    
    @Override
    public List<Vehicle> findAll() {
        return List.copyOf(vehicles.values());
    }
    
    @Override
    public void save(Vehicle vehicle) {
        if (vehicle != null) {
            vehicles.put(vehicle.getVehicleId(), vehicle);
        }
    }
    
    @Override
    public void delete(String vehicleId) {
        vehicles.remove(vehicleId);
    }
    
    @Override
    public boolean exists(String vehicleId) {
        return vehicles.containsKey(vehicleId);
    }
}
```

=== ./device-comm/src/main/java/com/jjenus/tracker/devicecomm/application/DeviceDataProcessor.java ===
```.java
package com.jjenus.tracker.devicecomm.application;

import com.jjenus.tracker.devicecomm.domain.DeviceDataPacket;
import com.jjenus.tracker.devicecomm.domain.ITrackerProtocolParser;
import com.jjenus.tracker.shared.domain.LocationDataEvent;
import com.jjenus.tracker.shared.domain.LocationPoint;
import com.jjenus.tracker.shared.pubsub.EventPublisher;
import com.jjenus.tracker.devicecomm.exception.ProtocolException;
import com.jjenus.tracker.devicecomm.exception.DeviceException;
import org.springframework.stereotype.Service;

@Service
public class DeviceDataProcessor {
    private final ParserFactory parserFactory;
    private final EventPublisher eventPublisher;

    public DeviceDataProcessor(ParserFactory parserFactory, EventPublisher eventPublisher) {
        this.parserFactory = parserFactory;
        this.eventPublisher = eventPublisher;
    }

    public void processDeviceData(DeviceDataPacket packet) {
        try {
            ITrackerProtocolParser parser = parserFactory.getParser(packet.rawData());
            LocationPoint location = parser.parse(packet.rawData());

            LocationDataEvent event = new LocationDataEvent(
                packet.deviceId(),
                location,
                parser.getProtocolName()
            );

            eventPublisher.publish(event);
            
        } catch (ProtocolException | DeviceException e) {
            throw e;
        } catch (Exception e) {
            throw new com.jjenus.tracker.shared.exception.InfrastructureException(
                "DEVICE_DATA_PROCESS_ERROR",
                "Failed to process device data for " + packet.deviceId(),
                e
            );
        }
    }
}```

=== ./device-comm/src/main/java/com/jjenus/tracker/devicecomm/application/GT06CommandBuilder.java ===
```.java
package com.jjenus.tracker.devicecomm.application;

import java.time.LocalTime;
import java.time.format.DateTimeFormatter;
import java.util.Map;

public class GT06CommandBuilder {
    
    private static final DateTimeFormatter TIME_FORMATTER = 
        DateTimeFormatter.ofPattern("HHmmss");
    
    public static String buildChangePasswordCommand(String imei, String oldPassword, String newPassword) {
        String time = getCurrentTime();
        return String.format("*HQ,%s,S1,%s,%s,%s#", imei, time, oldPassword, newPassword);
    }
    
    public static String buildSetCenterNumberCommand(String imei, String centerNumber) {
        String time = getCurrentTime();
        return String.format("*HQ,%s,S2,%s,%s#", imei, time, centerNumber);
    }
    
    public static String buildSetAdminNumberCommand(String imei, String... adminNumbers) {
        String time = getCurrentTime();
        StringBuilder numbers = new StringBuilder();
        for (int i = 0; i < Math.min(adminNumbers.length, 5); i++) {
            if (i > 0) numbers.append(",");
            numbers.append(adminNumbers[i]);
        }
        return String.format("*HQ,%s,S3,%s,%s#", imei, time, numbers.toString());
    }
    
    public static String buildSetAlarmModeCommand(String imei, int mode) {
        // 0: close SMS and Calling alarm
        // 1: SMS alarm
        // 2: Calling center number as alarm
        String time = getCurrentTime();
        return String.format("*HQ,%s,S18,%s,%d#", imei, time, mode);
    }
    
    public static String buildSetGeoFenceCommand(String imei, int radiusMeters, int mode) {
        // mode: 1=out fence, 2=in fence, 3=out and in
        String time = getCurrentTime();
        return String.format("*HQ,%s,S21,%s,%d,%d#", imei, time, radiusMeters, mode);
    }
    
    public static String buildSetIPPortCommand(String imei, String ip, int port) {
        String time = getCurrentTime();
        String ipParts = ip.replace(".", ",");
        return String.format("*HQ,%s,S23,%s,%s,%d#", imei, time, ipParts, port);
    }
    
    public static String buildSetAPNCommand(String imei, String apn, String password) {
        String time = getCurrentTime();
        if (password == null || password.isEmpty()) {
            return String.format("*HQ,%s,S24,%s,%s,#", imei, time, apn);
        }
        return String.format("*HQ,%s,S24,%s,%s,%s#", imei, time, apn, password);
    }
    
    public static String buildRestartCommand(String imei) {
        String time = getCurrentTime();
        return String.format("*HQ,%s,R1,%s#", imei, time);
    }
    
    public static String buildSetGPRSIntervalCommand(String imei, int intervalSeconds) {
        String time = getCurrentTime();
        return String.format("*HQ,%s,D1,%s,%d#", imei, time, intervalSeconds);
    }
    
    public static String buildSetOverspeedAlarmCommand(String imei, int speedLimitKmh) {
        String time = getCurrentTime();
        return String.format("*HQ,%s,S33,%s,%d#", imei, time, speedLimitKmh);
    }
    
    public static String buildSetWorkingModeCommand(String imei, int mode) {
        String time = getCurrentTime();
        return String.format("*HQ,%s,WKMD,%s,%d#", imei, time, mode);
    }
    
    public static String buildReadDeviceStateCommand(String imei, int type) {
        // type: 0=basic data, 1=software version, 2=other data
        String time = getCurrentTime();
        return String.format("*HQ,%s,S26,%s,%d#", imei, time, type);
    }
    
    private static String getCurrentTime() {
        return LocalTime.now().format(TIME_FORMATTER);
    }
    
    public static Map<String, String> getCommandExamples() {
        return Map.of(
            "Change Password", "*HQ,865205030330012,S1,130305,123456,000000#",
            "Set Center Number", "*HQ,865205030330012,S2,130305,13812341234#",
            "Fuel Cut", "*HQ,865205033365775,S20,092353,1,3,10,3,5,5,7#",
            "Fuel Restore", "*HQ,865205030330012,S20,130305,1,0#",
            "Set Geo-fence", "*HQ,865205030330012,S21,130305,1000,1#",
            "Set IP/Port", "*HQ,865205030330012,S23,130305,116,205,4,25,8800#"
        );
    }
}```

=== ./device-comm/src/main/java/com/jjenus/tracker/devicecomm/application/ParserFactory.java ===
```.java
package com.jjenus.tracker.devicecomm.application;

import com.jjenus.tracker.devicecomm.domain.ITrackerProtocolParser;
import com.jjenus.tracker.devicecomm.exception.ProtocolException;
import org.springframework.stereotype.Component;

import java.util.List;
import java.util.Optional;

@Component
public class ParserFactory {
    private final List<ITrackerProtocolParser> parsers;

    public ParserFactory(List<ITrackerProtocolParser> parsers) {
        this.parsers = parsers;
    }

    public ITrackerProtocolParser getParser(String rawData) {
        return parsers.stream()
            .filter(parser -> parser.canParse(rawData))
            .findFirst()
            .orElseThrow(() -> ProtocolException.parserNotFound(rawData));
    }

    public Optional<ITrackerProtocolParser> getParserByName(String protocolName) {
        return parsers.stream()
            .filter(parser -> parser.getProtocolName().equalsIgnoreCase(protocolName))
            .findFirst();
    }
}
```

=== ./device-comm/src/main/java/com/jjenus/tracker/devicecomm/config/ProtocolParserConfig.java ===
```.java
@Configuration
public class ProtocolParserConfig {
    
    @Bean
    public List<ITrackerProtocolParser> protocolParsers() {
        return List.of(
            new GT06ProtocolParser(),
            new AutoseekerProtocolParser()
        );
    }
}```

=== ./device-comm/src/main/java/com/jjenus/tracker/devicecomm/config/TcpServerConfig.java ===
```.java
//package com.jjenus.tracker.devicecomm.config;
//
//import com.jjenus.tracker.devicecomm.service.ReactiveTcpServer;
//import jakarta.annotation.PreDestroy;
//import org.slf4j.Logger;
//import org.slf4j.LoggerFactory;
//import org.springframework.boot.context.event.ApplicationReadyEvent;
//import org.springframework.context.annotation.Bean;
//import org.springframework.context.annotation.Configuration;
//import org.springframework.context.event.EventListener;
//
//@Configuration
//public class TcpServerConfig {
//    private static final Logger logger = LoggerFactory.getLogger(TcpServerConfig.class);
//
//    @Bean
//    public ReactiveTcpServer reactiveTcpServer() {
//        return new ReactiveTcpServer(deviceDataProcessor);
//    }
//
//    @EventListener(ApplicationReadyEvent.class)
//    public void startTcpServerOnStartup(ApplicationReadyEvent event) {
//        // Delay startup to ensure all beans are ready
//        ReactiveTcpServer server = event.getApplicationContext()
//                .getBean(ReactiveTcpServer.class);
//
//        // Start in a separate thread to not block main thread
//        new Thread(() -> {
//            try {
//                Thread.sleep(3000); // Wait for Spring to fully initialize
//                server.start();
//            } catch (Exception e) {
//                logger.error("Failed to start TCP server", e);
//                // Don't crash the app, just log error
//            }
//        }, "tcp-server-starter").start();
//    }
//
//    @PreDestroy
//    public void cleanup() {
//        ReactiveTcpServer server = applicationContext.getBean(ReactiveTcpServer.class);
//        server.stop();
//    }
//}```

=== ./device-comm/src/main/java/com/jjenus/tracker/devicecomm/domain/DeviceDataPacket.java ===
```.java
package com.jjenus.tracker.devicecomm.domain;

import java.time.Instant;

public record DeviceDataPacket(
    String deviceId,
    String rawData,
    Instant receivedAt,
    String sourceIp
) {}
```

=== ./device-comm/src/main/java/com/jjenus/tracker/devicecomm/domain/FuelCutCommand.java ===
```.java
package com.jjenus.tracker.devicecomm.domain;

import com.jjenus.tracker.shared.pubsub.DomainEvent;

public class FuelCutCommand extends DomainEvent {
    private final String vehicleId;
    private final String deviceId;
    
    public FuelCutCommand(String vehicleId, String deviceId) {
        this.vehicleId = vehicleId;
        this.deviceId = deviceId;
    }
    
    public String getVehicleId() { return vehicleId; }
    public String getDeviceId() { return deviceId; }
}
```

=== ./device-comm/src/main/java/com/jjenus/tracker/devicecomm/domain/ITrackerProtocolParser.java ===
```.java
package com.jjenus.tracker.devicecomm.domain;

import com.jjenus.tracker.shared.domain.LocationPoint;
import com.jjenus.tracker.devicecomm.exception.ProtocolParseException;

public interface ITrackerProtocolParser {
    LocationPoint parse(String rawData) throws ProtocolParseException;
    boolean canParse(String rawData);
    String buildFuelCutCommand(String deviceId);
    String buildEngineOnCommand(String deviceId);
    String getProtocolName();
}

```

=== ./device-comm/src/main/java/com/jjenus/tracker/devicecomm/exception/DeviceException.java ===
```.java
package com.jjenus.tracker.devicecomm.exception;

import com.jjenus.tracker.shared.exception.BusinessRuleException;

public class DeviceException extends BusinessRuleException {

    public DeviceException(String errorCode, String message) {
        super(errorCode, message);
    }

    public DeviceException(String errorCode, String message, Throwable cause) {
        super(errorCode, message, cause);
    }

    public static DeviceException notFound(String deviceId) {
        return new DeviceException(
            "DEVICE_NOT_FOUND",
            String.format("Device with ID '%s' not found", deviceId)
        );
    }

    public static DeviceException offline(String deviceId) {
        return new DeviceException(
            "DEVICE_OFFLINE",
            String.format("Device with ID '%s' is offline", deviceId)
        );
    }

    public static DeviceException communicationError(String deviceId) {
        return new DeviceException(
            "DEVICE_COMMUNICATION_ERROR",
            String.format("Communication error with device '%s'", deviceId)
        );
    }

    public static DeviceException commandTimeout(String deviceId, String commandType) {
        return new DeviceException(
            "DEVICE_COMMAND_TIMEOUT",
            String.format("Command '%s' timeout for device '%s'", commandType, deviceId)
        );
    }

    public static DeviceException invalidResponse(String deviceId, String expected, String received) {
        return new DeviceException(
            "DEVICE_INVALID_RESPONSE",
            String.format("Invalid response from device '%s'. Expected: %s, Received: %s",
                         deviceId, expected, received)
        );
    }
}
```

=== ./device-comm/src/main/java/com/jjenus/tracker/devicecomm/exception/ProtocolException.java ===
```.java
package com.jjenus.tracker.devicecomm.exception;

import com.jjenus.tracker.shared.exception.InfrastructureException;

public class ProtocolException extends InfrastructureException {

    public ProtocolException(String errorCode, String message) {
        super(errorCode, message);
    }

    public ProtocolException(String errorCode, String message, Throwable cause) {
        super(errorCode, message, cause);
    }

    public static ProtocolException parserNotFound(String data) {

        return new ProtocolException(
            "PROTOCOL_PARSER_NOT_FOUND",
            String.format("No parser found for the provided data%s", data)
        );
    }

    public static ProtocolException invalidHeader(String protocolName) {
        return new ProtocolException(
            "PROTOCOL_INVALID_HEADER",
            String.format("Invalid header for %s protocol", protocolName)
        );
    }

    public static ProtocolException parseError(String protocolName, String detail) {
        return new ProtocolException(
            "PROTOCOL_PARSE_ERROR",
            String.format("Failed to parse %s data: %s", protocolName, detail)
        );
    }

    public static ProtocolException unsupportedProtocol(int protocolNumber) {
        return new ProtocolException(
            "PROTOCOL_UNSUPPORTED",
            String.format("Unsupported protocol number: 0x%02x", protocolNumber)
        );
    }

    public static ProtocolException commandBuildError(String protocolName, String commandType) {
        return new ProtocolException(
            "PROTOCOL_COMMAND_BUILD_ERROR",
            String.format("Failed to build %s command for %s protocol", commandType, protocolName)
        );
    }
}
```

=== ./device-comm/src/main/java/com/jjenus/tracker/devicecomm/exception/ProtocolParseException.java ===
```.java
package com.jjenus.tracker.devicecomm.exception;

public class ProtocolParseException extends Exception {
    public ProtocolParseException(String message) {
        super(message);
    }
}
```

=== ./device-comm/src/main/java/com/jjenus/tracker/devicecomm/infrastructure/AutoseekerProtocolParser.java ===
```.java
package com.jjenus.tracker.devicecomm.infrastructure;

import com.jjenus.tracker.devicecomm.domain.ITrackerProtocolParser;
import com.jjenus.tracker.shared.domain.LocationPoint;
import com.jjenus.tracker.devicecomm.exception.ProtocolException;
import java.time.Instant;
import java.time.format.DateTimeFormatter;

public class AutoseekerProtocolParser implements ITrackerProtocolParser {

    @Override
    public LocationPoint parse(String rawData) throws ProtocolException { // Changed from byte[] to String
        try {
            if (!canParse(rawData)) {
                throw ProtocolException.invalidHeader("Autoseeker");
            }
            
            // Parse the example format: *XX,YYYYYYYYYY,V1,HHMMSS,S,latitude,D,longitude,G,speed,direction,DDMMYY,vehicle_status,...
            String[] parts = rawData.split(",");
            
            if (parts.length < 11) {
                throw ProtocolException.parseError("Autoseeker", "Incomplete data packet");
            }
            
            String deviceId = parts[1]; // YYYYYYYYYY is device ID
            String timeStr = parts[3]; // HHMMSS
            
            // Parse latitude
            String latDir = parts[5]; // S or N
            double lat = Double.parseDouble(parts[4]);
            if ("S".equals(latDir)) {
                lat = -lat;
            }
            
            // Parse longitude
            String lonDir = parts[7]; // E or W
            double lng = Double.parseDouble(parts[6]);
            if ("W".equals(lonDir)) {
                lng = -lng;
            }
            
            // Parse speed
            float speed = Float.parseFloat(parts[8]);
            
            // Parse date
            String dateStr = parts[10]; // DDMMYY
            DateTimeFormatter dateFormatter = DateTimeFormatter.ofPattern("ddMMyyHHmmss");
            String dateTimeStr = dateStr + timeStr;
            Instant timestamp = java.time.LocalDateTime.parse(dateTimeStr, dateFormatter)
                .atZone(java.time.ZoneId.systemDefault())
                .toInstant();
            
            return new LocationPoint(lat, lng, speed, timestamp);
            
        } catch (ProtocolException e) {
            throw e;
        } catch (Exception e) {
            throw ProtocolException.parseError("Autoseeker", e.getMessage());
        }
    }

    @Override
    public boolean canParse(String rawData) { // Changed from byte[] to String
        if (rawData == null || rawData.isEmpty()) return false;
        return rawData.startsWith("*XX,");
    }

    @Override
    public String buildFuelCutCommand(String deviceId) {
        try {
            return String.format("*CMD,%s,FUEL,OFF#", deviceId);
        } catch (Exception e) {
            throw ProtocolException.commandBuildError("Autoseeker", "fuel cut");
        }
    }

    @Override
    public String buildEngineOnCommand(String deviceId) {
        try {
            return String.format("*CMD,%s,FUEL,ON#", deviceId);
        } catch (Exception e) {
            throw ProtocolException.commandBuildError("Autoseeker", "engine on");
        }
    }

    @Override
    public String getProtocolName() {
        return "Autoseeker";
    }
}```

=== ./device-comm/src/main/java/com/jjenus/tracker/devicecomm/infrastructure/BatteryCalculator.java ===
```.java
package com.jjenus.tracker.devicecomm.infrastructure;

public class BatteryCalculator {
    
    /**
     * Calculate battery percentage from hex voltage value
     * According to GT06 protocol: 0x0000-0x0299 represents battery voltage
     * Formula: voltage = (hex_value / 1024) * 5.6V
     * Percentage = (voltage / 3.6V) * 100%
     */
    public static float calculateBatteryPercentage(String batteryHex) {
        try {
            if (batteryHex == null || batteryHex.length() != 4) {
                return 0.0f;
            }
            
            int hexValue = Integer.parseInt(batteryHex, 16);
            
            // Calculate voltage
            float voltage = (hexValue / 1024.0f) * 5.6f;
            
            // Calculate percentage (nominal voltage is 3.6V)
            float percentage = (voltage / 3.6f) * 100.0f;
            
            // Clamp between 1% and 100%
            if (percentage < 1.0f) return 1.0f;
            if (percentage > 100.0f) return 100.0f;
            
            return percentage;
            
        } catch (Exception e) {
            return 0.0f;
        }
    }
    
    /**
     * Calculate battery voltage from hex value
     */
    public static float calculateBatteryVoltage(String batteryHex) {
        try {
            if (batteryHex == null || batteryHex.length() != 4) {
                return 0.0f;
            }
            
            int hexValue = Integer.parseInt(batteryHex, 16);
            return (hexValue / 1024.0f) * 5.6f;
            
        } catch (Exception e) {
            return 0.0f;
        }
    }
}```

=== ./device-comm/src/main/java/com/jjenus/tracker/devicecomm/infrastructure/GT06ProtocolParser.java ===
```.java
package com.jjenus.tracker.devicecomm.infrastructure;

import com.jjenus.tracker.devicecomm.domain.ITrackerProtocolParser;
import com.jjenus.tracker.core.domain.LocationPoint;
import com.jjenus.tracker.devicecomm.exception.ProtocolException;
import com.jjenus.tracker.devicecomm.exception.ProtocolParseException;
import java.time.Instant;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.time.format.DateTimeFormatter;
import java.util.HashMap;
import java.util.Map;
import java.util.regex.Pattern;

public class GT06ProtocolParser implements ITrackerProtocolParser {
    private static final Pattern GT06_PATTERN = Pattern.compile("^\\*[A-Z]{2},[0-9]{15},.*#");
    private static final DateTimeFormatter DATE_TIME_FORMATTER = 
        DateTimeFormatter.ofPattern("ddMMyyHHmmss");
    
    @Override
    public LocationPoint parse(String data) throws ProtocolParseException {
        try {
            if (!canParse(data)) {
                throw new ProtocolParseException("Not a valid GT06 protocol message");
            }
            
            // Remove * and #
            String cleanData = data.substring(1, data.length() - 1);
            String[] parts = cleanData.split(",");
            
            String protocolType = parts[2]; // V1, V2, V3, V4, V5, HTBT
            
            switch (protocolType) {
                case "V0":
                    return parseLoginPacket(parts);
                case "V1":
                case "V2":
                case "V4":
                    return parseGPSPacket(parts);
                case "V3":
                    return parseLBSPacket(parts);
                case "V5":
                    return parseWifiPacket(parts);
                case "HTBT":
                    return parseHeartbeatPacket(parts);
                default:
                    throw new ProtocolParseException("Unknown protocol type: " + protocolType);
            }
            
        } catch (Exception e) {
            throw new ProtocolParseException("Failed to parse GT06 data: " + e.getMessage());
        }
    }
    
    private LocationPoint parseGPSPacket(String[] parts) throws ProtocolParseException {
        try {
            // Format: *XX,IMEI,V1/V2/V4,HHMMSS,valid,latitude,N/S,longitude,E/W,speed,direction,DDMMYY,status#
            // Example: *HQ,865205030330012,V1,145452,A,2240.55181,N,11358.32389,E,0.00,0,100815,FFFFFBFF#
            
            if (parts.length < 12) {
                throw new ProtocolParseException("Incomplete GPS packet");
            }
            
            String imei = parts[1];
            String timeStr = parts[3];
            String validity = parts[4];
            String latStr = parts[5];
            String latDir = parts[6];
            String lonStr = parts[7];
            String lonDir = parts[8];
            String speedKnotStr = parts[9];
            String directionStr = parts[10];
            String dateStr = parts[11];
            
            // Parse latitude (DDMM.MMMMM format)
            double latitude = parseDDMMtoDecimal(latStr);
            if ("S".equals(latDir)) {
                latitude = -latitude;
            }
            
            // Parse longitude (DDDMM.MMMMM format)
            double longitude = parseDDMMtoDecimal(lonStr);
            if ("W".equals(lonDir)) {
                longitude = -longitude;
            }
            
            // Parse speed (knots to km/h)
            float speedKnots = Float.parseFloat(speedKnotStr);
            float speedKmh = speedKnots * 1.852f;
            
            // Parse timestamp
            Instant timestamp = parseDateTime(dateStr, timeStr);
            
            // Data is only valid if validity is 'A'
            boolean isValid = "A".equals(validity);
            
            // For invalid GPS, we might still want to process it but with 0 speed
            if (!isValid) {
                speedKmh = 0.0f;
            }
            
            return new LocationPoint(latitude, longitude, speedKmh, timestamp);
            
        } catch (Exception e) {
            throw new ProtocolParseException("Failed to parse GPS packet: " + e.getMessage());
        }
    }
    
    private LocationPoint parseLBSPacket(String[] parts) throws ProtocolParseException {
        try {
            // Format: *XX,IMEI,V3,HHMMSS,base_info,battery_info,failure_info,cont,DDMMYY,status#
            // Example: *HQ,865205030330012,V3,000201,46000,07,...#
            
            if (parts.length < 9) {
                throw new ProtocolParseException("Incomplete LBS packet");
            }
            
            String imei = parts[1];
            String timeStr = parts[3];
            String mccMnc = parts[4];
            String dateStr = parts[parts.length - 2];
            
            // Extract battery info
            String batteryHex = "0000";
            for (int i = 5; i < parts.length; i++) {
                if (parts[i].length() == 4 && parts[i].matches("[0-9A-Fa-f]{4}")) {
                    batteryHex = parts[i];
                    break;
                }
            }
            
            // Parse timestamp (for LBS, we still need a timestamp)
            Instant timestamp = parseDateTime(dateStr, timeStr);
            
            // LBS doesn't have real GPS coordinates, so we return default with 0 speed
            // In production, you'd look up the cell tower location
            return new LocationPoint(0.0, 0.0, 0.0f, timestamp);
            
        } catch (Exception e) {
            throw new ProtocolParseException("Failed to parse LBS packet: " + e.getMessage());
        }
    }
    
    private LocationPoint parseWifiPacket(String[] parts) throws ProtocolParseException {
        try {
            // Format: *XX,IMEI,V5,HHMMSS,wifi_count,wifi_info...,battery_info,DDMMYY,status#
            
            if (parts.length < 8) {
                throw new ProtocolParseException("Incomplete WIFI packet");
            }
            
            String timeStr = parts[3];
            String dateStr = parts[parts.length - 2];
            
            // Parse timestamp
            Instant timestamp = parseDateTime(dateStr, timeStr);
            
            // WIFI tracking doesn't have GPS coordinates by default
            return new LocationPoint(0.0, 0.0, 0.0f, timestamp);
            
        } catch (Exception e) {
            throw new ProtocolParseException("Failed to parse WIFI packet: " + e.getMessage());
        }
    }
    
    private LocationPoint parseHeartbeatPacket(String[] parts) throws ProtocolParseException {
        try {
            // Format: *XX,IMEI,HTBT# or *XX,IMEI,HTBT,battery_percent#
            
            String imei = parts[1];
            Instant timestamp = Instant.now();
            
            // Heartbeat doesn't have location, return current location or default
            // In your system, you might want to fetch last known location
            return new LocationPoint(0.0, 0.0, 0.0f, timestamp);
            
        } catch (Exception e) {
            throw new ProtocolParseException("Failed to parse heartbeat packet: " + e.getMessage());
        }
    }
    
    private LocationPoint parseLoginPacket(String[] parts) throws ProtocolParseException {
        // Login packet just announces device presence
        Instant timestamp = Instant.now();
        return new LocationPoint(0.0, 0.0, 0.0f, timestamp);
    }
    
    private double parseDDMMtoDecimal(String ddmm) {
        try {
            double value = Double.parseDouble(ddmm);
            int degrees = (int)(value / 100);
            double minutes = value - (degrees * 100);
            return degrees + (minutes / 60.0);
        } catch (NumberFormatException e) {
            return 0.0;
        }
    }
    
    private Instant parseDateTime(String dateStr, String timeStr) {
        try {
            String dateTimeStr = dateStr + timeStr;
            LocalDateTime ldt = LocalDateTime.parse(dateTimeStr, DATE_TIME_FORMATTER);
            return ldt.atZone(ZoneId.systemDefault()).toInstant();
        } catch (Exception e) {
            // If parsing fails, return current time
            return Instant.now();
        }
    }
    
    @Override
    public boolean canParse(String data) {
        if (data == null || data.isEmpty()) {
            return false;
        }
        
        return GT06_PATTERN.matcher(data).matches();
    }
    
    @Override
    public byte[] buildFuelCutCommand(String deviceId) {
        try {
            // GT06 fuel cut command format: *XX,IMEI,S20,HHMMSS,C,time1,time2,...#
            // From protocol: C=1 (static disable), time1=3 (3 seconds)
            
            String timeStr = getCurrentTimeString();
            String command = String.format("*HQ,%s,S20,%s,1,3#", deviceId, timeStr);
            return command.getBytes();
            
        } catch (Exception e) {
            throw ProtocolException.commandBuildError("GT06", "fuel cut");
        }
    }
    
    @Override
    public byte[] buildEngineOnCommand(String deviceId) {
        try {
            // GT06 fuel restore command: *XX,IMEI,S20,HHMMSS,1,0#
            
            String timeStr = getCurrentTimeString();
            String command = String.format("*HQ,%s,S20,%s,1,0#", deviceId, timeStr);
            return command.getBytes();
            
        } catch (Exception e) {
            throw ProtocolException.commandBuildError("GT06", "engine on");
        }
    }
    
    private String getCurrentTimeString() {
        return String.format("%02d%02d%02d", 
            java.time.LocalTime.now().getHour(),
            java.time.LocalTime.now().getMinute(),
            java.time.LocalTime.now().getSecond());
    }
    
    @Override
    public String getProtocolName() {
        return "GT06";
    }
    
    // Additional utility method to parse vehicle status bits
    public Map<String, Boolean> parseStatusBits(String statusHex) {
        Map<String, Boolean> statusMap = new HashMap<>();
        
        try {
            if (statusHex == null || statusHex.length() != 8) {
                return statusMap;
            }
            
            // Convert hex to binary (32 bits)
            long value = Long.parseLong(statusHex, 16);
            String binary = String.format("%32s", Long.toBinaryString(value)).replace(' ', '0');
            
            // Parse bits according to protocol (LSB first, 0 = active)
            // Byte 4 bits (bits 24-31)
            statusMap.put("door_open", binary.charAt(31) == '0');          // bit 0
            statusMap.put("overspeed_alarm", binary.charAt(30) == '0');    // bit 2
            statusMap.put("fence_in_alarm", binary.charAt(28) == '0');     // bit 4
            statusMap.put("fence_out_alarm", binary.charAt(25) == '0');    // bit 7
            
            // Byte 3 bits (bits 16-23)
            statusMap.put("gps_status", binary.charAt(22) == '0');         // bit 2
            statusMap.put("acc_off", binary.charAt(22) == '0');           // bit 2 (same as GPS status?)
            statusMap.put("sos_alarm", binary.charAt(21) == '0');         // bit 11
            statusMap.put("vibration_alarm", binary.charAt(19) == '0');   // bit 13
            statusMap.put("low_battery_alarm", binary.charAt(18) == '0'); // bit 14
            
            // Byte 2 bits (bits 8-15)
            statusMap.put("power_cut_alarm", binary.charAt(12) == '0');   // bit 20
            
            // Byte 1 bits (bits 0-7)
            statusMap.put("vehicle_battery_remove_alarm", binary.charAt(4) == '0');  // bit 4
            statusMap.put("anti_tamper_alarm", binary.charAt(3) == '0');             // bit 5
            statusMap.put("cut_off_oil", binary.charAt(2) == '0');                   // bit 6
            
        } catch (Exception e) {
            // Log error but don't throw
            System.err.println("Error parsing status bits: " + e.getMessage());
        }
        
        return statusMap;
    }
}```

=== ./device-comm/src/main/java/com/jjenus/tracker/devicecomm/infrastructure/VehicleStatusParser.java ===
```.java
package com.jjenus.tracker.devicecomm.infrastructure;

import java.util.HashMap;
import java.util.Map;

public class VehicleStatusParser {
    
    public static Map<String, Object> parseGT06Status(String statusHex) {
        Map<String, Object> status = new HashMap<>();
        
        if (statusHex == null || statusHex.length() != 8) {
            return status;
        }
        
        try {
            // Parse 4-byte status field
            long value = Long.parseLong(statusHex, 16);
            String binary = String.format("%32s", Long.toBinaryString(value)).replace(' ', '0');
            
            // Byte 4 (bits 24-31)
            parseByte4(status, binary.substring(24, 32));
            
            // Byte 3 (bits 16-23)
            parseByte3(status, binary.substring(16, 24));
            
            // Byte 2 (bits 8-15)
            parseByte2(status, binary.substring(8, 16));
            
            // Byte 1 (bits 0-7)
            parseByte1(status, binary.substring(0, 8));
            
        } catch (Exception e) {
            status.put("parse_error", e.getMessage());
        }
        
        return status;
    }
    
    private static void parseByte1(Map<String, Object> status, String byteStr) {
        // Bit 0: GPS Status (0=located, 1=not located)
        boolean gpsLocated = byteStr.charAt(7) == '0';
        status.put("gps_located", gpsLocated);
        
        // Bit 1: Vehicle security condition
        boolean securityActive = byteStr.charAt(6) == '0';
        status.put("security_active", securityActive);
        
        // Bit 2: ACC off
        boolean accOff = byteStr.charAt(5) == '0';
        status.put("acc_off", accOff);
        
        // Bit 3: SOS Alarm
        boolean sosAlarm = byteStr.charAt(4) == '0';
        status.put("sos_alarm", sosAlarm);
        
        // Bit 4: Vibration Alarm
        boolean vibrationAlarm = byteStr.charAt(3) == '0';
        status.put("vibration_alarm", vibrationAlarm);
        
        // Bit 5: Low Battery Alarm
        boolean lowBatteryAlarm = byteStr.charAt(2) == '0';
        status.put("low_battery_alarm", lowBatteryAlarm);
    }
    
    private static void parseByte2(Map<String, Object> status, String byteStr) {
        // Bit 0: Power cut-off alarm
        boolean powerCutAlarm = byteStr.charAt(7) == '0';
        status.put("power_cut_alarm", powerCutAlarm);
        
        // Bit 1: Device powered by backup battery
        boolean backupBattery = byteStr.charAt(6) == '0';
        status.put("backup_battery", backupBattery);
    }
    
    private static void parseByte3(Map<String, Object> status, String byteStr) {
        // Bit 0: Anti-tamper alarm
        boolean antiTamperAlarm = byteStr.charAt(7) == '0';
        status.put("anti_tamper_alarm", antiTamperAlarm);
        
        // Bit 1: Cut off oil condition
        boolean oilCutOff = byteStr.charAt(6) == '0';
        status.put("oil_cut_off", oilCutOff);
        
        // Bit 2: Vehicle battery remove condition alarm
        boolean batteryRemoved = byteStr.charAt(5) == '0';
        status.put("battery_removed", batteryRemoved);
    }
    
    private static void parseByte4(Map<String, Object> status, String byteStr) {
        // Bit 0: Door open
        boolean doorOpen = byteStr.charAt(7) == '0';
        status.put("door_open", doorOpen);
        
        // Bit 2: Overspeeding alarm
        boolean overspeedAlarm = byteStr.charAt(5) == '0';
        status.put("overspeed_alarm", overspeedAlarm);
        
        // Bit 4: Fence-in alarm
        boolean fenceInAlarm = byteStr.charAt(3) == '0';
        status.put("fence_in_alarm", fenceInAlarm);
        
        // Bit 7: Fence-out alarm
        boolean fenceOutAlarm = byteStr.charAt(0) == '0';
        status.put("fence_out_alarm", fenceOutAlarm);
    }
    
    public static boolean isAlarmActive(Map<String, Object> status) {
        return (boolean) status.getOrDefault("sos_alarm", false) ||
               (boolean) status.getOrDefault("vibration_alarm", false) ||
               (boolean) status.getOrDefault("low_battery_alarm", false) ||
               (boolean) status.getOrDefault("power_cut_alarm", false) ||
               (boolean) status.getOrDefault("anti_tamper_alarm", false) ||
               (boolean) status.getOrDefault("overspeed_alarm", false) ||
               (boolean) status.getOrDefault("fence_in_alarm", false) ||
               (boolean) status.getOrDefault("fence_out_alarm", false);
    }
}```

=== ./device-comm/src/main/java/com/jjenus/tracker/devicecomm/service/ReactiveTcpServer.java ===
```.java
package com.jjenus.tracker.devicecomm.service;

import com.jjenus.tracker.devicecomm.application.DeviceDataProcessor;
import com.jjenus.tracker.devicecomm.domain.DeviceDataPacket;
import com.jjenus.tracker.shared.domain.ConnectionInfo;
import com.jjenus.tracker.shared.redis.RedisConnectionTracker;
import io.netty.channel.ChannelOption;
import io.netty.handler.logging.LogLevel;
import io.netty.handler.timeout.ReadTimeoutHandler;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.context.event.ApplicationReadyEvent;
import org.springframework.context.event.EventListener;
import org.springframework.stereotype.Service;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import reactor.core.scheduler.Schedulers;
import reactor.netty.Connection;
import reactor.netty.DisposableServer;
import reactor.netty.tcp.TcpServer;

import java.net.InetSocketAddress;
import java.time.Duration;
import java.time.Instant;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;

@Service
public class ReactiveTcpServer {
    private static final Logger logger = LoggerFactory.getLogger(ReactiveTcpServer.class);
    private static final AtomicInteger CONNECTION_COUNTER = new AtomicInteger(0);

    private final DeviceDataProcessor deviceDataProcessor;
    private final RedisConnectionTracker connectionTracker;

    @Value("${tracking.tcp.server.port:8888}")
    private int tcpPort;

    @Value("${tracking.tcp.server.message-delimiter:#}")
    private String messageDelimiter;

    @Value("${tracking.tcp.server.max-message-length:1024}")
    private int maxMessageLength;

    @Value("${tracking.tcp.server.read-timeout:300}")
    private int readTimeoutSeconds;

    private DisposableServer server;
    private volatile boolean running = false;

    public ReactiveTcpServer(DeviceDataProcessor deviceDataProcessor,
                             RedisConnectionTracker connectionTracker) {
        this.deviceDataProcessor = deviceDataProcessor;
        this.connectionTracker = connectionTracker;
    }

    @EventListener(ApplicationReadyEvent.class)
    public void start() {
        if (running) {
            logger.warn("TCP Server is already running");
            return;
        }

        logger.info("Starting Reactive TCP Server on port {}", tcpPort);

        try {
            server = TcpServer.create()
                    .port(tcpPort)
                    .option(ChannelOption.SO_BACKLOG, 100)
                    .option(ChannelOption.SO_REUSEADDR, true)
                    .option(ChannelOption.TCP_NODELAY, true)
                    .option(ChannelOption.SO_KEEPALIVE, true)
                    .doOnConnection(this::handleNewConnection)
                    .doOnBind(bind -> logger.info("TCP Server binding to port {}", tcpPort))
                    .doOnBound(bound -> logger.info("TCP Server successfully bound"))
                    .doOnUnbound(unbound -> logger.info("TCP Server unbound"))
                    .wiretap("reactor.netty.tcp.TcpServer", LogLevel.DEBUG)
                    .handle((inbound, outbound) -> {
                        String connectionId = "conn-" + CONNECTION_COUNTER.incrementAndGet();

                        final String[] clientIp = new String[]{"unknown"};
                        final Connection[] nettyConnection = new Connection[1];

                        // CORRECT: Use withConnection (one of the 3 methods) to get the Connection
                        inbound.withConnection(conn -> {
                            nettyConnection[0] = conn;

                            // Get client IP from the Connection, not from inbound
                            InetSocketAddress remoteAddress = (InetSocketAddress) conn.address();
                            clientIp[0] = remoteAddress != null ?
                                    remoteAddress.getAddress().getHostAddress() : "unknown";

                            // Register connection in tracker
                            String initialDeviceId = "unknown";
                            connectionTracker.registerConnection(connectionId, initialDeviceId, clientIp[0], conn);

                            // Add timeout handler
                            conn.addHandlerLast(new ReadTimeoutHandler(readTimeoutSeconds, TimeUnit.SECONDS));

                            logger.debug("Connection {} established from {}", connectionId, clientIp[0]);
                        });

                        // CORRECT: Simplified message framing using bufferUntil
                        // Alternative: Use receive().asString().transform() with custom framing
                        return inbound.receive()
                                .asString()
                                .transform(this::frameMessagesWithDelimiter)
                                .doOnNext(message -> processRawMessage(message, connectionId, clientIp[0]))
                                .doOnError(error -> handleConnectionError(error, connectionId))
                                .doFinally(signal -> cleanupConnection(connectionId))
                                .then();
                    })
                    .bindNow();

            running = true;
            logger.info("TCP Server started successfully on port {}", tcpPort);

        } catch (Exception e) {
            logger.error("Failed to start TCP Server on port {}", tcpPort, e);
            throw new RuntimeException("Failed to start TCP Server", e);
        }
    }

    private void handleNewConnection(Connection connection) {
        InetSocketAddress remoteAddress = (InetSocketAddress) connection.address();
        String clientIp = remoteAddress != null ? remoteAddress.getAddress().getHostAddress() : "unknown";
        int clientPort = remoteAddress != null ? remoteAddress.getPort() : 0;

        logger.info("New TCP connection from {}:{}", clientIp, clientPort);

        connection.onDispose(() -> {
            logger.info("Connection from {}:{} closed", clientIp, clientPort);
        });
    }

    /**
     * Correct framing implementation using only Flux operators
     * No manual Flux.create needed
     */
    private Flux<String> frameMessagesWithDelimiter(Flux<String> dataStream) {
        return dataStream
                .windowUntil(s -> s.contains(messageDelimiter), true)
                .flatMap(window -> window.reduce(String::concat))
                .map(combined -> {
                    // Remove the delimiter for processing
                    if (combined.endsWith(messageDelimiter)) {
                        return combined.substring(0, combined.length() - 1);
                    }
                    return combined;
                });
    }

    private void processRawMessage(String rawMessage, String connectionId, String clientIp) {
        try {
            logger.debug("Received message ({} chars) from connection {}", rawMessage.length(), connectionId);

            // Extract device ID from the raw message
            String deviceId = extractDeviceIdFromRawMessage(rawMessage);

            // Update connection tracker with actual device ID if we extracted it
            if (!"unknown".equals(deviceId)) {
                connectionTracker.updateConnectionDevice(connectionId, deviceId);
            }

            DeviceDataPacket packet = new DeviceDataPacket(
                    deviceId,
                    rawMessage,
                    Instant.now(),
                    clientIp
            );

            // Process asynchronously
            Mono.fromRunnable(() -> deviceDataProcessor.processDeviceData(packet))
                    .subscribeOn(Schedulers.boundedElastic())
                    .subscribe(
                            null,
                            error -> logger.error("Error processing device data for connection {}", connectionId, error)
                    );

            // Update last seen in connection tracker
            connectionTracker.updateLastSeen(connectionId);

        } catch (Exception e) {
            logger.error("Error processing raw message from connection {}", connectionId, e);
        }
    }

    private String extractDeviceIdFromRawMessage(String rawMessage) {
        // Simple extraction - assumes format: *XX,DEVICE_ID,...
        try {
            if (rawMessage != null && rawMessage.startsWith("*")) {
                String[] parts = rawMessage.split(",", 3);
                if (parts.length >= 2) {
                    return parts[1].trim(); // Second part is device ID
                }
            }
        } catch (Exception e) {
            logger.warn("Failed to extract device ID from message: {}",
                    rawMessage.substring(0, Math.min(rawMessage.length(), 50)));
        }
        return "unknown";
    }

    private void handleConnectionError(Throwable error, String connectionId) {
        logger.warn("Connection error for {}: {}", connectionId, error.getMessage());
    }

    private void cleanupConnection(String connectionId) {
        connectionTracker.removeConnection(connectionId);
        logger.info("Cleaned up connection {}", connectionId);
    }

    public void stop() {
        if (!running) {
            logger.warn("TCP Server is not running");
            return;
        }

        logger.info("Stopping TCP Server...");

        if (server != null && !server.isDisposed()) {
            server.disposeNow();
        }

        running = false;
        logger.info("TCP Server stopped");
    }

    public int getActiveConnectionCount() {
        return connectionTracker.getActiveConnectionCount();
    }

    public Mono<Boolean> sendCommandToDevice(String deviceId, String command) {
        return Mono.fromCallable(() -> {
            try {
                // Get connection from Redis
                ConnectionInfo connectionInfo =
                        connectionTracker.getConnectionByDeviceId(deviceId);

                if (connectionInfo == null) {
                    logger.warn("No active connection found for device {}", deviceId);
                    return false;
                }

                // Get Netty connection
                Connection nettyConnection = connectionInfo.getNettyConnection();
                if (nettyConnection == null || nettyConnection.isDisposed()) {
                    logger.warn("Connection for device {} is not available", deviceId);
                    // Clean up stale connection
                    connectionTracker.removeConnection(connectionInfo.getConnectionId());
                    return false;
                }

                // Send command through the connection
                nettyConnection.outbound()
                        .sendString(Mono.just(command + messageDelimiter))
                        .then()
                        .block(Duration.ofSeconds(10));

                logger.debug("Command sent to device {}: {}", deviceId, command);
                return true;

            } catch (Exception e) {
                logger.error("Error sending command to device {}", deviceId, e);
                return false;
            }
        }).subscribeOn(Schedulers.boundedElastic());
    }
}```

=== ./main-app/src/main/java/com/jjenus/tracker/main/TrackingEngineApplication.java ===
```.java
package com.jjenus.tracker.main;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.scheduling.annotation.EnableScheduling;

@SpringBootApplication(scanBasePackages = "com.jjenus.tracker")
@EnableScheduling
public class TrackingEngineApplication {
    
    public static void main(String[] args) {
        SpringApplication.run(TrackingEngineApplication.class, args);
    }
}```

=== ./main-app/src/main/java/com/jjenus/tracker/main/config/AppConfig.java ===
```.java
package com.jjenus.tracker.main.config;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
import com.jjenus.tracker.shared.domain.ConnectionInfo;
import org.springframework.boot.autoconfigure.jms.DefaultJmsListenerContainerFactoryConfigurer;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;
import org.springframework.data.redis.serializer.StringRedisSerializer;
import org.springframework.jms.annotation.EnableJms;
import org.springframework.jms.config.DefaultJmsListenerContainerFactory;
import org.springframework.jms.config.JmsListenerContainerFactory;
import org.springframework.jms.support.converter.MappingJackson2MessageConverter;
import org.springframework.jms.support.converter.MessageConverter;
import org.springframework.jms.support.converter.MessageType;

import jakarta.jms.ConnectionFactory;

@Configuration
@EnableJms
public class AppConfig {
    
    @Bean
    public ObjectMapper objectMapper() {
        ObjectMapper mapper = new ObjectMapper();
        mapper.registerModule(new JavaTimeModule());
        // Enable polymorphic types for DomainEvent hierarchy
        mapper.activateDefaultTyping(mapper.getPolymorphicTypeValidator(), 
                                   ObjectMapper.DefaultTyping.NON_FINAL);
        return mapper;
    }
    
    @Bean
    @Primary
    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory connectionFactory,
                                                      ObjectMapper objectMapper) {
        RedisTemplate<String, Object> template = new RedisTemplate<>();
        template.setConnectionFactory(connectionFactory);
        template.setKeySerializer(new StringRedisSerializer());
        
        GenericJackson2JsonRedisSerializer serializer = 
            new GenericJackson2JsonRedisSerializer(objectMapper);
        template.setValueSerializer(serializer);
        template.setHashValueSerializer(serializer);
        
        return template;
    }
    
    @Bean
    public RedisTemplate<String, ConnectionInfo> connectionInfoRedisTemplate(
            RedisConnectionFactory connectionFactory, ObjectMapper objectMapper) {
        
        RedisTemplate<String, ConnectionInfo> template = new RedisTemplate<>();
        template.setConnectionFactory(connectionFactory);
        template.setKeySerializer(new StringRedisSerializer());
        
        GenericJackson2JsonRedisSerializer serializer = 
            new GenericJackson2JsonRedisSerializer(objectMapper);
        template.setValueSerializer(serializer);
        
        return template;
    }
    
    @Bean
    public JmsListenerContainerFactory<?> jmsListenerContainerFactory(
            ConnectionFactory connectionFactory,
            DefaultJmsListenerContainerFactoryConfigurer configurer) {
        
        DefaultJmsListenerContainerFactory factory = new DefaultJmsListenerContainerFactory();
        configurer.configure(factory, connectionFactory);
        factory.setConcurrency("3-10");
        factory.setErrorHandler(t -> {
            System.err.println("Error in JMS listener: " + t.getMessage());
        });
        return factory;
    }
    
    @Bean
    public MessageConverter jacksonJmsMessageConverter(ObjectMapper objectMapper) {
        MappingJackson2MessageConverter converter = new MappingJackson2MessageConverter();
        converter.setTargetType(MessageType.TEXT);
        converter.setTypeIdPropertyName("_type");
        converter.setObjectMapper(objectMapper);
        return converter;
    }
}```

=== ./shared/src/main/java/com/jjenus/tracker/shared/domain/ConnectionInfo.java ===
```.java
package com.jjenus.tracker.shared.domain;

import java.time.Instant;

public class ConnectionInfo {
    private String connectionId;
    private String deviceId;
    private String clientIp;
    private Instant connectedAt;
    private Instant lastSeen;
    private transient reactor.netty.Connection nettyConnection; // Transient = not serialized

    // Default constructor for Jackson
    public ConnectionInfo() {}

    public ConnectionInfo(String connectionId, String deviceId, String clientIp,
                          reactor.netty.Connection nettyConnection) {
        this.connectionId = connectionId;
        this.deviceId = deviceId;
        this.clientIp = clientIp;
        this.nettyConnection = nettyConnection;
        this.connectedAt = Instant.now();
        this.lastSeen = this.connectedAt;
    }

    public void updateLastSeen() {
        this.lastSeen = Instant.now();
    }

    // Getters and Setters (required for Jackson)
    public String getConnectionId() { return connectionId; }
    public void setConnectionId(String connectionId) { this.connectionId = connectionId; }

    public String getDeviceId() { return deviceId; }
    public void setDeviceId(String deviceId) { this.deviceId = deviceId; }

    public String getClientIp() { return clientIp; }
    public void setClientIp(String clientIp) { this.clientIp = clientIp; }

    public Instant getConnectedAt() { return connectedAt; }
    public void setConnectedAt(Instant connectedAt) { this.connectedAt = connectedAt; }

    public Instant getLastSeen() { return lastSeen; }
    public void setLastSeen(Instant lastSeen) { this.lastSeen = lastSeen; }

    public reactor.netty.Connection getNettyConnection() { return nettyConnection; }
    public void setNettyConnection(reactor.netty.Connection nettyConnection) {
        this.nettyConnection = nettyConnection;
    }

    @Override
    public String toString() {
        return "ConnectionInfo{" +
                "connectionId='" + connectionId + '\'' +
                ", deviceId='" + deviceId + '\'' +
                ", clientIp='" + clientIp + '\'' +
                ", connectedAt=" + connectedAt +
                ", lastSeen=" + lastSeen +
                '}';
    }
}

```

=== ./shared/src/main/java/com/jjenus/tracker/shared/domain/LocationDataEvent.java ===
```.java
package com.jjenus.tracker.shared.domain;

import com.jjenus.tracker.shared.pubsub.DomainEvent;
import java.util.Map;
import java.util.HashMap;

public class LocationDataEvent extends DomainEvent {
    private final String deviceId;
    private final LocationPoint location;
    private final String protocol;
    private final Map<String, Object> metaData;
    
    public LocationDataEvent(String deviceId, LocationPoint location, String protocol) {
        this.deviceId = deviceId;
        this.location = location;
        this.protocol = protocol;
        this.metaData = new HashMap<>();
    }
    
    public LocationDataEvent(String deviceId, LocationPoint location, String protocol, private final Map<String, Object> metaData) {
        this.deviceId = deviceId;
        this.location = location;
        this.protocol = protocol;
        this.metaData = metaData;
    }

    public String getDeviceId() { return deviceId; }
    public LocationPoint getLocation() { return location; }
    public String getProtocol() { return protocol; }
    public String getMetaData() { return protocol; }
}
```

=== ./shared/src/main/java/com/jjenus/tracker/shared/domain/LocationPoint.java ===
```.java
package com.jjenus.tracker.shared.domain;

import java.time.Instant;

public record LocationPoint(
    double latitude,
    double longitude,
    float speedKmh,
    Instant timestamp
) {
    public boolean isValid() {
        return latitude >= -90 && latitude <= 90 &&
               longitude >= -180 && longitude <= 180 &&
               speedKmh >= 0 &&
               timestamp != null;
    }

    public double distanceTo(LocationPoint other) {
        final int R = 6371;

        double latDistance = Math.toRadians(other.latitude() - this.latitude());
        double lonDistance = Math.toRadians(other.longitude() - this.longitude());

        double a = Math.sin(latDistance / 2) * Math.sin(latDistance / 2)
                 + Math.cos(Math.toRadians(this.latitude()))
                 * Math.cos(Math.toRadians(other.latitude()))
                 * Math.sin(lonDistance / 2) * Math.sin(lonDistance / 2);

        double c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

        return R * c;
    }
}
```

=== ./shared/src/main/java/com/jjenus/tracker/shared/exception/BusinessRuleException.java ===
```.java
package com.jjenus.tracker.shared.exception;

public class BusinessRuleException extends DomainException {
    public BusinessRuleException(String errorCode, String message) {
        super(errorCode, message);
    }

    public BusinessRuleException(String errorCode, String message, Throwable cause) {
        super(errorCode, message, cause);
    }
}
```

=== ./shared/src/main/java/com/jjenus/tracker/shared/exception/DomainException.java ===
```.java
package com.jjenus.tracker.shared.exception;

public abstract class DomainException extends RuntimeException {
    private final String errorCode;

    public DomainException(String errorCode, String message) {
        super(message);
        this.errorCode = errorCode;
    }

    public DomainException(String errorCode, String message, Throwable cause) {
        super(message, cause);
        this.errorCode = errorCode;
    }

    public String getErrorCode() {
        return errorCode;
    }
}
```

=== ./shared/src/main/java/com/jjenus/tracker/shared/exception/InfrastructureException.java ===
```.java
package com.jjenus.tracker.shared.exception;

public class InfrastructureException extends DomainException {
    public InfrastructureException(String errorCode, String message) {
        super(errorCode, message);
    }

    public InfrastructureException(String errorCode, String message, Throwable cause) {
        super(errorCode, message, cause);
    }
}
```

=== ./shared/src/main/java/com/jjenus/tracker/shared/exception/ValidationException.java ===
```.java
package com.jjenus.tracker.shared.exception;

public class ValidationException extends DomainException {
    public ValidationException(String errorCode, String message) {
        super(errorCode, message);
    }

    public ValidationException(String errorCode, String message, Throwable cause) {
        super(errorCode, message, cause);
    }
}
```

=== ./shared/src/main/java/com/jjenus/tracker/shared/pubsub/ArtemisEventPublisher.java ===
```.java
package com.jjenus.tracker.shared.pubsub;

import com.fasterxml.jackson.databind.ObjectMapper;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.jms.core.JmsTemplate;
import org.springframework.stereotype.Component;

@Component
public class ArtemisEventPublisher implements EventPublisher {
    private static final Logger logger = LoggerFactory.getLogger(ArtemisEventPublisher.class);
    
    private final JmsTemplate jmsTemplate;
    private final ObjectMapper objectMapper;
    
    public ArtemisEventPublisher(JmsTemplate jmsTemplate, ObjectMapper objectMapper) {
        this.jmsTemplate = jmsTemplate;
        this.objectMapper = objectMapper;
    }
    
    @Override
    public void publish(DomainEvent event) {
        try {
            // Use event type as destination name for topic-based routing
            String destination = "tracking.events." + event.getClass().getSimpleName().toLowerCase();
            
            jmsTemplate.convertAndSend(destination, event);
            
            logger.debug("Published event {} to destination {}", event.getEventId(), destination);
            
        } catch (Exception e) {
            logger.error("Failed to publish event {}", event.getEventId(), e);
            throw new RuntimeException("Failed to publish event", e);
        }
    }
}```

=== ./shared/src/main/java/com/jjenus/tracker/shared/pubsub/DomainEvent.java ===
```.java
package com.jjenus.tracker.shared.pubsub;

import com.fasterxml.jackson.annotation.JsonTypeInfo;
import java.time.Instant;
import java.util.UUID;

@JsonTypeInfo(use = JsonTypeInfo.Id.CLASS, property = "@class")
public abstract class DomainEvent {
    private final String eventId;
    private final Instant occurredOn;

    public DomainEvent() {
        this.eventId = UUID.randomUUID().toString();
        this.occurredOn = Instant.now();
    }

    public String getEventId() { return eventId; }
    public Instant getOccurredOn() { return occurredOn; }
}```

=== ./shared/src/main/java/com/jjenus/tracker/shared/pubsub/EventHandler.java ===
```.java
package com.jjenus.tracker.shared.pubsub;

@FunctionalInterface
public interface EventHandler<T extends DomainEvent> {
    void handle(T event);
}
```

=== ./shared/src/main/java/com/jjenus/tracker/shared/pubsub/EventPublisher.java ===
```.java
package com.jjenus.tracker.shared.pubsub;

public interface EventPublisher {
    void publish(DomainEvent event);
}
```

=== ./shared/src/main/java/com/jjenus/tracker/shared/pubsub/EventSubscriber.java ===
```.java
package com.jjenus.tracker.shared.pubsub;

public interface EventSubscriber {
    <T extends DomainEvent> void subscribe(Class<T> eventType, EventHandler<T> handler);
    void unsubscribe(Class<? extends DomainEvent> eventType, EventHandler<?> handler);
}
```

=== ./shared/src/main/java/com/jjenus/tracker/shared/pubsub/SimpleEventBus.java ===
```.java
package com.jjenus.tracker.shared.pubsub;

import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.RejectedExecutionException;

public class SimpleEventBus implements EventPublisher, EventSubscriber {
    private final ConcurrentHashMap<Class<?>, CopyOnWriteArrayList<EventHandler<?>>> handlers;
    private final ExecutorService executor;

    public SimpleEventBus() {
        this.handlers = new ConcurrentHashMap<>();
        this.executor = Executors.newFixedThreadPool(10);
    }

    @Override
    public void publish(DomainEvent event) {
        if (event == null) {
            return;
        }

        Class<?> eventType = event.getClass();
        CopyOnWriteArrayList<EventHandler<?>> eventHandlers = handlers.get(eventType);

        if (eventHandlers != null && !eventHandlers.isEmpty()) {
            for (EventHandler handler : eventHandlers) {
                try {
                    executor.submit(() -> {
                        try {
                            handler.handle(event);
                        } catch (Exception e) {
                            System.err.println("Error handling event: " + e.getMessage());
                        }
                    });
                } catch (RejectedExecutionException e) {
                    // Executor is shutting down, ignore
                    System.err.println("Event rejected from executor: " + e.getMessage());
                }
            }
        }
    }

    @Override
    public <T extends DomainEvent> void subscribe(Class<T> eventType, EventHandler<T> handler) {
        if (eventType == null || handler == null) {
            return;
        }
        handlers.computeIfAbsent(eventType, k -> new CopyOnWriteArrayList<>()).add(handler);
    }

    @Override
    public void unsubscribe(Class<? extends DomainEvent> eventType, EventHandler<?> handler) {
        if (eventType == null || handler == null) {
            return;
        }
        CopyOnWriteArrayList<EventHandler<?>> eventHandlers = handlers.get(eventType);
        if (eventHandlers != null) {
            eventHandlers.remove(handler);
        }
    }

    public void shutdown() {
        executor.shutdown();
    }
}
```

=== ./shared/src/main/java/com/jjenus/tracker/shared/redis/RedisConnectionTracker.java ===
```.java
package com.jjenus.tracker.shared.redis;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.jjenus.tracker.shared.domain.ConnectionInfo;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.core.ValueOperations;
import org.springframework.stereotype.Component;

import java.time.Duration;
import java.time.Instant;
import java.util.HashMap;
import java.util.Map;

@Component
public class RedisConnectionTracker {
    private static final Logger logger = LoggerFactory.getLogger(RedisConnectionTracker.class);

    private final RedisTemplate<String, Object> redisTemplate;
    private final ValueOperations<String, Object> valueOps;

    public RedisConnectionTracker(RedisTemplate<String, Object> redisTemplate) {
        this.redisTemplate = redisTemplate;
        this.valueOps = redisTemplate.opsForValue();
    }

    public void registerConnection(String connectionId, String deviceId, String clientIp,
                                   reactor.netty.Connection nettyConnection) {
        ConnectionInfo info = new ConnectionInfo(connectionId, deviceId, clientIp, nettyConnection);

        // Store in Redis with TTL
        String key = getConnectionKey(connectionId);
        valueOps.set(key, info, Duration.ofHours(1));

        // Also store reverse lookup: deviceId -> connectionId
        if (!"unknown".equals(deviceId)) {
            String deviceKey = getDeviceConnectionKey(deviceId);
            valueOps.set(deviceKey, connectionId, Duration.ofHours(1));
        }

        logger.info("Registered connection {} for device {}", connectionId, deviceId);
    }

    public void updateConnectionDevice(String connectionId, String deviceId) {
        ConnectionInfo info = getConnectionInfo(connectionId);
        if (info != null) {
            info.setDeviceId(deviceId);

            // Update Redis
            String key = getConnectionKey(connectionId);
            valueOps.set(key, info, Duration.ofHours(1));

            // Update reverse lookup
            String deviceKey = getDeviceConnectionKey(deviceId);
            valueOps.set(deviceKey, connectionId, Duration.ofHours(1));

            logger.info("Updated connection {} with device ID {}", connectionId, deviceId);
        }
    }

    public void updateLastSeen(String connectionId) {
        ConnectionInfo info = getConnectionInfo(connectionId);
        if (info != null) {
            info.updateLastSeen();

            // Update Redis
            String key = getConnectionKey(connectionId);
            valueOps.set(key, info, Duration.ofHours(1));
        }
    }

    public void removeConnection(String connectionId) {
        // Get info before removing
        ConnectionInfo info = getConnectionInfo(connectionId);

        // Remove from Redis
        String key = getConnectionKey(connectionId);
        redisTemplate.delete(key);

        // Remove reverse lookup if we have device ID
        if (info != null && info.getDeviceId() != null && !"unknown".equals(info.getDeviceId())) {
            String deviceKey = getDeviceConnectionKey(info.getDeviceId());
            redisTemplate.delete(deviceKey);
        }

        logger.info("Removed connection {}", connectionId);
    }

    public ConnectionInfo getConnectionInfo(String connectionId) {
        String key = getConnectionKey(connectionId);
        Object value = valueOps.get(key);

        if (value instanceof ConnectionInfo) {
            return (ConnectionInfo) value;
        }
        return null;
    }

    public ConnectionInfo getConnectionByDeviceId(String deviceId) {
        // First get connectionId from reverse lookup
        String deviceKey = getDeviceConnectionKey(deviceId);
        Object value = valueOps.get(deviceKey);

        if (value instanceof String) {
            return getConnectionInfo((String) value);
        }

        return null;
    }

    public int getActiveConnectionCount() {
        // Count from Redis for accuracy across instances
        String pattern = getConnectionKey("*");
        Long count = redisTemplate.countExistingKeys(redisTemplate.keys(pattern));
        return count != null ? count.intValue() : 0;
    }

    public Map<String, ConnectionInfo> getAllConnections() {
        Map<String, ConnectionInfo> connections = new HashMap<>();

        String pattern = getConnectionKey("*");
        redisTemplate.keys(pattern).forEach(key -> {
            Object value = valueOps.get(key);
            if (value instanceof ConnectionInfo info) {
                connections.put(info.getConnectionId(), info);
            }
        });

        return connections;
    }

    private String getConnectionKey(String connectionId) {
        return "tracker:connection:" + connectionId;
    }

    private String getDeviceConnectionKey(String deviceId) {
        return "tracker:device:connection:" + deviceId;
    }
}```

