=== ./src/main/java/com/jjenus/tracker/alerting/api/AlertRuleController.java ===
```.java
package com.jjenus.tracker.alerting.api;

import com.jjenus.tracker.alerting.api.dto.*;
import com.jjenus.tracker.alerting.application.service.AlertRuleService;
import com.jjenus.tracker.alerting.domain.enums.AlertRuleType;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.data.domain.Sort;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import jakarta.validation.Valid;
import java.util.List;

@RestController
@RequestMapping("/api/alert-rules")
@Tag(name = "Alert Rules", description = "Alert rule management endpoints")
public class AlertRuleController {

    private final AlertRuleService ruleService;

    public AlertRuleController(AlertRuleService ruleService) {
        this.ruleService = ruleService;
    }

    // ========== CRUD ENDPOINTS ==========

    @PostMapping
    @Operation(summary = "Create a new custom alert rule")
    public ResponseEntity<AlertRuleResponse> createRule(@Valid @RequestBody CreateAlertRuleRequest request) {
        return ResponseEntity.status(HttpStatus.CREATED)
                .body(ruleService.createRule(request));
    }

    @GetMapping
    @Operation(summary = "Get all alert rules with pagination and filtering")
    public ResponseEntity<PagedResponse<AlertRuleResponse>> getAllRules(
            @Parameter(description = "Page number (0-based)")
            @RequestParam(defaultValue = "0") int page,

            @Parameter(description = "Page size")
            @RequestParam(defaultValue = "20") int size,

            @Parameter(description = "Sort field")
            @RequestParam(defaultValue = "createdAt") String sortBy,

            @Parameter(description = "Sort direction")
            @RequestParam(defaultValue = "DESC") Sort.Direction sortDirection,

            @Parameter(description = "Search term for rule name")
            @RequestParam(required = false) String search,

            @Parameter(description = "Filter by rule type")
            @RequestParam(required = false) AlertRuleType ruleType,

            @Parameter(description = "Filter by enabled status")
            @RequestParam(required = false) Boolean enabled) {

        SearchRequest searchRequest = new SearchRequest();
        searchRequest.setPage(page);
        searchRequest.setSize(size);
        searchRequest.setSortBy(sortBy);
        searchRequest.setSortDirection(sortDirection);
        searchRequest.setSearch(search);
        searchRequest.setRuleType(ruleType);
        searchRequest.setEnabled(enabled);

        return ResponseEntity.ok(ruleService.getAllRulesPaged(searchRequest));
    }

    @GetMapping("/enabled")
    @Operation(summary = "Get all enabled alert rules with pagination")
    public ResponseEntity<PagedResponse<AlertRuleResponse>> getEnabledRules(
            @Parameter(description = "Page number (0-based)")
            @RequestParam(defaultValue = "0") int page,

            @Parameter(description = "Page size")
            @RequestParam(defaultValue = "20") int size,

            @Parameter(description = "Sort field")
            @RequestParam(defaultValue = "priority") String sortBy,

            @Parameter(description = "Sort direction")
            @RequestParam(defaultValue = "DESC") Sort.Direction sortDirection,

            @Parameter(description = "Search term for rule name")
            @RequestParam(required = false) String search) {

        SearchRequest searchRequest = new SearchRequest();
        searchRequest.setPage(page);
        searchRequest.setSize(size);
        searchRequest.setSortBy(sortBy);
        searchRequest.setSortDirection(sortDirection);
        searchRequest.setSearch(search);
        searchRequest.setEnabled(true);

        return ResponseEntity.ok(ruleService.getEnabledRulesPaged(searchRequest));
    }

    @GetMapping("/list")
    @Operation(summary = "Get all alert rules (without pagination)")
    public ResponseEntity<List<AlertRuleResponse>> getAllRulesList() {
        return ResponseEntity.ok(ruleService.getAllRules());
    }

    @GetMapping("/enabled/list")
    @Operation(summary = "Get all enabled alert rules (without pagination)")
    public ResponseEntity<List<AlertRuleResponse>> getEnabledRulesList() {
        return ResponseEntity.ok(ruleService.getEnabledRules());
    }

    @GetMapping("/{ruleKey}")
    @Operation(summary = "Get alert rule by key")
    public ResponseEntity<AlertRuleResponse> getRuleByKey(@PathVariable String ruleKey) {
        return ResponseEntity.ok(ruleService.getRuleByKey(ruleKey));
    }

    @PutMapping("/{ruleKey}")
    @Operation(summary = "Update an existing alert rule")
    public ResponseEntity<AlertRuleResponse> updateRule(
            @PathVariable String ruleKey,
            @Valid @RequestBody UpdateAlertRuleRequest request) {
        return ResponseEntity.ok(ruleService.updateRule(ruleKey, request));
    }

    @DeleteMapping("/{ruleKey}")
    @Operation(summary = "Delete an alert rule")
    @ResponseStatus(HttpStatus.NO_CONTENT)
    public void deleteRule(@PathVariable String ruleKey) {
        ruleService.deleteRule(ruleKey);
    }

    @PatchMapping("/{ruleKey}/enable")
    @Operation(summary = "Enable an alert rule")
    public ResponseEntity<Void> enableRule(@PathVariable String ruleKey) {
        ruleService.enableRule(ruleKey);
        return ResponseEntity.ok().build();
    }

    @PatchMapping("/{ruleKey}/disable")
    @Operation(summary = "Disable an alert rule")
    public ResponseEntity<Void> disableRule(@PathVariable String ruleKey) {
        ruleService.disableRule(ruleKey);
        return ResponseEntity.ok().build();
    }

    // ========== TEMPLATE ENDPOINTS ==========

    @PostMapping("/templates/overspeed")
    @Operation(summary = "Create overspeed rule from template")
    public ResponseEntity<AlertRuleResponse> createOverspeedRule(
            @Valid @RequestBody OverspeedRuleTemplateRequest request) {
        return ResponseEntity.status(HttpStatus.CREATED)
                .body(ruleService.createOverspeedRule(request));
    }

    @PostMapping("/templates/idle-timeout")
    @Operation(summary = "Create idle timeout rule from template")
    public ResponseEntity<AlertRuleResponse> createIdleTimeoutRule(
            @Valid @RequestBody IdleTimeoutRuleTemplateRequest request) {
        return ResponseEntity.status(HttpStatus.CREATED)
                .body(ruleService.createIdleTimeoutRule(request));
    }

    @PostMapping("/templates/geofence")
    @Operation(summary = "Create geofence rule from template")
    public ResponseEntity<AlertRuleResponse> createGeofenceRule(
            @Valid @RequestBody GeofenceRuleTemplateRequest request) {
        return ResponseEntity.status(HttpStatus.CREATED)
                .body(ruleService.createGeofenceRule(request));
    }

    // ========== BATCH OPERATIONS ==========

    @PostMapping("/batch")
    @Operation(summary = "Create multiple alert rules in batch")
    public ResponseEntity<List<AlertRuleResponse>> batchCreateRules(
            @Valid @RequestBody List<CreateAlertRuleRequest> requests) {
        return ResponseEntity.status(HttpStatus.CREATED)
                .body(ruleService.batchCreateRules(requests));
    }

    @PostMapping("/batch/enable")
    @Operation(summary = "Enable multiple alert rules")
    public ResponseEntity<Void> batchEnableRules(@RequestBody List<String> ruleKeys) {
        ruleService.batchEnableRules(new java.util.HashSet<>(ruleKeys));
        return ResponseEntity.ok().build();
    }
}```

=== ./src/main/java/com/jjenus/tracker/alerting/api/dto/AlertRuleResponse.java ===
```.java
package com.jjenus.tracker.alerting.api.dto;

import com.fasterxml.jackson.annotation.JsonFormat;
import com.jjenus.tracker.alerting.domain.enums.AlertRuleType;

import java.time.Instant;
import java.util.Map;

public class AlertRuleResponse {
    private String ruleKey;
    private String ruleName;
    private AlertRuleType ruleType;
    private Map<String, Object> parameters;
    private int priority;
    private boolean enabled;
    
    @JsonFormat(pattern = "yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", timezone = "UTC")
    private Instant createdAt;
    
    @JsonFormat(pattern = "yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", timezone = "UTC")
    private Instant updatedAt;
    
    // Getters and Setters
    public String getRuleKey() { return ruleKey; }
    public void setRuleKey(String ruleKey) { this.ruleKey = ruleKey; }
    
    public String getRuleName() { return ruleName; }
    public void setRuleName(String ruleName) { this.ruleName = ruleName; }
    
    public AlertRuleType getRuleType() { return ruleType; }
    public void setRuleType(AlertRuleType ruleType) { this.ruleType = ruleType; }
    
    public Map<String, Object> getParameters() { return parameters; }
    public void setParameters(Map<String, Object> parameters) { this.parameters = parameters; }
    
    public int getPriority() { return priority; }
    public void setPriority(int priority) { this.priority = priority; }
    
    public boolean isEnabled() { return enabled; }
    public void setEnabled(boolean enabled) { this.enabled = enabled; }
    
    public Instant getCreatedAt() { return createdAt; }
    public void setCreatedAt(Instant createdAt) { this.createdAt = createdAt; }
    
    public Instant getUpdatedAt() { return updatedAt; }
    public void setUpdatedAt(Instant updatedAt) { this.updatedAt = updatedAt; }
}
```

=== ./src/main/java/com/jjenus/tracker/alerting/api/dto/CreateAlertRuleRequest.java ===
```.java
package com.jjenus.tracker.alerting.api.dto;

import jakarta.validation.constraints.NotEmpty;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Positive;

public class CreateAlertRuleRequest {
    
    @NotEmpty(message = "Rule key is required")
    private String ruleKey;
    
    @NotEmpty(message = "Rule name is required")
    private String ruleName;
    
    @NotEmpty(message = "Rule type is required")
    private String ruleType; // SPEED, GEOFENCE, IDLE_TIME
    
    @NotNull(message = "Parameters are required")
    private String parameters; // JSON
    
    @Positive(message = "Priority must be positive")
    private int priority = 5;
    
    private boolean enabled = true;
    
    // Getters and Setters
    public String getRuleKey() { return ruleKey; }
    public void setRuleKey(String ruleKey) { this.ruleKey = ruleKey; }
    
    public String getRuleName() { return ruleName; }
    public void setRuleName(String ruleName) { this.ruleName = ruleName; }
    
    public String getRuleType() { return ruleType; }
    public void setRuleType(String ruleType) { this.ruleType = ruleType; }
    
    public String getParameters() { return parameters; }
    public void setParameters(String parameters) { this.parameters = parameters; }
    
    public int getPriority() { return priority; }
    public void setPriority(int priority) { this.priority = priority; }
    
    public boolean isEnabled() { return enabled; }
    public void setEnabled(boolean enabled) { this.enabled = enabled; }
}
```

=== ./src/main/java/com/jjenus/tracker/alerting/api/dto/CreateGeofenceRequest.java ===
```.java
package com.jjenus.tracker.alerting.api.dto;

import com.jjenus.tracker.alerting.domain.enums.GeofenceShapeType;
import jakarta.validation.constraints.NotEmpty;
import jakarta.validation.constraints.NotNull;
import java.util.List;

public class CreateGeofenceRequest {

    @NotEmpty(message = "Vehicle ID is required")
    private String vehicleId;

    @NotEmpty(message = "Name is required")
    private String name;

    @NotNull(message = "Shape type is required")
    private GeofenceShapeType shapeType;

    private Double centerLatitude;
    private Double centerLongitude;
    private Integer radiusMeters;

    private List<GeofencePointDto> points;
    private boolean active = true;
    private String createdBy;

    public String getVehicleId() {
        return vehicleId;
    }

    public void setVehicleId(String vehicleId) {
        this.vehicleId = vehicleId;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public GeofenceShapeType getShapeType() {
        return shapeType;
    }

    public void setShapeType(GeofenceShapeType shapeType) {
        this.shapeType = shapeType;
    }

    public Double getCenterLatitude() {
        return centerLatitude;
    }

    public void setCenterLatitude(Double centerLatitude) {
        this.centerLatitude = centerLatitude;
    }

    public Double getCenterLongitude() {
        return centerLongitude;
    }

    public void setCenterLongitude(Double centerLongitude) {
        this.centerLongitude = centerLongitude;
    }

    public Integer getRadiusMeters() {
        return radiusMeters;
    }

    public void setRadiusMeters(Integer radiusMeters) {
        this.radiusMeters = radiusMeters;
    }

    public List<GeofencePointDto> getPoints() {
        return points;
    }

    public void setPoints(List<GeofencePointDto> points) {
        this.points = points;
    }

    public boolean isActive() {
        return active;
    }

    public void setActive(boolean active) {
        this.active = active;
    }

    public String getCreatedBy() {
        return createdBy;
    }

    public void setCreatedBy(String createdBy) {
        this.createdBy = createdBy;
    }
}```

=== ./src/main/java/com/jjenus/tracker/alerting/api/dto/GeofencePointDto.java ===
```.java
package com.jjenus.tracker.alerting.api.dto;

import jakarta.validation.constraints.NotNull;

public class GeofencePointDto {

    @NotNull(message = "Latitude is required")
    private Double latitude;

    @NotNull(message = "Longitude is required")
    private Double longitude;

    public Double getLatitude() {
        return latitude;
    }

    public void setLatitude(Double latitude) {
        this.latitude = latitude;
    }

    public Double getLongitude() {
        return longitude;
    }

    public void setLongitude(Double longitude) {
        this.longitude = longitude;
    }
}```

=== ./src/main/java/com/jjenus/tracker/alerting/api/dto/GeofenceResponse.java ===
```.java
package com.jjenus.tracker.alerting.api.dto;

import com.fasterxml.jackson.annotation.JsonFormat;
import com.jjenus.tracker.alerting.domain.enums.GeofenceShapeType;
import java.time.Instant;
import java.util.List;

public class GeofenceResponse {
    private Long geofenceId;
    private String vehicleId;
    private String name;
    private GeofenceShapeType shapeType;
    private Double centerLatitude;
    private Double centerLongitude;
    private Integer radiusMeters;
    private boolean active;
    private List<GeofencePointDto> points;
    private String description;

    @JsonFormat(pattern = "yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", timezone = "UTC")
    private Instant createdAt;

    @JsonFormat(pattern = "yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", timezone = "UTC")
    private Instant updatedAt;

    public Long getGeofenceId() {
        return geofenceId;
    }

    public void setGeofenceId(Long geofenceId) {
        this.geofenceId = geofenceId;
    }

    public String getVehicleId() {
        return vehicleId;
    }

    public void setVehicleId(String vehicleId) {
        this.vehicleId = vehicleId;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public GeofenceShapeType getShapeType() {
        return shapeType;
    }

    public void setShapeType(GeofenceShapeType shapeType) {
        this.shapeType = shapeType;
    }

    public Double getCenterLatitude() {
        return centerLatitude;
    }

    public void setCenterLatitude(Double centerLatitude) {
        this.centerLatitude = centerLatitude;
    }

    public Double getCenterLongitude() {
        return centerLongitude;
    }

    public void setCenterLongitude(Double centerLongitude) {
        this.centerLongitude = centerLongitude;
    }

    public Integer getRadiusMeters() {
        return radiusMeters;
    }

    public void setRadiusMeters(Integer radiusMeters) {
        this.radiusMeters = radiusMeters;
    }

    public boolean isActive() {
        return active;
    }

    public void setActive(boolean active) {
        this.active = active;
    }

    public List<GeofencePointDto> getPoints() {
        return points;
    }

    public void setPoints(List<GeofencePointDto> points) {
        this.points = points;
    }

    public Instant getCreatedAt() {
        return createdAt;
    }

    public void setCreatedAt(Instant createdAt) {
        this.createdAt = createdAt;
    }

    public Instant getUpdatedAt() {
        return updatedAt;
    }

    public void setUpdatedAt(Instant updatedAt) {
        this.updatedAt = updatedAt;
    }

    public String getDescription() {
        return description;
    }

    public void setDescription(String description) {
        this.description = description;
    }
}```

=== ./src/main/java/com/jjenus/tracker/alerting/api/dto/GeofenceRuleTemplateRequest.java ===
```.java
package com.jjenus.tracker.alerting.api.dto;

import jakarta.validation.constraints.NotEmpty;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Positive;
import jakarta.validation.constraints.Size;

import java.util.Set;

public class GeofenceRuleTemplateRequest {

    @NotEmpty(message = "Rule key is required")
    @Size(min = 3, max = 100, message = "Rule key must be between 3 and 100 characters")
    private String ruleKey;

    @NotEmpty(message = "Rule name is required")
    @Size(min = 3, max = 200, message = "Rule name must be between 3 and 200 characters")
    private String ruleName;

    @NotEmpty(message = "Geofence ID is required")
    private String geofenceId;

    @NotNull(message = "Action is required")
    private GeofenceAction action = GeofenceAction.BOTH;

    @NotNull(message = "Vehicle IDs are required")
    @NotEmpty(message = "At least one vehicle ID is required")
    private Set<String> vehicleIds;

    @Positive(message = "Priority must be positive")
    private Integer priority = 2;

    private boolean enabled = true;

    public enum GeofenceAction {
        ENTRY, EXIT, BOTH
    }

    // Getters and Setters
    public String getRuleKey() { return ruleKey; }
    public void setRuleKey(String ruleKey) { this.ruleKey = ruleKey; }

    public String getRuleName() { return ruleName; }
    public void setRuleName(String ruleName) { this.ruleName = ruleName; }

    public String getGeofenceId() { return geofenceId; }
    public void setGeofenceId(String geofenceId) { this.geofenceId = geofenceId; }

    public GeofenceAction getAction() { return action; }
    public void setAction(GeofenceAction action) { this.action = action; }

    public Set<String> getVehicleIds() { return vehicleIds; }
    public void setVehicleIds(Set<String> vehicleIds) { this.vehicleIds = vehicleIds; }

    public Integer getPriority() { return priority; }
    public void setPriority(Integer priority) { this.priority = priority; }

    public boolean isEnabled() { return enabled; }
    public void setEnabled(boolean enabled) { this.enabled = enabled; }
}```

=== ./src/main/java/com/jjenus/tracker/alerting/api/dto/IdleTimeoutRuleTemplateRequest.java ===
```.java
package com.jjenus.tracker.alerting.api.dto;

import jakarta.validation.constraints.NotEmpty;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Positive;
import jakarta.validation.constraints.Size;

import java.util.Set;

public class IdleTimeoutRuleTemplateRequest {

    @NotEmpty(message = "Rule key is required")
    @Size(min = 3, max = 100, message = "Rule key must be between 3 and 100 characters")
    private String ruleKey;

    @NotEmpty(message = "Rule name is required")
    @Size(min = 3, max = 200, message = "Rule name must be between 3 and 200 characters")
    private String ruleName;

    @NotNull(message = "Max idle minutes is required")
    @Positive(message = "Max idle minutes must be positive")
    private Integer maxIdleMinutes;

    @NotNull(message = "Vehicle IDs are required")
    @NotEmpty(message = "At least one vehicle ID is required")
    private Set<String> vehicleIds;

    @Positive(message = "Priority must be positive")
    private Integer priority = 3;

    private boolean enabled = true;

    // Getters and Setters
    public String getRuleKey() { return ruleKey; }
    public void setRuleKey(String ruleKey) { this.ruleKey = ruleKey; }

    public String getRuleName() { return ruleName; }
    public void setRuleName(String ruleName) { this.ruleName = ruleName; }

    public Integer getMaxIdleMinutes() { return maxIdleMinutes; }
    public void setMaxIdleMinutes(Integer maxIdleMinutes) { this.maxIdleMinutes = maxIdleMinutes; }

    public Set<String> getVehicleIds() { return vehicleIds; }
    public void setVehicleIds(Set<String> vehicleIds) { this.vehicleIds = vehicleIds; }

    public Integer getPriority() { return priority; }
    public void setPriority(Integer priority) { this.priority = priority; }

    public boolean isEnabled() { return enabled; }
    public void setEnabled(boolean enabled) { this.enabled = enabled; }
}
```

=== ./src/main/java/com/jjenus/tracker/alerting/api/dto/OverspeedRuleTemplateRequest.java ===
```.java
package com.jjenus.tracker.alerting.api.dto;

import jakarta.validation.constraints.NotEmpty;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Positive;
import jakarta.validation.constraints.Size;

import java.util.Set;

public class OverspeedRuleTemplateRequest {

    @NotEmpty(message = "Rule key is required")
    @Size(min = 3, max = 100, message = "Rule key must be between 3 and 100 characters")
    private String ruleKey;

    @NotEmpty(message = "Rule name is required")
    @Size(min = 3, max = 200, message = "Rule name must be between 3 and 200 characters")
    private String ruleName;

    @NotNull(message = "Speed limit is required")
    @Positive(message = "Speed limit must be positive")
    private Float speedLimit;

    @Positive(message = "Buffer must be positive")
    private Float buffer = 5.0f;

    @NotNull(message = "Vehicle IDs are required")
    @NotEmpty(message = "At least one vehicle ID is required")
    private Set<String> vehicleIds;

    @Positive(message = "Priority must be positive")
    private Integer priority = 1;

    private boolean enabled = true;

    // Getters and Setters
    public String getRuleKey() { return ruleKey; }
    public void setRuleKey(String ruleKey) { this.ruleKey = ruleKey; }

    public String getRuleName() { return ruleName; }
    public void setRuleName(String ruleName) { this.ruleName = ruleName; }

    public Float getSpeedLimit() { return speedLimit; }
    public void setSpeedLimit(Float speedLimit) { this.speedLimit = speedLimit; }

    public Float getBuffer() { return buffer; }
    public void setBuffer(Float buffer) { this.buffer = buffer; }

    public Set<String> getVehicleIds() { return vehicleIds; }
    public void setVehicleIds(Set<String> vehicleIds) { this.vehicleIds = vehicleIds; }

    public Integer getPriority() { return priority; }
    public void setPriority(Integer priority) { this.priority = priority; }

    public boolean isEnabled() { return enabled; }
    public void setEnabled(boolean enabled) { this.enabled = enabled; }
}```

=== ./src/main/java/com/jjenus/tracker/alerting/api/dto/PagedResponse.java ===
```.java
package com.jjenus.tracker.alerting.api.dto;

import org.springframework.data.domain.Page;
import java.util.List;

public class PagedResponse<T> {
    private List<T> content;
    private int pageNumber;
    private int pageSize;
    private long totalElements;
    private int totalPages;
    private boolean first;
    private boolean last;
    private boolean empty;

    public PagedResponse(Page<T> page) {
        this.content = page.getContent();
        this.pageNumber = page.getNumber();
        this.pageSize = page.getSize();
        this.totalElements = page.getTotalElements();
        this.totalPages = page.getTotalPages();
        this.first = page.isFirst();
        this.last = page.isLast();
        this.empty = page.isEmpty();
    }

    // Getters and Setters
    public List<T> getContent() { return content; }
    public void setContent(List<T> content) { this.content = content; }

    public int getPageNumber() { return pageNumber; }
    public void setPageNumber(int pageNumber) { this.pageNumber = pageNumber; }

    public int getPageSize() { return pageSize; }
    public void setPageSize(int pageSize) { this.pageSize = pageSize; }

    public long getTotalElements() { return totalElements; }
    public void setTotalElements(long totalElements) { this.totalElements = totalElements; }

    public int getTotalPages() { return totalPages; }
    public void setTotalPages(int totalPages) { this.totalPages = totalPages; }

    public boolean isFirst() { return first; }
    public void setFirst(boolean first) { this.first = first; }

    public boolean isLast() { return last; }
    public void setLast(boolean last) { this.last = last; }

    public boolean isEmpty() { return empty; }
    public void setEmpty(boolean empty) { this.empty = empty; }
}```

=== ./src/main/java/com/jjenus/tracker/alerting/api/dto/SearchRequest.java ===
```.java
package com.jjenus.tracker.alerting.api.dto;

import com.jjenus.tracker.alerting.domain.enums.AlertRuleType;
import org.springframework.data.domain.Sort;

public class SearchRequest {
    private Integer page = 0;
    private Integer size = 20;
    private String sortBy = "createdAt";
    private Sort.Direction sortDirection = Sort.Direction.DESC;
    private String search;
    private AlertRuleType ruleType;
    private Boolean enabled;
    private String vehicleId;
    private Boolean active;

    // Getters and Setters
    public Integer getPage() { return page; }
    public void setPage(Integer page) { this.page = page; }

    public Integer getSize() { return size; }
    public void setSize(Integer size) { this.size = size; }

    public String getSortBy() { return sortBy; }
    public void setSortBy(String sortBy) { this.sortBy = sortBy; }

    public Sort.Direction getSortDirection() { return sortDirection; }
    public void setSortDirection(Sort.Direction sortDirection) { this.sortDirection = sortDirection; }

    public String getSearch() { return search; }
    public void setSearch(String search) { this.search = search; }

    public AlertRuleType getRuleType() { return ruleType; }
    public void setRuleType(AlertRuleType ruleType) { this.ruleType = ruleType; }

    public Boolean getEnabled() { return enabled; }
    public void setEnabled(Boolean enabled) { this.enabled = enabled; }

    public String getVehicleId() { return vehicleId; }
    public void setVehicleId(String vehicleId) { this.vehicleId = vehicleId; }

    public Boolean getActive() { return active; }
    public void setActive(Boolean active) { this.active = active; }
}```

=== ./src/main/java/com/jjenus/tracker/alerting/api/dto/UpdateAlertRuleRequest.java ===
```.java
package com.jjenus.tracker.alerting.api.dto;

import jakarta.validation.constraints.PositiveOrZero;
import jakarta.validation.constraints.Size;
import java.util.Map;

public class UpdateAlertRuleRequest {

    @Size(min = 3, max = 200, message = "Rule name must be between 3 and 200 characters")
    private String ruleName;

    @Size(min = 3, max = 100, message = "Rule key must be between 3 and 100 characters")
    private String ruleKey;

    private Map<String, Object> parameters;

    @PositiveOrZero(message = "Priority must be zero or positive")
    private int priority = -1; // -1 means not updating

    // Getters and Setters
    public String getRuleName() { return ruleName; }
    public void setRuleName(String ruleName) { this.ruleName = ruleName; }

    public String getRuleKey() { return ruleKey; }
    public void setRuleKey(String ruleKey) { this.ruleKey = ruleKey; }

    public Map<String, Object> getParameters() { return parameters; }
    public void setParameters(Map<String, Object> parameters) { this.parameters = parameters; }

    public int getPriority() { return priority; }
    public void setPriority(int priority) { this.priority = priority; }
}```

=== ./src/main/java/com/jjenus/tracker/alerting/api/dto/UpdateGeofenceRequest.java ===
```.java
package com.jjenus.tracker.alerting.api.dto;

import com.jjenus.tracker.alerting.domain.enums.GeofenceShapeType;
import jakarta.validation.constraints.Size;
import java.util.Set;

public class UpdateGeofenceRequest {

    @Size(min = 1, max = 100, message = "Name must be between 1 and 100 characters")
    private String name;

    @Size(max = 500, message = "Description cannot exceed 500 characters")
    private String description;

    private GeofenceShapeType shapeType;

    private Double centerLatitude;
    private Double centerLongitude;
    private Integer radiusMeters;

    private Boolean active;

    private Set<String> vehicleIds;

    // Getters and Setters
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }

    public String getDescription() { return description; }
    public void setDescription(String description) { this.description = description; }

    public GeofenceShapeType getShapeType() { return shapeType; }
    public void setShapeType(GeofenceShapeType shapeType) { this.shapeType = shapeType; }

    public Double getCenterLatitude() { return centerLatitude; }
    public void setCenterLatitude(Double centerLatitude) { this.centerLatitude = centerLatitude; }

    public Double getCenterLongitude() { return centerLongitude; }
    public void setCenterLongitude(Double centerLongitude) { this.centerLongitude = centerLongitude; }

    public Integer getRadiusMeters() { return radiusMeters; }
    public void setRadiusMeters(Integer radiusMeters) { this.radiusMeters = radiusMeters; }

    public Boolean isActive() { return active; }
    public void setActive(Boolean active) { this.active = active; }

    public Set<String> getVehicleIds() { return vehicleIds; }
    public void setVehicleIds(Set<String> vehicleIds) { this.vehicleIds = vehicleIds; }
}```

=== ./src/main/java/com/jjenus/tracker/alerting/api/GeofenceController.java ===
```.java
package com.jjenus.tracker.alerting.api;

import com.jjenus.tracker.alerting.api.dto.*;
import com.jjenus.tracker.alerting.application.service.GeofenceService;
import com.jjenus.tracker.alerting.domain.entity.Geofence;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.data.domain.Sort;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import jakarta.validation.Valid;
import java.util.List;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/api/geofences")
@Tag(name = "Geofences", description = "Geofence management endpoints")
public class GeofenceController {

    private final GeofenceService geofenceService;

    public GeofenceController(GeofenceService geofenceService) {
        this.geofenceService = geofenceService;
    }

    @PostMapping
    @Operation(summary = "Create a new geofence")
    public ResponseEntity<GeofenceResponse> createGeofence(@Valid @RequestBody CreateGeofenceRequest request) {
        Geofence geofence = convertToEntity(request);
        Geofence created = geofenceService.createGeofence(geofence);
        return ResponseEntity.status(HttpStatus.CREATED).body(toResponse(created));
    }

    @GetMapping
    @Operation(summary = "Search geofences with pagination and filtering")
    public ResponseEntity<PagedResponse<GeofenceResponse>> searchGeofences(
            @Parameter(description = "Page number (0-based)")
            @RequestParam(defaultValue = "0") int page,

            @Parameter(description = "Page size")
            @RequestParam(defaultValue = "20") int size,

            @Parameter(description = "Sort field")
            @RequestParam(defaultValue = "createdAt") String sortBy,

            @Parameter(description = "Sort direction")
            @RequestParam(defaultValue = "DESC") Sort.Direction sortDirection,

            @Parameter(description = "Search term for geofence name")
            @RequestParam(required = false) String search,

            @Parameter(description = "Filter by vehicle ID")
            @RequestParam(required = false) String vehicleId,

            @Parameter(description = "Filter by active status")
            @RequestParam(required = false) Boolean active) {

        SearchRequest searchRequest = new SearchRequest();
        searchRequest.setPage(page);
        searchRequest.setSize(size);
        searchRequest.setSortBy(sortBy);
        searchRequest.setSortDirection(sortDirection);
        searchRequest.setSearch(search);
        searchRequest.setVehicleId(vehicleId);
        searchRequest.setActive(active);

        return ResponseEntity.ok(geofenceService.searchGeofences(searchRequest));
    }

    @GetMapping("/vehicle/{vehicleId}")
    @Operation(summary = "Get all geofences for a vehicle with pagination")
    public ResponseEntity<PagedResponse<GeofenceResponse>> getVehicleGeofences(
            @PathVariable String vehicleId,
            @Parameter(description = "Page number (0-based)")
            @RequestParam(defaultValue = "0") int page,

            @Parameter(description = "Page size")
            @RequestParam(defaultValue = "20") int size,

            @Parameter(description = "Sort field")
            @RequestParam(defaultValue = "name") String sortBy,

            @Parameter(description = "Sort direction")
            @RequestParam(defaultValue = "ASC") Sort.Direction sortDirection) {

        SearchRequest searchRequest = new SearchRequest();
        searchRequest.setPage(page);
        searchRequest.setSize(size);
        searchRequest.setSortBy(sortBy);
        searchRequest.setSortDirection(sortDirection);

        return ResponseEntity.ok(geofenceService.getVehicleGeofencesPaged(vehicleId, searchRequest));
    }

    @GetMapping("/vehicle/{vehicleId}/list")
    @Operation(summary = "Get all geofences for a vehicle (without pagination)")
    public ResponseEntity<List<GeofenceResponse>> getVehicleGeofencesList(@PathVariable String vehicleId) {
        List<Geofence> geofences = geofenceService.getVehicleGeofences(vehicleId);
        return ResponseEntity.ok(geofences.stream()
                .map(this::toResponse)
                .collect(Collectors.toList()));
    }

    @GetMapping("/vehicle/{vehicleId}/active")
    @Operation(summary = "Get active geofences for a vehicle with pagination")
    public ResponseEntity<PagedResponse<GeofenceResponse>> getActiveVehicleGeofences(
            @PathVariable String vehicleId,
            @Parameter(description = "Page number (0-based)")
            @RequestParam(defaultValue = "0") int page,

            @Parameter(description = "Page size")
            @RequestParam(defaultValue = "20") int size,

            @Parameter(description = "Sort field")
            @RequestParam(defaultValue = "name") String sortBy,

            @Parameter(description = "Sort direction")
            @RequestParam(defaultValue = "ASC") Sort.Direction sortDirection) {

        SearchRequest searchRequest = new SearchRequest();
        searchRequest.setPage(page);
        searchRequest.setSize(size);
        searchRequest.setSortBy(sortBy);
        searchRequest.setSortDirection(sortDirection);

        return ResponseEntity.ok(geofenceService.getActiveGeofencesPaged(vehicleId, searchRequest));
    }

    @GetMapping("/vehicle/{vehicleId}/active/list")
    @Operation(summary = "Get active geofences for a vehicle (without pagination)")
    public ResponseEntity<List<GeofenceResponse>> getActiveVehicleGeofencesList(@PathVariable String vehicleId) {
        List<Geofence> geofences = geofenceService.getActiveGeofences(vehicleId);
        return ResponseEntity.ok(geofences.stream()
                .map(this::toResponse)
                .collect(Collectors.toList()));
    }

    @GetMapping("/{geofenceId}")
    @Operation(summary = "Get geofence by ID")
    public ResponseEntity<GeofenceResponse> getGeofenceById(@PathVariable Long geofenceId) {
        Geofence geofence = geofenceService.getGeofenceById(geofenceId);
        return ResponseEntity.ok(toResponse(geofence));
    }

    @PutMapping("/{geofenceId}")
    @Operation(summary = "Update a geofence")
    public ResponseEntity<GeofenceResponse> updateGeofence(
            @PathVariable Long geofenceId,
            @Valid @RequestBody UpdateGeofenceRequest request) {
        Geofence updates = convertToEntity(request);
        Geofence updated = geofenceService.updateGeofence(geofenceId, updates);
        return ResponseEntity.ok(toResponse(updated));
    }

    @DeleteMapping("/{geofenceId}")
    @Operation(summary = "Delete a geofence")
    @ResponseStatus(HttpStatus.NO_CONTENT)
    public void deleteGeofence(@PathVariable Long geofenceId) {
        geofenceService.deleteGeofence(geofenceId);
    }

    @PostMapping("/check-violations")
    @Operation(summary = "Check for geofence violations (for testing)")
    public ResponseEntity<Void> checkGeofenceViolations(
            @RequestParam String vehicleId,
            @RequestParam Double latitude,
            @RequestParam Double longitude) {
        geofenceService.checkGeofenceViolations(vehicleId, latitude, longitude);
        return ResponseEntity.ok().build();
    }

    // ========== HELPER METHODS ==========

    private Geofence convertToEntity(CreateGeofenceRequest request) {
        Geofence geofence = new Geofence();
        geofence.setVehicleIds(new java.util.HashSet<>());
        geofence.getVehicleIds().add(request.getVehicleId());
        geofence.setName(request.getName());
        geofence.setShapeType(request.getShapeType());
        geofence.setCenterLatitude(request.getCenterLatitude());
        geofence.setCenterLongitude(request.getCenterLongitude());
        geofence.setRadiusMeters(request.getRadiusMeters());
        geofence.setIsActive(request.isActive());
        geofence.setCreatedBy(request.getCreatedBy());

        // Add polygon points if provided
        if (request.getPoints() != null) {
            for (int i = 0; i < request.getPoints().size(); i++) {
                GeofencePointDto point = request.getPoints().get(i);
                geofence.addPoint(point.getLatitude(), point.getLongitude(), i + 1);
            }
        }

        return geofence;
    }

    private Geofence convertToEntity(UpdateGeofenceRequest request) {
        Geofence geofence = new Geofence();
        geofence.setName(request.getName());
        geofence.setIsActive(request.isActive());
        geofence.setShapeType(request.getShapeType());
        geofence.setCenterLatitude(request.getCenterLatitude());
        geofence.setCenterLongitude(request.getCenterLongitude());
        geofence.setRadiusMeters(request.getRadiusMeters());
        return geofence;
    }

    private GeofenceResponse toResponse(Geofence geofence) {
        GeofenceResponse response = new GeofenceResponse();
        response.setGeofenceId(geofence.getGeofenceId());
        response.setVehicleId(geofence.getVehicleIds().stream().findFirst().orElse(null));
        response.setName(geofence.getName());
        response.setShapeType(geofence.getShapeType());
        response.setCenterLatitude(geofence.getCenterLatitude());
        response.setCenterLongitude(geofence.getCenterLongitude());
        response.setRadiusMeters(geofence.getRadiusMeters());
        response.setActive(Boolean.TRUE.equals(geofence.getIsActive()));
        response.setCreatedAt(geofence.getCreatedAt());
        response.setUpdatedAt(geofence.getUpdatedAt());

        // Convert points
        if (geofence.getPoints() != null && !geofence.getPoints().isEmpty()) {
            response.setPoints(geofence.getPoints().stream()
                    .map(point -> {
                        GeofencePointDto dto = new GeofencePointDto();
                        dto.setLatitude(point.getLatitude());
                        dto.setLongitude(point.getLongitude());
                        return dto;
                    })
                    .collect(Collectors.toList()));
        }

        return response;
    }
}```

=== ./src/main/java/com/jjenus/tracker/alerting/application/AlertingEngine.java ===
```.java
package com.jjenus.tracker.alerting.application;

import com.jjenus.tracker.alerting.application.service.AlertRuleEvaluationService;
import com.jjenus.tracker.alerting.domain.IAlertRule;
import com.jjenus.tracker.alerting.domain.AlertDetectedEvent;
import com.jjenus.tracker.alerting.domain.entity.AlertRule;
import com.jjenus.tracker.alerting.infrastructure.cache.VehicleRuleCacheService;
import com.jjenus.tracker.shared.domain.LocationPoint;
import com.jjenus.tracker.shared.exception.ValidationException;
import com.jjenus.tracker.shared.pubsub.EventPublisher;
import com.jjenus.tracker.alerting.exception.AlertException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

import java.util.List;

@Component
public class AlertingEngine {
    private final VehicleRuleCacheService vehicleRuleCacheService;
    private final EventPublisher eventPublisher;
    private final AlertRuleEvaluationService evaluationService;
    private final Logger logger = LoggerFactory.getLogger(AlertingEngine.class);

    public AlertingEngine(
            EventPublisher eventPublisher,
            AlertRuleEvaluationService evaluationService,
            VehicleRuleCacheService vehicleRuleCacheService) {
        this.vehicleRuleCacheService = vehicleRuleCacheService;
        this.eventPublisher = eventPublisher;
        this.evaluationService = evaluationService;
    }

    public void processVehicleUpdate(String vehicleId, LocationPoint newLocation) {
        if (vehicleId == null || newLocation == null) {
            throw new ValidationException(
                    "ALERT_INVALID_INPUT",
                    "Vehicle and location cannot be null"
            );
        }

        // QUICK CHECK 1: Using cached index
        if (!vehicleRuleCacheService.hasRulesCached(vehicleId)) {
            logger.debug("Vehicle {} has no active rules (cached index), skipping", vehicleId);
            return;
        }

        // QUICK CHECK 2: Full cache check
        if (!vehicleRuleCacheService.hasActiveRules(vehicleId)) {
            return;
        }

        // Get pre-sorted rules from Redis cache
        List<AlertRule> vehicleRules = vehicleRuleCacheService.getActiveRulesForVehicle(vehicleId);

        if (vehicleRules.isEmpty()) {
            return;
        }

        logger.debug("Processing {} rules for vehicle {}", vehicleRules.size(), vehicleId);

        for (AlertRule rule : vehicleRules) {
            try {
                IAlertRule domainRule = convertToDomainRule(rule);
                AlertEvent alert = evaluationService.evaluateRule(domainRule, vehicleId, newLocation);

                if (alert != null) {
                    logger.info("Alert triggered: {} for vehicle {}",
                            alert.getRuleKey(), vehicleId);
                    eventPublisher.publish(alert);
                }
            } catch (AlertException e) {
                logger.error("Alert evaluation error for rule {}: {}", rule.getRuleKey(), e.getMessage());
            } catch (Exception e) {
                logger.error("Unexpected error evaluating rule {}: {}", rule.getRuleKey(), e.getMessage());
            }
        }
    }

    private IAlertRule convertToDomainRule(AlertRule entityRule) {
        return new IAlertRule() {
            @Override
            public AlertEvent evaluate(String vehicleId, LocationPoint newLocation) {
                return evaluationService.evaluateRule(this, vehicleId, newLocation);
            }

            @Override
            public String getRuleKey() { return entityRule.getRuleKey(); }

            @Override
            public String getRuleName() { return entityRule.getRuleName(); }

            @Override
            public boolean isEnabled() { return Boolean.TRUE.equals(entityRule.isEnabled()); }

            @Override
            public void setEnabled(boolean enabled) { entityRule.setIsEnabled(enabled); }

            @Override
            public int getPriority() { return entityRule.getPriority() != null ? entityRule.getPriority() : 5; }
        };
    }

    // Cache management methods
    public void invalidateVehicleCache(String vehicleId) {
        vehicleRuleCacheService.invalidateVehicleRules(vehicleId);
    }

    public void invalidateAllCache() {
        vehicleRuleCacheService.invalidateAllVehicleRules();
    }

    public void refreshVehicleRules(String vehicleId) {
        vehicleRuleCacheService.invalidateVehicleRules(vehicleId);
        vehicleRuleCacheService.getActiveRulesForVehicle(vehicleId); // Re-cache
    }
}```

=== ./src/main/java/com/jjenus/tracker/alerting/application/event/AlertEventHandler.java ===
```.java
package com.jjenus.tracker.alerting.application.event;

import com.jjenus.tracker.alerting.application.AlertingEngine;
import com.jjenus.tracker.shared.events.VehicleUpdatedEvent;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.jms.annotation.JmsListener;
import org.springframework.messaging.handler.annotation.Payload;
import org.springframework.stereotype.Component;

@Component
public class AlertEventHandler {
    private static final Logger logger = LoggerFactory.getLogger(AlertEventHandler.class);

    private final AlertingEngine alertingEngine;

    public AlertEventHandler(AlertingEngine alertingEngine) {
        this.alertingEngine = alertingEngine;
    }

    @JmsListener(
            destination = "tracking.events.vehicleupdatedevent",
            containerFactory = "topicJmsListenerContainerFactory"
    )
    public void handleVehicleUpdate(@Payload VehicleUpdatedEvent event) {
        try {
            logger.info("Alert Processing received LOCATION update for device {}", event.getVehicleId());
            logger.debug("Processing vehicle update for {}", event.getEventId());

             alertingEngine.processVehicleUpdate(event.getVehicleId(), event.getNewLocation());
        } catch (Exception e) {
            logger.error("Failed to process vehicle update for {}",
                    event.getEventId(), e);
            throw e;
        }
    }

}```

=== ./src/main/java/com/jjenus/tracker/alerting/application/event/CacheInvalidationEventListener.java ===
```.java
package com.jjenus.tracker.alerting.application.event;

import com.jjenus.tracker.alerting.infrastructure.cache.GeofenceCacheService;
import com.jjenus.tracker.alerting.infrastructure.cache.VehicleRuleCacheService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.context.event.EventListener;
import org.springframework.stereotype.Component;

import java.util.Set;

@Component
public class CacheInvalidationEventListener {

    private static final Logger logger = LoggerFactory.getLogger(CacheInvalidationEventListener.class);

    private final VehicleRuleCacheService vehicleRuleCacheService;
    private final GeofenceCacheService geofenceCacheService;

    public CacheInvalidationEventListener(
            VehicleRuleCacheService vehicleRuleCacheService,
            GeofenceCacheService geofenceCacheService) {
        this.vehicleRuleCacheService = vehicleRuleCacheService;
        this.geofenceCacheService = geofenceCacheService;
    }

    @EventListener
    public void handleGeofenceChange(GeofenceChangedEvent event) {
        logger.debug("Handling geofence change event for: {}", event.getGeofenceId());

        // Invalidate geofence cache
        geofenceCacheService.invalidateGeofence(event.getGeofenceId());

        // Invalidate affected vehicle caches
        if (event.getAffectedVehicleIds() != null) {
            geofenceCacheService.invalidateVehicleGeofenceCaches(event.getAffectedVehicleIds());
            event.getAffectedVehicleIds().forEach(vehicleRuleCacheService::invalidateVehicleRules);
        }
    }

    public static class GeofenceChangedEvent {
        private final Long geofenceId;
        private final Set<String> affectedVehicleIds;

        public GeofenceChangedEvent(Long geofenceId, Set<String> affectedVehicleIds) {
            this.geofenceId = geofenceId;
            this.affectedVehicleIds = affectedVehicleIds;
        }

        public Long getGeofenceId() { return geofenceId; }
        public Set<String> getAffectedVehicleIds() { return affectedVehicleIds; }
    }
}```

=== ./src/main/java/com/jjenus/tracker/alerting/application/service/AlertRuleEvaluationService.java ===
```.java
package com.jjenus.tracker.alerting.application.service;

import com.jjenus.tracker.alerting.domain.IAlertRule;
import com.jjenus.tracker.alerting.domain.AlertDetectedEvent;
import com.jjenus.tracker.shared.domain.LocationPoint;
import org.springframework.stereotype.Service;

@Service
public class AlertRuleEvaluationService {

    public AlertEvent evaluateRule(IAlertRule rule, String vehicleId, LocationPoint location) {
        // Handle null parameters
        if (rule == null || vehicleId == null || location == null) {
            return null;
        }
        return rule.evaluate(vehicleId, location);
    }

    public boolean validateRuleConfiguration(IAlertRule rule) {
        if (rule == null) return false;

        String ruleKey = rule.getRuleKey();
        String ruleName = rule.getRuleName();

        // More comprehensive validation
        if (ruleKey == null || ruleKey.trim().isEmpty()) return false;
        if (ruleName == null || ruleName.trim().isEmpty()) return false;

        // Validate that ruleKey doesn't contain invalid characters
        if (!ruleKey.matches("^[a-zA-Z0-9_]+$")) return false;

        // Validate priority is reasonable
        int priority = rule.getPriority();
        return priority >= 1 && priority <= 100;
    }
}```

=== ./src/main/java/com/jjenus/tracker/alerting/application/service/AlertRuleService.java ===
```.java
package com.jjenus.tracker.alerting.application.service;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.jjenus.tracker.alerting.api.dto.*;
import com.jjenus.tracker.alerting.domain.entity.AlertRule;
import com.jjenus.tracker.alerting.domain.entity.Geofence;
import com.jjenus.tracker.alerting.domain.enums.AlertRuleType;
import com.jjenus.tracker.alerting.exception.AlertException;
import com.jjenus.tracker.alerting.infrastructure.cache.AlertRuleCacheService;
import com.jjenus.tracker.alerting.infrastructure.cache.RedisKeyGenerator;
import com.jjenus.tracker.alerting.infrastructure.cache.VehicleRuleCacheService;
import com.jjenus.tracker.alerting.infrastructure.repository.AlertRuleRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.CollectionUtils;
import org.springframework.util.StringUtils;

import java.time.Instant;
import java.util.*;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;

@Service
@Transactional
public class AlertRuleService {

    private static final Logger logger = LoggerFactory.getLogger(AlertRuleService.class);

    private final AlertRuleRepository ruleRepository;
    private final AlertRuleCacheService ruleCacheService;
    private final VehicleRuleCacheService vehicleRuleCacheService;
    private final GeofenceRuleValidator geofenceRuleValidator;
    private final ObjectMapper objectMapper;
    private final RedisTemplate<String, Object> redisTemplate;
    private final RedisKeyGenerator keyGenerator;

    public AlertRuleService(
            AlertRuleRepository ruleRepository,
            AlertRuleCacheService ruleCacheService,
            VehicleRuleCacheService vehicleRuleCacheService,
            GeofenceRuleValidator geofenceRuleValidator,
            ObjectMapper objectMapper,
            RedisTemplate<String, Object> redisTemplate,
            RedisKeyGenerator keyGenerator) {
        this.ruleRepository = ruleRepository;
        this.ruleCacheService = ruleCacheService;
        this.vehicleRuleCacheService = vehicleRuleCacheService;
        this.geofenceRuleValidator = geofenceRuleValidator;
        this.objectMapper = objectMapper;
        this.redisTemplate = redisTemplate;
        this.keyGenerator = keyGenerator;
    }

    // ========== TEMPLATE METHODS ==========

    @Transactional
    public AlertRuleResponse createOverspeedRule(OverspeedRuleTemplateRequest request) {
        logger.info("Creating overspeed rule: {}", request.getRuleKey());

        validateRuleKeyUniqueness(request.getRuleKey());
        validateOverspeedRuleRequest(request);

        // Build parameters with validation
        Map<String, Object> parameters = buildOverspeedParameters(request);

        // Build actions configuration
        String actionsJson = buildOverspeedActions();

        // Create and save rule
        AlertRule rule = createBaseRule(request, AlertRuleType.SPEED, parameters);
        rule.setActions(actionsJson);
        rule.setVehicleIds(request.getVehicleIds());

        AlertRule saved = saveAndCacheRule(rule);

        logger.info("Overspeed rule created successfully: {} for {} vehicles",
                saved.getRuleKey(), request.getVehicleIds().size());

        return toResponse(saved);
    }

    @Transactional
    public AlertRuleResponse createIdleTimeoutRule(IdleTimeoutRuleTemplateRequest request) {
        logger.info("Creating idle timeout rule: {}", request.getRuleKey());

        validateRuleKeyUniqueness(request.getRuleKey());
        validateIdleTimeoutRuleRequest(request);

        // Build parameters
        Map<String, Object> parameters = buildIdleTimeoutParameters(request);

        // Create and save rule
        AlertRule rule = createBaseRule(request, AlertRuleType.TIME, parameters);
        rule.setVehicleIds(request.getVehicleIds());

        AlertRule saved = saveAndCacheRule(rule);

        logger.info("Idle timeout rule created successfully: {} for {} vehicles",
                saved.getRuleKey(), request.getVehicleIds().size());

        return toResponse(saved);
    }

    @Transactional
    public AlertRuleResponse createGeofenceRule(GeofenceRuleTemplateRequest request) {
        logger.info("Creating geofence rule: {}", request.getRuleKey());

        validateRuleKeyUniqueness(request.getRuleKey());

        // Validate geofence rule request
        geofenceRuleValidator.validateGeofenceRuleRequest(request);

        // Get validated geofence
        Geofence geofence = geofenceRuleValidator.getValidatedGeofence(request.getGeofenceId());

        // Build parameters with geofence details
        Map<String, Object> parameters = buildGeofenceParameters(request, geofence);

        // Validate vehicle associations
        validateVehicleGeofenceAssociation(geofence, request.getVehicleIds());

        // Create and save rule
        AlertRule rule = createBaseRule(request, AlertRuleType.GEOFENCE, parameters);
        rule.setVehicleIds(request.getVehicleIds());

        AlertRule saved = saveAndCacheRule(rule);

        logger.info("Geofence rule created successfully: {} for geofence {} and {} vehicles",
                saved.getRuleKey(), request.getGeofenceId(), request.getVehicleIds().size());

        return toResponse(saved);
    }

    // ========== CRUD METHODS ==========

    @Transactional
    public AlertRuleResponse createRule(CreateAlertRuleRequest request) {
        logger.info("Creating custom alert rule: {}", request.getRuleKey());

        validateRuleKeyUniqueness(request.getRuleKey());

        // Parse and validate rule type
        AlertRuleType ruleType = parseRuleType(request.getRuleType());

        // Parse and validate parameters
        Map<String, Object> parameters = parseAndValidateParameters(request.getParameters(), ruleType);

        // Extract vehicle IDs from parameters
        Set<String> vehicleIds = extractVehicleIdsFromParameters(parameters);

        // Create entity
        AlertRule rule = new AlertRule();
        rule.setRuleKey(request.getRuleKey());
        rule.setRuleName(request.getRuleName());
        rule.setRuleType(ruleType);
        rule.setParameters(parameters);
        rule.setPriority(request.getPriority());
        rule.setIsEnabled(request.isEnabled());
        rule.setVehicleIds(vehicleIds);
        rule.setCooldownMinutes(5); // Default cooldown

        AlertRule saved = saveAndCacheRule(rule);

        logger.info("Custom alert rule created successfully: {}", saved.getRuleKey());

        return toResponse(saved);
    }

    @Transactional(readOnly = true)
    public List<AlertRuleResponse> getAllRules() {
        return ruleRepository.findAll().stream()
                .map(this::toResponse)
                .collect(Collectors.toList());
    }

    @Transactional(readOnly = true)
    public PagedResponse<AlertRuleResponse> getAllRulesPaged(SearchRequest searchRequest) {
        String cacheKey = keyGenerator.getPaginatedRulesKey(
                searchRequest.getPage(),
                searchRequest.getSize(),
                searchRequest.getSortBy(),
                searchRequest.getSortDirection().name(),
                searchRequest.getSearch(),
                searchRequest.getRuleType() != null ? searchRequest.getRuleType().name() : null,
                searchRequest.getEnabled()
        );

        try {
            // Try cache first
            Object cached = redisTemplate.opsForValue().get(cacheKey);
            if (cached != null && cached instanceof PagedResponse) {
                logger.debug("Cache hit for paginated rules");
                return (PagedResponse<AlertRuleResponse>) cached;
            }
        } catch (Exception e) {
            logger.warn("Failed to get paginated rules from cache", e);
        }

        // Cache miss - query database
        Pageable pageable = createPageable(searchRequest);
        Page<AlertRule> page = ruleRepository.searchAlertRules(
                searchRequest.getSearch(),
                searchRequest.getRuleType(),
                searchRequest.getEnabled(),
                pageable);

        PagedResponse<AlertRuleResponse> response = new PagedResponse<>(page.map(this::toResponse));

        // Cache the result
        try {
            redisTemplate.opsForValue().set(cacheKey, response,
                    RedisKeyGenerator.PAGINATION_CACHE_TTL, TimeUnit.SECONDS);
        } catch (Exception e) {
            logger.warn("Failed to cache paginated rules", e);
        }

        return response;
    }

    @Transactional(readOnly = true)
    public List<AlertRuleResponse> getEnabledRules() {
        return ruleRepository.findByIsEnabled(true).stream()
                .map(this::toResponse)
                .collect(Collectors.toList());
    }

    @Transactional(readOnly = true)
    public PagedResponse<AlertRuleResponse> getEnabledRulesPaged(SearchRequest searchRequest) {
        searchRequest.setEnabled(true); // Force enabled=true
        return getAllRulesPaged(searchRequest);
    }

    @Transactional(readOnly = true)
    public AlertRuleResponse getRuleByKey(String ruleKey) {
        // Try cache first
        var cachedRule = ruleCacheService.getRuleByKey(ruleKey);
        if (cachedRule.isPresent()) {
            logger.debug("Cache hit for rule: {}", ruleKey);
            return toResponse(cachedRule.get());
        }

        // Cache miss - load from DB
        AlertRule rule = ruleRepository.findByRuleKey(ruleKey)
                .orElseThrow(() -> AlertException.ruleNotFound(ruleKey));

        // Cache the rule for future requests
        ruleCacheService.cacheRule(rule);

        return toResponse(rule);
    }

    @Transactional
    public AlertRuleResponse updateRule(String ruleKey, UpdateAlertRuleRequest request) {
        logger.info("Updating alert rule: {}", ruleKey);

        AlertRule rule = ruleRepository.findByRuleKey(ruleKey)
                .orElseThrow(() -> AlertException.ruleNotFound(ruleKey));

        boolean hasChanges = false;
        Set<String> oldVehicleIds = new HashSet<>(rule.getVehicleIds());

        // Update fields if provided
        if (StringUtils.hasText(request.getRuleName())) {
            rule.setRuleName(request.getRuleName());
            hasChanges = true;
        }

        if (StringUtils.hasText(request.getRuleKey()) && !request.getRuleKey().equals(ruleKey)) {
            validateRuleKeyUniqueness(request.getRuleKey());
            rule.setRuleKey(request.getRuleKey());
            hasChanges = true;
        }

        if (request.getParameters() != null && !request.getParameters().isEmpty()) {
            // Merge and validate parameters
            Map<String, Object> existingParams = rule.getParameters();
            existingParams.putAll(request.getParameters());

            // Validate parameters based on rule type
            validateRuleParameters(rule.getRuleType(), existingParams);

            rule.setParameters(existingParams);

            // Update vehicle IDs from parameters
            Set<String> newVehicleIds = extractVehicleIdsFromParameters(existingParams);
            rule.setVehicleIds(newVehicleIds);

            hasChanges = true;
        }

        if (request.getPriority() > 0) {
            rule.setPriority(request.getPriority());
            hasChanges = true;
        }

        if (hasChanges) {
            rule.setUpdatedAt(Instant.now());
            AlertRule updated = ruleRepository.save(rule);

            // Update cache
            ruleCacheService.cacheRule(updated);

            // Invalidate vehicle caches if vehicle associations changed
            if (!oldVehicleIds.equals(rule.getVehicleIds())) {
                Set<String> allAffectedVehicles = new HashSet<>(oldVehicleIds);
                allAffectedVehicles.addAll(rule.getVehicleIds());
                allAffectedVehicles.forEach(vehicleRuleCacheService::invalidateVehicleRules);
            }

            // Invalidate pagination cache
            invalidatePaginationCache();

            logger.info("Alert rule updated successfully: {}", ruleKey);
            return toResponse(updated);
        }

        logger.debug("No changes detected for rule: {}", ruleKey);
        return toResponse(rule);
    }

    @Transactional
    public void enableRule(String ruleKey) {
        logger.info("Enabling alert rule: {}", ruleKey);

        AlertRule rule = ruleRepository.findByRuleKey(ruleKey)
                .orElseThrow(() -> AlertException.ruleNotFound(ruleKey));

        if (!Boolean.TRUE.equals(rule.isEnabled())) {
            rule.setIsEnabled(true);
            rule.setUpdatedAt(Instant.now());
            ruleRepository.save(rule);

            // Update cache
            ruleCacheService.cacheRule(rule);

            // Invalidate vehicle caches
            rule.getVehicleIds().forEach(vehicleRuleCacheService::invalidateVehicleRules);

            // Invalidate pagination cache
            invalidatePaginationCache();

            logger.info("Alert rule enabled: {}", ruleKey);
        } else {
            logger.debug("Rule already enabled: {}", ruleKey);
        }
    }

    @Transactional
    public void disableRule(String ruleKey) {
        logger.info("Disabling alert rule: {}", ruleKey);

        AlertRule rule = ruleRepository.findByRuleKey(ruleKey)
                .orElseThrow(() -> AlertException.ruleNotFound(ruleKey));

        if (Boolean.TRUE.equals(rule.isEnabled())) {
            rule.setIsEnabled(false);
            rule.setUpdatedAt(Instant.now());
            ruleRepository.save(rule);

            // Remove from cache
            ruleCacheService.evictRule(ruleKey);

            // Invalidate vehicle caches
            rule.getVehicleIds().forEach(vehicleRuleCacheService::invalidateVehicleRules);

            // Invalidate pagination cache
            invalidatePaginationCache();

            logger.info("Alert rule disabled: {}", ruleKey);
        } else {
            logger.debug("Rule already disabled: {}", ruleKey);
        }
    }

    @Transactional
    public void deleteRule(String ruleKey) {
        logger.info("Deleting alert rule: {}", ruleKey);

        AlertRule rule = ruleRepository.findByRuleKey(ruleKey)
                .orElseThrow(() -> AlertException.ruleNotFound(ruleKey));

        Set<String> affectedVehicles = rule.getVehicleIds();

        ruleRepository.deleteByRuleKey(ruleKey);

        // Remove from cache
        ruleCacheService.evictRule(ruleKey);

        // Invalidate vehicle caches
        affectedVehicles.forEach(vehicleRuleCacheService::invalidateVehicleRules);

        // Invalidate pagination cache
        invalidatePaginationCache();

        logger.info("Alert rule deleted successfully: {}", ruleKey);
    }

    // ========== HELPER METHODS ==========

    private Pageable createPageable(SearchRequest searchRequest) {
        Sort sort = Sort.by(searchRequest.getSortDirection(), searchRequest.getSortBy());
        return PageRequest.of(searchRequest.getPage(), searchRequest.getSize(), sort);
    }

    private void invalidatePaginationCache() {
        try {
            Set<String> keys = redisTemplate.keys(keyGenerator.getPaginatedRulesPattern());
            if (keys != null && !keys.isEmpty()) {
                redisTemplate.delete(keys);
                logger.debug("Invalidated pagination cache for rules");
            }
        } catch (Exception e) {
            logger.warn("Failed to invalidate pagination cache", e);
        }
    }

    private AlertRule saveAndCacheRule(AlertRule rule) {
        // Set timestamps
        Instant now = Instant.now();
        if (rule.getCreatedAt() == null) {
            rule.setCreatedAt(now);
        }
        rule.setUpdatedAt(now);

        // Save to database
        AlertRule saved = ruleRepository.save(rule);

        // Cache the rule
        ruleCacheService.cacheRule(saved);

        // Invalidate affected vehicle caches
        saved.getVehicleIds().forEach(vehicleRuleCacheService::invalidateVehicleRules);

        // Invalidate pagination cache
        invalidatePaginationCache();

        return saved;
    }

    private void validateRuleKeyUniqueness(String ruleKey) {
        if (ruleRepository.existsByRuleKey(ruleKey)) {
            throw AlertException.ruleAlreadyExists(ruleKey);
        }
    }

    private void validateOverspeedRuleRequest(OverspeedRuleTemplateRequest request) {
        if (request.getSpeedLimit() <= 0) {
            throw new IllegalArgumentException("Speed limit must be positive");
        }
        if (request.getBuffer() < 0) {
            throw new IllegalArgumentException("Buffer must be non-negative");
        }
        if (CollectionUtils.isEmpty(request.getVehicleIds())) {
            throw new IllegalArgumentException("At least one vehicle ID is required");
        }
    }

    private void validateIdleTimeoutRuleRequest(IdleTimeoutRuleTemplateRequest request) {
        if (request.getMaxIdleMinutes() <= 0) {
            throw new IllegalArgumentException("Max idle minutes must be positive");
        }
        if (CollectionUtils.isEmpty(request.getVehicleIds())) {
            throw new IllegalArgumentException("At least one vehicle ID is required");
        }
    }

    private Map<String, Object> buildOverspeedParameters(OverspeedRuleTemplateRequest request) {
        Map<String, Object> parameters = new HashMap<>();
        parameters.put("speedLimit", request.getSpeedLimit());
        parameters.put("buffer", request.getBuffer());
        parameters.put("severity", "CRITICAL");
        parameters.put("vehicleIds", new ArrayList<>(request.getVehicleIds()));
        parameters.put("unit", "km/h");
        parameters.put("evaluationInterval", 60); // seconds
        return parameters;
    }

    private Map<String, Object> buildIdleTimeoutParameters(IdleTimeoutRuleTemplateRequest request) {
        Map<String, Object> parameters = new HashMap<>();
        parameters.put("maxIdleMinutes", request.getMaxIdleMinutes());
        parameters.put("severity", "WARNING");
        parameters.put("vehicleIds", new ArrayList<>(request.getVehicleIds()));
        parameters.put("ignoreEngineOff", false);
        parameters.put("notificationThreshold", request.getMaxIdleMinutes() / 2);
        return parameters;
    }

    private Map<String, Object> buildGeofenceParameters(GeofenceRuleTemplateRequest request,
                                                        Geofence geofence) {
        Map<String, Object> parameters = new HashMap<>();
        parameters.put("geofenceId", request.getGeofenceId());
        parameters.put("geofenceName", geofence.getName());
        parameters.put("action", request.getAction().name());
        parameters.put("severity", "WARNING");
        parameters.put("vehicleIds", new ArrayList<>(request.getVehicleIds()));
        parameters.put("shapeType", geofence.getShapeType().name());

        if (geofence.getCenterLatitude() != null) {
            parameters.put("centerLatitude", geofence.getCenterLatitude());
        }
        if (geofence.getCenterLongitude() != null) {
            parameters.put("centerLongitude", geofence.getCenterLongitude());
        }
        if (geofence.getRadiusMeters() != null) {
            parameters.put("radiusMeters", geofence.getRadiusMeters());
        }

        return parameters;
    }

    private String buildOverspeedActions() {
        Map<String, Object> actions = new HashMap<>();
        actions.put("sendNotification", true);
        actions.put("executeCommand", false);
        actions.put("notificationChannels", Arrays.asList("SMS", "EMAIL", "DASHBOARD"));
        actions.put("escalationEnabled", true);
        actions.put("escalationAfterMinutes", 5);

        try {
            return objectMapper.writeValueAsString(actions);
        } catch (JsonProcessingException e) {
            throw new RuntimeException("Failed to serialize actions", e);
        }
    }

    private AlertRule createBaseRule(Object request, AlertRuleType ruleType,
                                     Map<String, Object> parameters) {
        AlertRule rule = new AlertRule();

        if (request instanceof OverspeedRuleTemplateRequest overspeedRequest) {
            rule.setRuleKey(overspeedRequest.getRuleKey());
            rule.setRuleName(overspeedRequest.getRuleName());
            rule.setPriority(overspeedRequest.getPriority());
            rule.setIsEnabled(overspeedRequest.isEnabled());
        } else if (request instanceof IdleTimeoutRuleTemplateRequest idleRequest) {
            rule.setRuleKey(idleRequest.getRuleKey());
            rule.setRuleName(idleRequest.getRuleName());
            rule.setPriority(idleRequest.getPriority());
            rule.setIsEnabled(idleRequest.isEnabled());
        } else if (request instanceof GeofenceRuleTemplateRequest geofenceRequest) {
            rule.setRuleKey(geofenceRequest.getRuleKey());
            rule.setRuleName(geofenceRequest.getRuleName());
            rule.setPriority(geofenceRequest.getPriority());
            rule.setIsEnabled(geofenceRequest.isEnabled());
        }

        rule.setRuleType(ruleType);
        rule.setParameters(parameters);
        rule.setCooldownMinutes(5);
        rule.setCreatedAt(Instant.now());
        rule.setUpdatedAt(Instant.now());

        return rule;
    }

    private AlertRuleType parseRuleType(String ruleTypeStr) {
        try {
            return AlertRuleType.valueOf(ruleTypeStr.toUpperCase());
        } catch (IllegalArgumentException e) {
            throw new IllegalArgumentException("Invalid rule type: " + ruleTypeStr +
                    ". Valid values: " + Arrays.toString(AlertRuleType.values()));
        }
    }

    private Map<String, Object> parseAndValidateParameters(String parametersJson, AlertRuleType ruleType) {
        Map<String, Object> parameters = parseParameters(parametersJson);
        validateRuleParameters(ruleType, parameters);
        return parameters;
    }

    private Map<String, Object> parseParameters(String parametersJson) {
        try {
            if (!StringUtils.hasText(parametersJson)) {
                return new HashMap<>();
            }
            return objectMapper.readValue(parametersJson, new TypeReference<Map<String, Object>>() {});
        } catch (Exception e) {
            throw new IllegalArgumentException("Invalid parameters JSON format: " + e.getMessage(), e);
        }
    }

    private Set<String> extractVehicleIdsFromParameters(Map<String, Object> parameters) {
        Set<String> vehicleIds = new HashSet<>();

        if (parameters != null && parameters.containsKey("vehicleIds")) {
            Object vehicleIdsObj = parameters.get("vehicleIds");
            if (vehicleIdsObj instanceof Collection) {
                ((Collection<?>) vehicleIdsObj).forEach(id -> {
                    if (id != null) {
                        vehicleIds.add(id.toString().trim());
                    }
                });
            } else if (vehicleIdsObj instanceof String) {
                // Handle comma-separated string
                String[] ids = ((String) vehicleIdsObj).split(",");
                for (String id : ids) {
                    if (StringUtils.hasText(id)) {
                        vehicleIds.add(id.trim());
                    }
                }
            }
        }

        return vehicleIds;
    }

    private void validateVehicleGeofenceAssociation(Geofence geofence, Set<String> vehicleIds) {
        for (String vehicleId : vehicleIds) {
            if (!geofence.hasVehicle(vehicleId)) {
                throw new IllegalArgumentException(
                        String.format("Vehicle %s is not associated with geofence %s",
                                vehicleId, geofence.getGeofenceId()));
            }
        }
    }

    private void validateRuleParameters(AlertRuleType ruleType, Map<String, Object> parameters) {
        if (parameters == null) {
            throw new IllegalArgumentException("Parameters cannot be null");
        }

        switch (ruleType) {
            case SPEED:
                validateSpeedRuleParameters(parameters);
                break;
            case TIME:
                validateTimeRuleParameters(parameters);
                break;
            case GEOFENCE:
                validateGeofenceRuleParameters(parameters);
                break;
            default:
                // Basic validation for custom rule types
                if (!parameters.containsKey("vehicleIds") ||
                        ((Collection<?>) parameters.get("vehicleIds")).isEmpty()) {
                    throw new IllegalArgumentException("Custom rules require at least one vehicle ID");
                }
                break;
        }
    }

    private void validateSpeedRuleParameters(Map<String, Object> parameters) {
        if (!parameters.containsKey("speedLimit")) {
            throw new IllegalArgumentException("Speed rule requires 'speedLimit' parameter");
        }
        Object speedLimit = parameters.get("speedLimit");
        if (!(speedLimit instanceof Number)) {
            throw new IllegalArgumentException("'speedLimit' must be a number");
        }
        if (((Number) speedLimit).floatValue() <= 0) {
            throw new IllegalArgumentException("'speedLimit' must be positive");
        }

        // Optional buffer validation
        if (parameters.containsKey("buffer")) {
            Object buffer = parameters.get("buffer");
            if (!(buffer instanceof Number)) {
                throw new IllegalArgumentException("'buffer' must be a number");
            }
            if (((Number) buffer).floatValue() < 0) {
                throw new IllegalArgumentException("'buffer' cannot be negative");
            }
        }
    }

    private void validateTimeRuleParameters(Map<String, Object> parameters) {
        if (!parameters.containsKey("maxIdleMinutes")) {
            throw new IllegalArgumentException("Time rule requires 'maxIdleMinutes' parameter");
        }
        Object idleMinutes = parameters.get("maxIdleMinutes");
        if (!(idleMinutes instanceof Number)) {
            throw new IllegalArgumentException("'maxIdleMinutes' must be a number");
        }
        if (((Number) idleMinutes).intValue() <= 0) {
            throw new IllegalArgumentException("'maxIdleMinutes' must be positive");
        }
    }

    private void validateGeofenceRuleParameters(Map<String, Object> parameters) {
        if (!parameters.containsKey("geofenceId")) {
            throw new IllegalArgumentException("Geofence rule requires 'geofenceId' parameter");
        }

        String geofenceId = parameters.get("geofenceId").toString();
        if (!StringUtils.hasText(geofenceId)) {
            throw new IllegalArgumentException("Geofence ID cannot be empty");
        }

        // Validate geofence exists and is active
        geofenceRuleValidator.getValidatedGeofence(geofenceId);
    }

    // ========== RESPONSE CONVERSION ==========

    public AlertRuleResponse toResponse(AlertRule rule) {
        AlertRuleResponse response = new AlertRuleResponse();
        response.setRuleKey(rule.getRuleKey());
        response.setRuleName(rule.getRuleName());
        response.setRuleType(rule.getRuleType());
        response.setParameters(rule.getParameters());
        response.setPriority(rule.getPriority() != null ? rule.getPriority() : 5);
        response.setEnabled(Boolean.TRUE.equals(rule.isEnabled()));
        response.setCreatedAt(rule.getCreatedAt());
        response.setUpdatedAt(rule.getUpdatedAt());
        return response;
    }

    // ========== BATCH OPERATIONS ==========

    @Transactional
    public List<AlertRuleResponse> batchCreateRules(List<CreateAlertRuleRequest> requests) {
        logger.info("Batch creating {} alert rules", requests.size());

        List<AlertRuleResponse> responses = new ArrayList<>();

        for (CreateAlertRuleRequest request : requests) {
            try {
                AlertRuleResponse response = createRule(request);
                responses.add(response);
            } catch (Exception e) {
                logger.error("Failed to create rule {} in batch: {}",
                        request.getRuleKey(), e.getMessage());
                // Continue with other rules
            }
        }

        logger.info("Batch creation completed: {} successful, {} total",
                responses.size(), requests.size());

        return responses;
    }

    @Transactional
    public void batchEnableRules(Set<String> ruleKeys) {
        logger.info("Batch enabling {} alert rules", ruleKeys.size());

        int enabledCount = 0;
        for (String ruleKey : ruleKeys) {
            try {
                enableRule(ruleKey);
                enabledCount++;
            } catch (Exception e) {
                logger.error("Failed to enable rule {} in batch: {}", ruleKey, e.getMessage());
            }
        }

        logger.info("Batch enabling completed: {} enabled, {} total",
                enabledCount, ruleKeys.size());
    }

    @Transactional(readOnly = true)
    public Map<String, List<AlertRuleResponse>> getRulesByVehicleIds(Set<String> vehicleIds) {
        Map<String, List<AlertRuleResponse>> result = new HashMap<>();

        for (String vehicleId : vehicleIds) {
            List<AlertRule> vehicleRules = ruleRepository.findActiveRulesForVehicle(vehicleId);
            result.put(vehicleId, vehicleRules.stream()
                    .map(this::toResponse)
                    .collect(Collectors.toList()));
        }

        return result;
    }
}```

=== ./src/main/java/com/jjenus/tracker/alerting/application/service/GeofenceRuleValidator.java ===
```.java
package com.jjenus.tracker.alerting.application.service;

import com.jjenus.tracker.alerting.api.dto.GeofenceRuleTemplateRequest;
import com.jjenus.tracker.alerting.domain.entity.Geofence;
import com.jjenus.tracker.alerting.exception.AlertException;
import org.springframework.stereotype.Component;

@Component
public class GeofenceRuleValidator {

    private final GeofenceService geofenceService;

    public GeofenceRuleValidator(GeofenceService geofenceService) {
        this.geofenceService = geofenceService;
    }

    public void validateGeofenceRuleRequest(GeofenceRuleTemplateRequest request) {
        // Validate geofence exists and is active
        try {
            Long geofenceId = Long.parseLong(request.getGeofenceId());
            if (!geofenceService.existsAndActive(geofenceId)) {
                throw AlertException.geofenceNotFound(request.getGeofenceId());
            }
        } catch (NumberFormatException e) {
            throw new IllegalArgumentException("Invalid geofence ID format");
        }

        // Validate vehicle IDs are not empty
        if (request.getVehicleIds() == null || request.getVehicleIds().isEmpty()) {
            throw new IllegalArgumentException("At least one vehicle ID is required");
        }
    }

    public Geofence getValidatedGeofence(String geofenceId) {
        try {
            Long id = Long.parseLong(geofenceId);
            Geofence geofence = geofenceService.getGeofenceById(id);

            if (geofence == null) {
                throw AlertException.geofenceNotFound(geofenceId);
            }

            if (!Boolean.TRUE.equals(geofence.getIsActive())) {
                throw new IllegalStateException("Geofence is not active: " + geofenceId);
            }

            return geofence;

        } catch (NumberFormatException e) {
            throw new IllegalArgumentException("Invalid geofence ID format: " + geofenceId);
        }
    }
}```

=== ./src/main/java/com/jjenus/tracker/alerting/application/service/GeofenceService.java ===
```.java
package com.jjenus.tracker.alerting.application.service;


import com.jjenus.tracker.alerting.api.dto.GeofencePointDto;
import com.jjenus.tracker.alerting.api.dto.GeofenceResponse;
import com.jjenus.tracker.alerting.api.dto.PagedResponse;
import com.jjenus.tracker.alerting.api.dto.SearchRequest;
import com.jjenus.tracker.alerting.domain.entity.Geofence;
import com.jjenus.tracker.alerting.domain.entity.GeofencePoint;
import com.jjenus.tracker.alerting.infrastructure.cache.GeofenceCacheService;
import com.jjenus.tracker.alerting.infrastructure.cache.RedisKeyGenerator;
import com.jjenus.tracker.alerting.infrastructure.repository.GeofenceRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.Objects;
import java.util.Set;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;

@Service
public class GeofenceService {

    private static final Logger logger = LoggerFactory.getLogger(GeofenceService.class);

    private final GeofenceRepository geofenceRepository;
    private final GeofenceCacheService geofenceCacheService;
    private final RedisTemplate<String, Object> redisTemplate;
    private final RedisKeyGenerator keyGenerator;

    public GeofenceService(
            GeofenceRepository geofenceRepository,
            GeofenceCacheService geofenceCacheService,
            RedisTemplate<String, Object> redisTemplate,
            RedisKeyGenerator keyGenerator) {
        this.geofenceRepository = geofenceRepository;
        this.geofenceCacheService = geofenceCacheService;
        this.redisTemplate = redisTemplate;
        this.keyGenerator = keyGenerator;
    }

    @Transactional
    public Geofence createGeofence(Geofence geofence) {
        Geofence saved = geofenceRepository.save(geofence);

        // Cache the geofence
        geofenceCacheService.cacheGeofence(saved);

        // Invalidate pagination cache
        invalidatePaginationCache();

        logger.info("Created geofence: {} for {} vehicles",
                saved.getName(), saved.getVehicleIds().size());
        return saved;
    }

    @Transactional(readOnly = true)
    public List<Geofence> getVehicleGeofences(String vehicleId) {
        // Try cache first
        List<Geofence> cached = geofenceCacheService.getVehicleGeofences(vehicleId);
        if (cached != null) {
            logger.debug("Cache hit for vehicle geofences: {}", vehicleId);
            return cached;
        }

        // Cache miss - load from DB
        List<Geofence> geofences = geofenceRepository.findByVehicleId(vehicleId);

        // Cache the result
        geofenceCacheService.cacheVehicleGeofences(vehicleId, geofences);

        return geofences;
    }

    @Transactional(readOnly = true)
    public PagedResponse<GeofenceResponse> getVehicleGeofencesPaged(String vehicleId, SearchRequest searchRequest) {
        String cacheKey = keyGenerator.getPaginatedGeofencesKey(
                searchRequest.getPage(),
                searchRequest.getSize(),
                searchRequest.getSortBy(),
                searchRequest.getSortDirection().name(),
                searchRequest.getSearch(),
                vehicleId,
                null // Don't filter by active status
        );

        try {
            // Try cache first
            Object cached = redisTemplate.opsForValue().get(cacheKey);
            if (cached != null && cached instanceof PagedResponse) {
                logger.debug("Cache hit for paginated vehicle geofences");
                return (PagedResponse<GeofenceResponse>) cached;
            }
        } catch (Exception e) {
            logger.warn("Failed to get paginated vehicle geofences from cache", e);
        }

        // Cache miss - query database
        Pageable pageable = createPageable(searchRequest);
        Page<Geofence> page = geofenceRepository.findByVehicleId(vehicleId, pageable);

        PagedResponse<GeofenceResponse> response = new PagedResponse<>(page.map(this::toResponse));

        // Cache the result
        try {
            redisTemplate.opsForValue().set(cacheKey, response,
                    RedisKeyGenerator.PAGINATION_CACHE_TTL, TimeUnit.SECONDS);
        } catch (Exception e) {
            logger.warn("Failed to cache paginated vehicle geofences", e);
        }

        return response;
    }

    @Transactional(readOnly = true)
    public List<Geofence> getActiveGeofences(String vehicleId) {
        return geofenceRepository.findByVehicleIdAndIsActive(vehicleId);
    }

    @Transactional(readOnly = true)
    public PagedResponse<GeofenceResponse> getActiveGeofencesPaged(String vehicleId, SearchRequest searchRequest) {
        String cacheKey = keyGenerator.getPaginatedGeofencesKey(
                searchRequest.getPage(),
                searchRequest.getSize(),
                searchRequest.getSortBy(),
                searchRequest.getSortDirection().name(),
                searchRequest.getSearch(),
                vehicleId,
                true // Filter by active=true
        );

        try {
            // Try cache first
            Object cached = redisTemplate.opsForValue().get(cacheKey);
            if (cached != null && cached instanceof PagedResponse) {
                logger.debug("Cache hit for paginated active vehicle geofences");
                return (PagedResponse<GeofenceResponse>) cached;
            }
        } catch (Exception e) {
            logger.warn("Failed to get paginated active vehicle geofences from cache", e);
        }

        // Cache miss - query database
        Pageable pageable = createPageable(searchRequest);
        Page<Geofence> page = geofenceRepository.findByVehicleIdAndIsActive(vehicleId, pageable);

        PagedResponse<GeofenceResponse> response = new PagedResponse<>(page.map(this::toResponse));

        // Cache the result
        try {
            redisTemplate.opsForValue().set(cacheKey, response,
                    RedisKeyGenerator.PAGINATION_CACHE_TTL, TimeUnit.SECONDS);
        } catch (Exception e) {
            logger.warn("Failed to cache paginated active vehicle geofences", e);
        }

        return response;
    }

    @Transactional(readOnly = true)
    public PagedResponse<GeofenceResponse> searchGeofences(SearchRequest searchRequest) {
        String cacheKey = keyGenerator.getPaginatedGeofencesKey(
                searchRequest.getPage(),
                searchRequest.getSize(),
                searchRequest.getSortBy(),
                searchRequest.getSortDirection().name(),
                searchRequest.getSearch(),
                searchRequest.getVehicleId(),
                searchRequest.getActive()
        );

        try {
            // Try cache first
            Object cached = redisTemplate.opsForValue().get(cacheKey);
            if (cached != null && cached instanceof PagedResponse) {
                logger.debug("Cache hit for search geofences");
                return (PagedResponse<GeofenceResponse>) cached;
            }
        } catch (Exception e) {
            logger.warn("Failed to get search geofences from cache", e);
        }

        // Cache miss - query database
        Pageable pageable = createPageable(searchRequest);
        Page<Geofence> page = geofenceRepository.searchGeofences(
                searchRequest.getVehicleId(),
                searchRequest.getSearch(),
                searchRequest.getActive(),
                pageable);

        PagedResponse<GeofenceResponse> response = new PagedResponse<>(page.map(this::toResponse));

        // Cache the result
        try {
            redisTemplate.opsForValue().set(cacheKey, response,
                    RedisKeyGenerator.PAGINATION_CACHE_TTL, TimeUnit.SECONDS);
        } catch (Exception e) {
            logger.warn("Failed to cache search geofences", e);
        }

        return response;
    }

    @Transactional(readOnly = true)
    public Geofence getGeofenceById(Long geofenceId) {
        // Try cache first
        return geofenceCacheService.getGeofenceById(geofenceId)
                .orElseGet(() -> {
                    // Cache miss - load from DB
                    Geofence geofence = geofenceRepository.findById(geofenceId)
                            .orElseThrow(() -> new IllegalArgumentException("Geofence not found"));

                    // Cache for future requests
                    geofenceCacheService.cacheGeofence(geofence);

                    return geofence;
                });
    }

    @Transactional
    public Geofence updateGeofence(Long geofenceId, Geofence updates) {
        Geofence geofence = geofenceRepository.findById(geofenceId)
                .orElseThrow(() -> new IllegalArgumentException("Geofence not found"));

        // Track affected vehicles for cache invalidation
        Set<String> oldVehicleIds = geofence.getVehicleIds();
        Set<String> newVehicleIds = updates.getVehicleIds() != null ?
                updates.getVehicleIds() : oldVehicleIds;

        // Update fields
        if (updates.getName() != null) geofence.setName(updates.getName());
        if (updates.getDescription() != null) geofence.setDescription(updates.getDescription());
        if (updates.getIsActive() != null) geofence.setIsActive(updates.getIsActive());
        if (updates.getShapeType() != null) geofence.setShapeType(updates.getShapeType());

        // Update geometry if changed
        if (updates.getCenterLatitude() != null) {
            geofence.setCenterLatitude(updates.getCenterLatitude());
        }

        if (updates.getCenterLongitude() != null) {
            geofence.setCenterLongitude(updates.getCenterLongitude());
        }

        if (updates.getRadiusMeters() != null) {
            geofence.setRadiusMeters(updates.getRadiusMeters());
        }

        // Update vehicle associations
        if (updates.getVehicleIds() != null) {
            geofence.setVehicleIds(updates.getVehicleIds());
        }

        Geofence updated = geofenceRepository.save(geofence);

        // Update cache
        geofenceCacheService.cacheGeofence(updated);

        // Invalidate caches for all affected vehicles
        Set<String> allAffected = oldVehicleIds;
        allAffected.addAll(newVehicleIds);
        geofenceCacheService.invalidateVehicleGeofenceCaches(allAffected);

        // Invalidate pagination cache
        invalidatePaginationCache();

        logger.info("Updated geofence: {} affecting {} vehicles",
                geofenceId, allAffected.size());
        return updated;
    }

    @Transactional
    public void deleteGeofence(Long geofenceId) {
        Geofence geofence = geofenceRepository.findById(geofenceId)
                .orElseThrow(() -> new IllegalArgumentException("Geofence not found"));

        Set<String> affectedVehicles = geofence.getVehicleIds();
        geofenceRepository.deleteById(geofenceId);

        // Invalidate caches
        geofenceCacheService.invalidateGeofence(geofenceId);
        geofenceCacheService.invalidateVehicleGeofenceCaches(affectedVehicles);

        // Invalidate pagination cache
        invalidatePaginationCache();

        logger.info("Deleted geofence: {} affecting {} vehicles",
                geofenceId, affectedVehicles.size());
    }

    @Transactional(readOnly = true)
    public List<Geofence> findNearbyGeofencesForVehicle(String vehicleId,
                                                        Double latitude,
                                                        Double longitude) {
        return geofenceRepository.findNearbyGeofencesForVehicle(vehicleId, latitude, longitude);
    }

    public void checkGeofenceViolations(String vehicleId, Double latitude, Double longitude) {
        List<Geofence> nearbyGeofences = findNearbyGeofencesForVehicle(vehicleId, latitude, longitude);

        for (Geofence geofence : nearbyGeofences) {
            boolean isInside = geofence.isPointInside(latitude, longitude);
            logger.debug("Vehicle {} is {} geofence {} at [{}, {}]",
                    vehicleId,
                    isInside ? "inside" : "outside",
                    geofence.getName(),
                    latitude, longitude);
        }
    }

    @Transactional(readOnly = true)
    public boolean existsAndActive(Long geofenceId) {
        return geofenceRepository.findById(geofenceId)
                .map(g -> Boolean.TRUE.equals(g.getIsActive()))
                .orElse(false);
    }

    // ========== HELPER METHODS ==========

    private Pageable createPageable(SearchRequest searchRequest) {
        Sort sort = Sort.by(searchRequest.getSortDirection(), searchRequest.getSortBy());
        return PageRequest.of(searchRequest.getPage(), searchRequest.getSize(), sort);
    }

    private void invalidatePaginationCache() {
        try {
            Set<String> keys = redisTemplate.keys(keyGenerator.getPaginatedGeofencesPattern());
            if (keys != null && !keys.isEmpty()) {
                redisTemplate.delete(keys);
                logger.debug("Invalidated pagination cache for geofences");
            }
        } catch (Exception e) {
            logger.warn("Failed to invalidate pagination cache", e);
        }
    }

    private GeofenceResponse toResponse(Geofence geofence) {
        GeofenceResponse response = new GeofenceResponse();
        response.setGeofenceId(geofence.getGeofenceId());
        response.setVehicleId(geofence.getVehicleIds().stream().findFirst().orElse(null));
        response.setName(geofence.getName());
        response.setDescription(geofence.getDescription());
        response.setShapeType(geofence.getShapeType());
        response.setCenterLatitude(geofence.getCenterLatitude());
        response.setCenterLongitude(geofence.getCenterLongitude());
        response.setRadiusMeters(geofence.getRadiusMeters());
        response.setActive(Boolean.TRUE.equals(geofence.getIsActive()));
        response.setCreatedAt(geofence.getCreatedAt());
        response.setUpdatedAt(geofence.getUpdatedAt());

        // Convert points
        if (geofence.getPoints() != null && !geofence.getPoints().isEmpty()) {
            response.setPoints(geofence.getPoints().stream()
                    .map(point -> {
                        GeofencePointDto dto =
                                new GeofencePointDto();
                        dto.setLatitude(point.getLatitude());
                        dto.setLongitude(point.getLongitude());
                        return dto;
                    })
                    .collect(Collectors.toList()));
        }

        return response;
    }
}```

=== ./src/main/java/com/jjenus/tracker/alerting/domain/AlertEvent.java ===
```.java
package com.jjenus.tracker.alerting.domain;

import com.jjenus.tracker.alerting.domain.enums.AlertSeverity;
import com.jjenus.tracker.shared.domain.LocationPoint;
import com.jjenus.tracker.shared.pubsub.DomainEvent;
import java.time.Instant;

public class AlertEvent extends DomainEvent {
    private final String ruleKey;
    private final String vehicleId;
    private final String message;
    private final AlertSeverity severity;
    private final Instant alertTimestamp;
    private final LocationPoint location;
    
    public AlertEvent(String ruleKey, String vehicleId, String message,
                      AlertSeverity severity, LocationPoint location) {
        this.ruleKey = ruleKey;
        this.vehicleId = vehicleId;
        this.message = message;
        this.severity = severity;
        this.alertTimestamp = Instant.now();
        this.location = location;
    }
    
    public String getRuleKey() { return ruleKey; }
    public String getVehicleId() { return vehicleId; }
    public String getMessage() { return message; }
    public AlertSeverity getSeverity() { return severity; }
    public Instant getAlertTimestamp() { return alertTimestamp; }
    public LocationPoint getLocation() { return location; }
}
```

=== ./src/main/java/com/jjenus/tracker/alerting/domain/entity/AlertRule.java ===
```.java
package com.jjenus.tracker.alerting.domain.entity;

import com.jjenus.tracker.alerting.domain.enums.AlertRuleType;
import jakarta.persistence.*;
import org.hibernate.annotations.JdbcTypeCode;
import org.hibernate.type.SqlTypes;

import java.time.Instant;
import java.util.*;

@Entity
@Table(name = "alert_rules")
public class AlertRule {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "rule_id")
    private Long ruleId;

    @Column(name = "rule_key", length = 100, unique = true, nullable = false)
    private String ruleKey;

    @Column(name = "rule_name", length = 200, nullable = false)
    private String ruleName;

    @Enumerated(EnumType.STRING)
    @Column(name = "rule_type", length = 50, nullable = false)
    private AlertRuleType ruleType;

    @Column(name = "is_enabled")
    private Boolean isEnabled = true;

    @Column(name = "priority")
    private Integer priority = 5;

    @Column(name = "parameters", columnDefinition = "JSONB", nullable = false)
    @JdbcTypeCode(SqlTypes.JSON)
    private Map<String, Object> parameters = new HashMap<>();

    @ElementCollection
    @CollectionTable(
            name = "alert_rule_vehicles",
            joinColumns = @JoinColumn(name = "rule_id")
    )
    @Column(name = "vehicle_id")
    private Set<String> vehicleIds = new HashSet<>();

    @Column(name = "conditions", columnDefinition = "JSONB")
    private String conditions;

    @Column(name = "actions", columnDefinition = "JSONB")
    private String actions;

    @Column(name = "notification_channels", columnDefinition = "JSONB")
    private String notificationChannels;

    @Column(name = "cooldown_minutes")
    private Integer cooldownMinutes = 5;

    @Column(name = "created_by", length = 100)
    private String createdBy;

    @Column(name = "created_at")
    private Instant createdAt = Instant.now();

    @Column(name = "updated_at")
    private Instant updatedAt = Instant.now();

    @PreUpdate
    protected void onUpdate() {
        this.updatedAt = Instant.now();
    }

    // Business methods
    public boolean isInCooldown(Instant lastTriggered) {
        if (cooldownMinutes == null || cooldownMinutes == 0) return false;
        if (lastTriggered == null) return false;

        return Instant.now().isBefore(
                lastTriggered.plusSeconds(cooldownMinutes * 60L)
        );
    }

    public boolean appliesToVehicle(String vehicleId) {
        return vehicleIds != null && vehicleIds.contains(vehicleId);
    }

    // Getters and Setters
    public Long getRuleId() { return ruleId; }
    public void setRuleId(Long ruleId) { this.ruleId = ruleId; }

    public String getRuleKey() { return ruleKey; }
    public void setRuleKey(String ruleKey) { this.ruleKey = ruleKey; }

    public String getRuleName() { return ruleName; }
    public void setRuleName(String ruleName) { this.ruleName = ruleName; }

    public AlertRuleType getRuleType() { return ruleType; }
    public void setRuleType(AlertRuleType ruleType) { this.ruleType = ruleType; }

    public Boolean isEnabled() { return isEnabled; }
    public void setIsEnabled(Boolean isEnabled) { this.isEnabled = isEnabled; }

    public Integer getPriority() { return priority; }
    public void setPriority(Integer priority) { this.priority = priority; }

    public Map<String, Object> getParameters() { return parameters; }
    public void setParameters(Map<String, Object> parameters) { this.parameters = parameters; }

    public Set<String> getVehicleIds() { return vehicleIds; }
    public void setVehicleIds(Set<String> vehicleIds) { this.vehicleIds = vehicleIds; }

    public Instant getCreatedAt() { return createdAt; }
    public void setCreatedAt(Instant createdAt) { this.createdAt = createdAt; }

    public Instant getUpdatedAt() { return updatedAt; }
    public void setUpdatedAt(Instant updatedAt) { this.updatedAt = updatedAt; }

    public String getConditions() { return conditions; }
    public void setConditions(String conditions) { this.conditions = conditions; }

    public String getActions() { return actions; }
    public void setActions(String actions) { this.actions = actions; }

    public String getNotificationChannels() { return notificationChannels; }
    public void setNotificationChannels(String notificationChannels) {
        this.notificationChannels = notificationChannels;
    }

    public Integer getCooldownMinutes() { return cooldownMinutes; }
    public void setCooldownMinutes(Integer cooldownMinutes) { this.cooldownMinutes = cooldownMinutes; }

    public String getCreatedBy() { return createdBy; }
    public void setCreatedBy(String createdBy) { this.createdBy = createdBy; }
}```

=== ./src/main/java/com/jjenus/tracker/alerting/domain/entity/Geofence.java ===
```.java
package com.jjenus.tracker.alerting.domain.entity;

import com.jjenus.tracker.alerting.domain.enums.GeofenceShapeType;
import jakarta.persistence.*;
import java.time.Instant;
import java.util.*;

@Entity
@Table(name = "geofences")
public class Geofence {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "geofence_id")
    private Long geofenceId;

    @Column(name = "name", length = 100, nullable = false)
    private String name;

    @Column(name = "description", length = 500)
    private String description;

    @Enumerated(EnumType.STRING)
    @Column(name = "shape_type", length = 20)
    private GeofenceShapeType shapeType;

    @Column(name = "center_latitude")
    private Double centerLatitude;

    @Column(name = "center_longitude")
    private Double centerLongitude;

    @Column(name = "radius_meters")
    private Integer radiusMeters;

    @Column(name = "is_active")
    private Boolean isActive = true;

    // Many-to-many with vehicles (through vehicle IDs)
    @ElementCollection
    @CollectionTable(
            name = "geofence_vehicles",
            joinColumns = @JoinColumn(name = "geofence_id"),
            indexes = @Index(name = "idx_geofence_vehicles_vehicle_id", columnList = "vehicle_id")
    )
    @Column(name = "vehicle_id", length = 50)
    private Set<String> vehicleIds = new HashSet<>();

    @OneToMany(mappedBy = "geofence", cascade = CascadeType.ALL, orphanRemoval = true)
    @OrderBy("pointOrder ASC")
    private List<GeofencePoint> points = new ArrayList<>();

    @Column(name = "created_by", length = 100)
    private String createdBy;

    @Column(name = "created_at")
    private Instant createdAt = Instant.now();

    @Column(name = "updated_at")
    private Instant updatedAt = Instant.now();

    @PreUpdate
    protected void onUpdate() {
        this.updatedAt = Instant.now();
    }

    // Business methods
    public void addPoint(Double latitude, Double longitude, Integer order) {
        GeofencePoint point = new GeofencePoint();
        point.setGeofence(this);
        point.setLatitude(latitude);
        point.setLongitude(longitude);
        point.setPointOrder(order);
        points.add(point);
    }

    public boolean isPointInside(Double latitude, Double longitude) {
        if (shapeType == GeofenceShapeType.CIRCLE) {
            return isPointInCircle(latitude, longitude);
        } else if (shapeType == GeofenceShapeType.POLYGON) {
            return isPointInPolygon(latitude, longitude);
        }
        return false;
    }

    private boolean isPointInCircle(Double latitude, Double longitude) {
        if (centerLatitude == null || centerLongitude == null || radiusMeters == null) {
            return false;
        }

        double distance = calculateDistance(centerLatitude, centerLongitude, latitude, longitude);
        return distance <= radiusMeters;
    }

    private boolean isPointInPolygon(Double latitude, Double longitude) {
        if (points.size() < 3) {
            return false;
        }

        // Implement ray casting algorithm for polygon
        boolean inside = false;
        for (int i = 0, j = points.size() - 1; i < points.size(); j = i++) {
            Double xi = points.get(i).getLatitude();
            Double yi = points.get(i).getLongitude();
            Double xj = points.get(j).getLatitude();
            Double yj = points.get(j).getLongitude();

            boolean intersect = ((yi > longitude) != (yj > longitude))
                    && (latitude < (xj - xi) * (longitude - yi) / (yj - yi) + xi);
            if (intersect) inside = !inside;
        }
        return inside;
    }

    private double calculateDistance(Double lat1, Double lon1, Double lat2, Double lon2) {
        // Simplified distance calculation
        return Math.sqrt(Math.pow(lat2 - lat1, 2) + Math.pow(lon2 - lon1, 2)) * 111000; // Approx meters
    }

    // Vehicle management methods
    public void addVehicle(String vehicleId) {
        if (vehicleIds == null) {
            vehicleIds = new HashSet<>();
        }
        vehicleIds.add(vehicleId);
    }

    public void removeVehicle(String vehicleId) {
        if (vehicleIds != null) {
            vehicleIds.remove(vehicleId);
        }
    }

    public boolean hasVehicle(String vehicleId) {
        return vehicleIds != null && vehicleIds.contains(vehicleId);
    }

    // Getters and Setters
    public Long getGeofenceId() { return geofenceId; }
    public void setGeofenceId(Long geofenceId) { this.geofenceId = geofenceId; }

    public String getName() { return name; }
    public void setName(String name) { this.name = name; }

    public String getDescription() { return description; }
    public void setDescription(String description) { this.description = description; }

    public GeofenceShapeType getShapeType() { return shapeType; }
    public void setShapeType(GeofenceShapeType shapeType) { this.shapeType = shapeType; }

    public Boolean getIsActive() { return isActive; }
    public void setIsActive(Boolean isActive) { this.isActive = isActive; }

    public Set<String> getVehicleIds() { return vehicleIds; }
    public void setVehicleIds(Set<String> vehicleIds) { this.vehicleIds = vehicleIds; }

    public List<GeofencePoint> getPoints() { return points; }
    public void setPoints(List<GeofencePoint> points) { this.points = points; }

    public Instant getCreatedAt() { return createdAt; }
    public void setCreatedAt(Instant createdAt) { this.createdAt = createdAt; }

    public Instant getUpdatedAt() { return updatedAt; }
    public void setUpdatedAt(Instant updatedAt) { this.updatedAt = updatedAt; }

    // Additional getters/setters
    public Double getCenterLatitude() { return centerLatitude; }
    public void setCenterLatitude(Double centerLatitude) { this.centerLatitude = centerLatitude; }

    public Double getCenterLongitude() { return centerLongitude; }
    public void setCenterLongitude(Double centerLongitude) { this.centerLongitude = centerLongitude; }

    public Integer getRadiusMeters() { return radiusMeters; }
    public void setRadiusMeters(Integer radiusMeters) { this.radiusMeters = radiusMeters; }

    public String getCreatedBy() { return createdBy; }
    public void setCreatedBy(String createdBy) { this.createdBy = createdBy; }
}```

=== ./src/main/java/com/jjenus/tracker/alerting/domain/entity/GeofencePoint.java ===
```.java
package com.jjenus.tracker.alerting.domain.entity;

import jakarta.persistence.*;
import java.time.Instant;

@Entity
@Table(name = "geofence_points")
public class GeofencePoint {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "point_id")
    private Long pointId;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "geofence_id", nullable = false)
    private Geofence geofence;
    
    @Column(name = "point_order", nullable = false)
    private Integer pointOrder;
    
    @Column(name = "latitude", nullable = false)
    private Double latitude;
    
    @Column(name = "longitude", nullable = false)
    private Double longitude;
    
    @Column(name = "created_at")
    private Instant createdAt = Instant.now();
    
    // Getters and Setters
    public Long getPointId() { return pointId; }
    public void setPointId(Long pointId) { this.pointId = pointId; }
    
    public Geofence getGeofence() { return geofence; }
    public void setGeofence(Geofence geofence) { this.geofence = geofence; }
    
    public Integer getPointOrder() { return pointOrder; }
    public void setPointOrder(Integer pointOrder) { this.pointOrder = pointOrder; }
    
    public Double getLatitude() { return latitude; }
    public void setLatitude(Double latitude) { this.latitude = latitude; }
    
    public Double getLongitude() { return longitude; }
    public void setLongitude(Double longitude) { this.longitude = longitude; }
    
    public Instant getCreatedAt() { return createdAt; }
    public void setCreatedAt(Instant createdAt) { this.createdAt = createdAt; }
}```

=== ./src/main/java/com/jjenus/tracker/alerting/domain/entity/TrackerAlert.java ===
```.java
package com.jjenus.tracker.alerting.domain.entity;

import com.jjenus.tracker.alerting.domain.enums.AlertSeverity;
import jakarta.persistence.*;
import org.hibernate.annotations.JdbcTypeCode;
import org.hibernate.type.SqlTypes;

import java.time.Instant;
import java.util.HashMap;
import java.util.Map;

@Entity
@Table(name = "tracker_alerts")
public class TrackerAlert {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "alert_id")
    private Long alertId;
    
    @Column(name = "trackerId_id")
    private String trackerId;
    
    @Column(name = "vehicle_id")
    private String vehicleId;
    
    @Column(name = "alert_type", length = 50, nullable = false)
    private String alertType;
    
    @Enumerated(EnumType.STRING)
    @Column(name = "severity", length = 20)
    private AlertSeverity severity;
    
    @Column(name = "message", columnDefinition = "TEXT")
    private String message;
    
    @JoinColumn(name = "location_id")
    private String locationId;
    
    @Column(name = "triggered_at", nullable = false)
    private Instant triggeredAt = Instant.now();
    
    @Column(name = "acknowledged")
    private Boolean acknowledged = false;
    
    @Column(name = "acknowledged_by", length = 100)
    private String acknowledgedBy;
    
    @Column(name = "acknowledged_at")
    private Instant acknowledgedAt;
    
    @Column(name = "resolved")
    private Boolean resolved = false;
    
    @Column(name = "resolved_at")
    private Instant resolvedAt;
    
    @Column(name = "resolved_by", length = 100)
    private String resolvedBy;
    
    @Column(name = "resolution_notes", columnDefinition = "TEXT")
    private String resolutionNotes;
    
    @Column(name = "metadata", columnDefinition = "JSONB")
    @JdbcTypeCode(SqlTypes.JSON)
    private Map<String, Object> metadata = new HashMap<>();
    
    @Column(name = "created_at")
    private Instant createdAt = Instant.now();
    
    @Column(name = "updated_at")
    private Instant updatedAt = Instant.now();
    
    @PreUpdate
    protected void onUpdate() {
        this.updatedAt = Instant.now();
    }
    
    // Business methods
    public void acknowledge(String acknowledgedBy) {
        this.acknowledged = true;
        this.acknowledgedBy = acknowledgedBy;
        this.acknowledgedAt = Instant.now();
    }
    
    public void resolve(String resolvedBy, String resolutionNotes) {
        this.resolved = true;
        this.resolvedBy = resolvedBy;
        this.resolvedAt = Instant.now();
        this.resolutionNotes = resolutionNotes;
    }
    
    public boolean isCritical() {
        return severity == AlertSeverity.CRITICAL;
    }
    
    public boolean requiresImmediateAction() {
        return isCritical() && !acknowledged;
    }
    
    public void addMetadata(String key, Object value) {
        this.metadata.put(key, value);
    }
    
    // Getters and Setters
    public Long getAlertId() { return alertId; }
    public void setAlertId(Long alertId) { this.alertId = alertId; }
    
    public String getTracker() { return trackerId; }
    public void setTracker(String trackerId) { this.trackerId = trackerId; }
    
    public String getVehicle() { return vehicleId; }
    public void setVehicle(String vehicleId) { this.vehicleId = vehicleId; }
    
    public String getAlertType() { return alertType; }
    public void setAlertType(String alertType) { this.alertType = alertType; }
    
    public AlertSeverity getSeverity() { return severity; }
    public void setSeverity(AlertSeverity severity) { this.severity = severity; }
    
    public String getMessage() { return message; }
    public void setMessage(String message) { this.message = message; }
    
    public String getLocationId() { return locationId; }
    public void setLocation(String location) { this.locationId = locationId; }
    
    public Instant getTriggeredAt() { return triggeredAt; }
    public void setTriggeredAt(Instant triggeredAt) { this.triggeredAt = triggeredAt; }
    
    public Boolean getAcknowledged() { return acknowledged; }
    public void setAcknowledged(Boolean acknowledged) { this.acknowledged = acknowledged; }
    
    public String getAcknowledgedBy() { return acknowledgedBy; }
    public void setAcknowledgedBy(String acknowledgedBy) { this.acknowledgedBy = acknowledgedBy; }
    
    public Instant getAcknowledgedAt() { return acknowledgedAt; }
    public void setAcknowledgedAt(Instant acknowledgedAt) { this.acknowledgedAt = acknowledgedAt; }
    
    public Boolean getResolved() { return resolved; }
    public void setResolved(Boolean resolved) { this.resolved = resolved; }
    
    public Instant getResolvedAt() { return resolvedAt; }
    public void setResolvedAt(Instant resolvedAt) { this.resolvedAt = resolvedAt; }
    
    public Instant getCreatedAt() { return createdAt; }
    public void setCreatedAt(Instant createdAt) { this.createdAt = createdAt; }
    
    public Instant getUpdatedAt() { return updatedAt; }
    public void setUpdatedAt(Instant updatedAt) { this.updatedAt = updatedAt; }
    
    // Additional getters/setters
    public String getResolvedBy() { return resolvedBy; }
    public void setResolvedBy(String resolvedBy) { this.resolvedBy = resolvedBy; }
    
    public String getResolutionNotes() { return resolutionNotes; }
    public void setResolutionNotes(String resolutionNotes) { this.resolutionNotes = resolutionNotes; }
    
    public Map<String, Object> getMetadata() { return metadata; }
    public void setMetadata(Map<String, Object> metadata) { this.metadata = metadata; }
}```

=== ./src/main/java/com/jjenus/tracker/alerting/domain/enums/AlertRuleType.java ===
```.java
package com.jjenus.tracker.alerting.domain.enums;

public enum AlertRuleType {
    SPEED,
    GEOFENCE,
    TIME,
    DEVICE_STATUS,
    VEHICLE_STATUS,
    SAFETY,
    BUSINESS_RULE,
    CUSTOM
}```

=== ./src/main/java/com/jjenus/tracker/alerting/domain/enums/AlertSeverity.java ===
```.java
package com.jjenus.tracker.alerting.domain.enums;

public enum AlertSeverity {
    INFO,
    WARNING,
    CRITICAL
}```

=== ./src/main/java/com/jjenus/tracker/alerting/domain/enums/AlertType.java ===
```.java
package com.jjenus.tracker.alerting.domain.enums;

public enum AlertType {
    // Speed related
    OVERSPEED("Overspeed violation"),
    RAPID_ACCELERATION("Rapid acceleration"),
    HARD_BRAKING("Hard braking"),
    
    // Geofence related
    GEOFENCE_ENTRY("Geofence entry"),
    GEOFENCE_EXIT("Geofence exit"),
    GEOFENCE_VIOLATION("Geofence violation"),
    
    // Time related
    IDLE_TIMEOUT("Excessive idling"),
    LONG_STOP("Long stop detected"),
    SCHEDULE_VIOLATION("Schedule violation"),
    
    // Device status
    DEVICE_DISCONNECTED("Device disconnected"),
    LOW_BATTERY("Low battery"),
    NO_GPS_SIGNAL("No GPS signal"),
    TAMPER_DETECTED("Device tampering detected"),
    
    // Vehicle status
    ENGINE_ON_OUTSIDE_HOURS("Engine on outside permitted hours"),
    FUEL_THEFT_SUSPECTED("Fuel theft suspected"),
    MAINTENANCE_DUE("Maintenance due"),
    
    // Safety
    ACCIDENT_DETECTED("Possible accident detected"),
    PANIC_BUTTON_PRESSED("Panic button activated"),
    
    // Business rules
    ROUTE_DEVIATION("Route deviation"),
    UNAUTHORIZED_AREA("Entered unauthorized area"),
    HIJACKING_SUSPECTED("Possible hijacking");
    
    private final String description;
    
    AlertType(String description) {
        this.description = description;
    }
    
    public String getDescription() {
        return description;
    }
}```

=== ./src/main/java/com/jjenus/tracker/alerting/domain/enums/GeofenceShapeType.java ===
```.java
package com.jjenus.tracker.alerting.domain.enums;

public enum GeofenceShapeType {
    CIRCLE,
    POLYGON
}```

=== ./src/main/java/com/jjenus/tracker/alerting/domain/factory/AlertRuleFactory.java ===
```.java
package com.jjenus.tracker.alerting.domain.factory;

import com.jjenus.tracker.alerting.application.service.GeofenceService;
import com.jjenus.tracker.alerting.domain.*;
import com.jjenus.tracker.alerting.domain.entity.AlertRule;
import com.jjenus.tracker.alerting.domain.entity.Geofence;
import com.jjenus.tracker.alerting.domain.enums.AlertRuleType;
import com.jjenus.tracker.shared.domain.LocationPoint;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

import java.time.Duration;
import java.util.List;
import java.util.Map;

@Component
public class AlertRuleFactory {

    private static final Logger logger = LoggerFactory.getLogger(AlertRuleFactory.class);

    private final GeofenceService geofenceService;

    public AlertRuleFactory(GeofenceService geofenceService) {
        this.geofenceService = geofenceService;
    }

    /**
     * Convert AlertRule entity to appropriate IAlertRule implementation
     */
    public IAlertRule createDomainRule(AlertRule entity, String vehicleId) {
        if (entity == null || !entity.isEnabled()) {
            return null;
        }

        // Check if rule applies to this specific vehicle
        if (!entity.appliesToVehicle(vehicleId)) {
            return null;
        }

        Map<String, Object> params = entity.getParameters();

        try {
            return switch (entity.getRuleType()) {
                case SPEED -> createMaxSpeedRule(entity, params);
                case TIME -> createIdleTimeRule(entity, params);
                case GEOFENCE -> createGeofenceRule(entity, params, vehicleId);
                default -> createGenericRule(entity, params);
            };
        } catch (Exception e) {
            logger.error("Failed to create domain rule for {}: {}",
                    entity.getRuleKey(), e.getMessage());
            return null;
        }
    }

    private MaxSpeedRule createMaxSpeedRule(AlertRule entity, Map<String, Object> params) {
        float speedLimit = getFloatParam(params, "speedLimit", 80.0f);
        return new MaxSpeedRule(entity.getRuleKey(), entity.getRuleName(), speedLimit);
    }

    private IdleTimeRule createIdleTimeRule(AlertRule entity, Map<String, Object> params) {
        int maxIdleMinutes = getIntParam(params, "maxIdleMinutes", 30);
        Duration maxIdleTime = Duration.ofMinutes(maxIdleMinutes);
        return new IdleTimeRule(entity.getRuleKey(), entity.getRuleName(), maxIdleTime);
    }

    private GeofenceRule createGeofenceRule(AlertRule entity, Map<String, Object> params, String vehicleId) {
        String geofenceId = getStringParam(params, "geofenceId", "");
        String actionStr = getStringParam(params, "action", "BOTH");

        // Fetch geofence from service (cached)
        Geofence geofence = getGeofenceById(geofenceId);
        if (geofence == null) {
            logger.warn("Geofence not found: {} for rule {}", geofenceId, entity.getRuleKey());
            return null;
        }

        // Check if this geofence applies to the vehicle
        if (!geofence.hasVehicle(vehicleId)) {
            logger.debug("Geofence {} doesn't apply to vehicle {}", geofenceId, vehicleId);
            return null;
        }

        // Convert boundary points
        List<LocationPoint> boundaryPoints = extractBoundaryPoints(geofence);

        GeofenceRule.Action action;
        try {
            action = GeofenceRule.Action.valueOf(actionStr);
        } catch (IllegalArgumentException e) {
            action = GeofenceRule.Action.BOTH;
        }

        return new GeofenceRule(
                entity.getRuleKey(),
                entity.getRuleName(),
                geofenceId,
                boundaryPoints,
                action,
                entity.getPriority()
        );
    }

    private Geofence getGeofenceById(String geofenceId) {
        try {
            Long id = Long.parseLong(geofenceId);
            return geofenceService.getGeofenceById(id);
        } catch (NumberFormatException e) {
            logger.error("Invalid geofence ID format: {}", geofenceId);
            return null;
        }
    }

    private List<LocationPoint> extractBoundaryPoints(Geofence geofence) {
        if (geofence.getShapeType() == null) {
            return List.of();
        }

        // For circle geofences, create a polygon approximation
        if (geofence.getShapeType().name().equals("CIRCLE") &&
                geofence.getCenterLatitude() != null &&
                geofence.getCenterLongitude() != null &&
                geofence.getRadiusMeters() != null) {

            return createCircleBoundaryPoints(
                    geofence.getCenterLatitude(),
                    geofence.getCenterLongitude(),
                    geofence.getRadiusMeters()
            );
        }

        // For polygon geofences, use the stored points
        return geofence.getPoints().stream()
                .map(point -> new LocationPoint(
                        point.getLatitude(),
                        point.getLongitude(),
                        0.0f, // Speed not relevant for geofence points
                        java.time.Instant.now()
                ))
                .toList();
    }

    private List<LocationPoint> createCircleBoundaryPoints(Double lat, Double lon, Integer radius) {
        // Create 12-point polygon approximation of circle
        List<LocationPoint> points = new java.util.ArrayList<>();
        int pointsCount = 12;

        for (int i = 0; i < pointsCount; i++) {
            double angle = 2 * Math.PI * i / pointsCount;
            double latOffset = (radius / 111000.0) * Math.sin(angle);
            double lonOffset = (radius / (111000.0 * Math.cos(Math.toRadians(lat)))) * Math.cos(angle);

            points.add(new LocationPoint(
                    lat + latOffset,
                    lon + lonOffset,
                    0.0f,
                    java.time.Instant.now()
            ));
        }

        return points;
    }

    private IAlertRule createGenericRule(AlertRule entity, Map<String, Object> params) {
        return new GenericAlertRule(entity, params);
    }

    // Helper methods for parameter extraction
    private float getFloatParam(Map<String, Object> params, String key, float defaultValue) {
        if (params != null && params.containsKey(key)) {
            Object value = params.get(key);
            if (value instanceof Number) {
                return ((Number) value).floatValue();
            } else if (value instanceof String) {
                try {
                    return Float.parseFloat((String) value);
                } catch (NumberFormatException e) {
                    return defaultValue;
                }
            }
        }
        return defaultValue;
    }

    private int getIntParam(Map<String, Object> params, String key, int defaultValue) {
        if (params != null && params.containsKey(key)) {
            Object value = params.get(key);
            if (value instanceof Number) {
                return ((Number) value).intValue();
            } else if (value instanceof String) {
                try {
                    return Integer.parseInt((String) value);
                } catch (NumberFormatException e) {
                    return defaultValue;
                }
            }
        }
        return defaultValue;
    }

    private String getStringParam(Map<String, Object> params, String key, String defaultValue) {
        if (params != null && params.containsKey(key)) {
            Object value = params.get(key);
            return value != null ? value.toString() : defaultValue;
        }
        return defaultValue;
    }
}```

=== ./src/main/java/com/jjenus/tracker/alerting/domain/GenericAlertRule.java ===
```.java
package com.jjenus.tracker.alerting.domain;

import com.jjenus.tracker.alerting.domain.entity.AlertRule;
import com.jjenus.tracker.shared.domain.LocationPoint;
import java.util.Map;

public class GenericAlertRule implements IAlertRule {
    private final String ruleKey;
    private final String ruleName;
    private final Map<String, Object> parameters;
    private boolean enabled;
    private final int priority;

    public GenericAlertRule(AlertRule entity, Map<String, Object> parameters) {
        this.ruleKey = entity.getRuleKey();
        this.ruleName = entity.getRuleName();
        this.parameters = parameters;
        this.enabled = entity.isEnabled();
        this.priority = entity.getPriority();
    }

    @Override
    public AlertEvent evaluate(String vehicleId, LocationPoint newLocation) {
        // Custom rule evaluation logic based on parameters
        // Could be implemented using scripting engine or rule engine
        return null; // Override in specific implementations
    }

    @Override
    public String getRuleKey() { return ruleKey; }

    @Override
    public String getRuleName() { return ruleName; }

    @Override
    public boolean isEnabled() { return enabled; }

    @Override
    public void setEnabled(boolean enabled) { this.enabled = enabled; }

    @Override
    public int getPriority() { return priority; }

    public Map<String, Object> getParameters() { return parameters; }
}```

=== ./src/main/java/com/jjenus/tracker/alerting/domain/GeofenceExitRule.java ===
```.java
package com.jjenus.tracker.alerting.domain;

import com.jjenus.tracker.alerting.domain.enums.AlertSeverity;
import com.jjenus.tracker.shared.domain.LocationPoint;
import java.awt.geom.Path2D;
import java.util.List;

public class GeofenceExitRule implements IAlertRule {
    private final String ruleKey;
    private final String ruleName;
    private final String geofenceId;
    private final List<LocationPoint> boundaryPoints;
    private boolean enabled;
    private final int priority;
    private boolean wasInside;
    
    public GeofenceExitRule(String ruleKey, String geofenceId, 
                           List<LocationPoint> boundaryPoints) {
        this.ruleKey = ruleKey;
        this.ruleName = "Geofence Exit Rule";
        this.geofenceId = geofenceId;
        this.boundaryPoints = boundaryPoints;
        this.enabled = true;
        this.priority = 3;
        this.wasInside = false;
    }
    
    @Override
    public AlertEvent evaluate(String vehicleId, LocationPoint newLocation) {
        if (!enabled) return null;
        
        boolean isInside = isPointInPolygon(newLocation);
        AlertEvent alert = null;
        
        if (wasInside && !isInside) {
            String message = String.format(
                "Vehicle %s exited geofence %s",
                vehicleId,
                geofenceId
            );
            
            alert = new AlertEvent(
                ruleKey,
                vehicleId,
                message,
                AlertSeverity.WARNING,
                newLocation
            );
        }
        
        wasInside = isInside;
        return alert;
    }
    
    private boolean isPointInPolygon(LocationPoint point) {
        if (boundaryPoints.size() < 3) return false;
        
        Path2D polygon = new Path2D.Double();
        polygon.moveTo(boundaryPoints.get(0).longitude(), 
                      boundaryPoints.get(0).latitude());
        
        for (int i = 1; i < boundaryPoints.size(); i++) {
            polygon.lineTo(boundaryPoints.get(i).longitude(), 
                          boundaryPoints.get(i).latitude());
        }
        polygon.closePath();
        
        return polygon.contains(point.longitude(), point.latitude());
    }
    
    @Override
    public String getRuleKey() { return ruleKey; }
    
    @Override
    public String getRuleName() { return ruleName; }
    
    @Override
    public boolean isEnabled() { return enabled; }
    
    @Override
    public void setEnabled(boolean enabled) { this.enabled = enabled; }
    
    @Override
    public int getPriority() { return priority; }
    
    public String getGeofenceId() { return geofenceId; }
}
```

=== ./src/main/java/com/jjenus/tracker/alerting/domain/GeofenceRule.java ===
```.java
package com.jjenus.tracker.alerting.domain;

import com.jjenus.tracker.alerting.domain.enums.AlertSeverity;
import com.jjenus.tracker.shared.domain.LocationPoint;
import java.awt.geom.Path2D;
import java.util.List;

public class GeofenceRule implements IAlertRule {
    public enum Action {
        ENTRY, EXIT, BOTH
    }

    private final String ruleKey;
    private final String ruleName;
    private final String geofenceId;
    private final List<LocationPoint> boundaryPoints;
    private final Action action;
    private boolean enabled;
    private final int priority;
    private boolean wasInside = false;

    public GeofenceRule(String ruleKey, String ruleName, String geofenceId,
                        List<LocationPoint> boundaryPoints, Action action, int priority) {
        this.ruleKey = ruleKey;
        this.ruleName = ruleName;
        this.geofenceId = geofenceId;
        this.boundaryPoints = boundaryPoints;
        this.action = action;
        this.enabled = true;
        this.priority = priority;
    }

    @Override
    public AlertEvent evaluate(String vehicleId, LocationPoint newLocation) {
        if (!enabled || boundaryPoints == null || boundaryPoints.size() < 3) {
            return null;
        }

        boolean isInside = isPointInPolygon(newLocation);
        AlertEvent alert = null;

        // Check based on action type
        switch (action) {
            case ENTRY:
                if (!wasInside && isInside) {
                    alert = createAlert(vehicleId, newLocation, "entered", AlertSeverity.INFO);
                }
                break;

            case EXIT:
                if (wasInside && !isInside) {
                    alert = createAlert(vehicleId, newLocation, "exited", AlertSeverity.WARNING);
                }
                break;

            case BOTH:
                if (!wasInside && isInside) {
                    alert = createAlert(vehicleId, newLocation, "entered", AlertSeverity.INFO);
                } else if (wasInside && !isInside) {
                    alert = createAlert(vehicleId, newLocation, "exited", AlertSeverity.WARNING);
                }
                break;
        }

        wasInside = isInside;
        return alert;
    }

    private AlertEvent createAlert(String vehicleId, LocationPoint location,
                                   String actionStr, AlertSeverity severity) {
        String message = String.format(
                "Vehicle %s %s geofence %s at %s",
                vehicleId,
                actionStr,
                geofenceId,
                formatCoordinates(location.latitude(), location.longitude())
        );

        return new AlertEvent(
                ruleKey,
                vehicleId,
                message,
                severity,
                location
        );
    }

    private String formatCoordinates(double lat, double lon) {
        return String.format("[%.6f, %.6f]", lat, lon);
    }

    private boolean isPointInPolygon(LocationPoint point) {
        try {
            Path2D polygon = new Path2D.Double();
            polygon.moveTo(boundaryPoints.get(0).longitude(),
                    boundaryPoints.get(0).latitude());

            for (int i = 1; i < boundaryPoints.size(); i++) {
                polygon.lineTo(boundaryPoints.get(i).longitude(),
                        boundaryPoints.get(i).latitude());
            }
            polygon.closePath();

            return polygon.contains(point.longitude(), point.latitude());
        } catch (Exception e) {
            return false;
        }
    }

    @Override
    public String getRuleKey() { return ruleKey; }

    @Override
    public String getRuleName() { return ruleName; }

    @Override
    public boolean isEnabled() { return enabled; }

    @Override
    public void setEnabled(boolean enabled) { this.enabled = enabled; }

    @Override
    public int getPriority() { return priority; }

    // Additional methods
    public String getGeofenceId() { return geofenceId; }
    public Action getAction() { return action; }
    public List<LocationPoint> getBoundaryPoints() { return boundaryPoints; }
}```

=== ./src/main/java/com/jjenus/tracker/alerting/domain/IAlertRule.java ===
```.java
package com.jjenus.tracker.alerting.domain;

import com.jjenus.tracker.shared.domain.LocationPoint;

public interface IAlertRule {
    AlertEvent evaluate(String vehicleId, LocationPoint newLocation);
    String getRuleKey();
    String getRuleName();
    boolean isEnabled();
    void setEnabled(boolean enabled);
    int getPriority();
}

```

=== ./src/main/java/com/jjenus/tracker/alerting/domain/IdleTimeRule.java ===
```.java
package com.jjenus.tracker.alerting.domain;

import com.jjenus.tracker.alerting.domain.enums.AlertSeverity;
import com.jjenus.tracker.shared.domain.LocationPoint;
import java.time.Duration;
import java.time.Instant;

public class IdleTimeRule implements IAlertRule {
    private final String ruleKey;
    private final String ruleName;
    private final Duration maxIdleTime;
    private boolean enabled;
    private final int priority;

    private final java.util.Map<String, Instant> lastMovementTimes = new java.util.HashMap<>();

    public IdleTimeRule(String ruleKey, String ruleName, Duration maxIdleTime) {
        this.ruleKey = ruleKey;
        this.ruleName = ruleName;
        this.maxIdleTime = maxIdleTime;
        this.enabled = true;
        this.priority = 1;
    }

    @Override
    public AlertEvent evaluate(String vehicleId, LocationPoint newLocation) {
        if (!enabled) return null;

        Instant now = Instant.now();
        Instant lastMovement = lastMovementTimes.get(vehicleId);

        // Update last movement time if vehicle is moving
        if (newLocation.speedKmh() > 1.0) {
            lastMovementTimes.put(vehicleId, now);
            return null;
        }

        // If we have no last movement time, set it and return
        if (lastMovement == null) {
            lastMovementTimes.put(vehicleId, now);
            return null;
        }

        Duration idleDuration = Duration.between(lastMovement, now);

        if (idleDuration.compareTo(maxIdleTime) > 0) {
            String message = String.format(
                    "Vehicle %s has been idle for %d minutes (max allowed: %d minutes) at %s",
                    vehicleId,
                    idleDuration.toMinutes(),
                    maxIdleTime.toMinutes(),
                    formatCoordinates(newLocation.latitude(), newLocation.longitude())
            );

            return new AlertEvent(
                    ruleKey,
                    vehicleId,
                    message,
                    AlertSeverity.INFO,
                    newLocation
            );
        }
        return null;
    }

    private String formatCoordinates(double lat, double lon) {
        return String.format("[%.6f, %.6f]", lat, lon);
    }

    @Override
    public String getRuleKey() { return ruleKey; }

    @Override
    public String getRuleName() { return ruleName; }

    @Override
    public boolean isEnabled() { return enabled; }

    @Override
    public void setEnabled(boolean enabled) { this.enabled = enabled; }

    @Override
    public int getPriority() { return priority; }

    public Duration getMaxIdleTime() { return maxIdleTime; }
}```

=== ./src/main/java/com/jjenus/tracker/alerting/domain/MaxSpeedRule.java ===
```.java
package com.jjenus.tracker.alerting.domain;

import com.jjenus.tracker.alerting.domain.enums.AlertSeverity;
import com.jjenus.tracker.shared.domain.LocationPoint;

public class MaxSpeedRule implements IAlertRule {
    private final String ruleKey;
    private final String ruleName;
    private final float thresholdSpeed;
    private boolean enabled;
    private final int priority;

    public MaxSpeedRule(String ruleKey, float thresholdSpeed) {
        this.ruleKey = ruleKey;
        this.ruleName = "MAX_SPEED_RULE";
        this.thresholdSpeed = thresholdSpeed;
        this.enabled = true;
        this.priority = 2;
    }

    public MaxSpeedRule(String ruleKey, String ruleName, float speedLimit) {
        this.ruleKey = ruleKey;
        this.ruleName = ruleName;
        this.thresholdSpeed = speedLimit;
        this.enabled = true;
        this.priority = 2;
    }

    @Override
    public AlertEvent evaluate(String vehicleId, LocationPoint newLocation) {
        if (!enabled || vehicleId == null || newLocation == null) {
            return null;
        }

        float speed = newLocation.speedKmh();

        if (speed > thresholdSpeed) {
            String message = String.format(
                    "Vehicle %s exceeded speed limit of %.1f km/h. Current speed: %.1f km/h at %s",
                    vehicleId,
                    thresholdSpeed,
                    speed,
                    formatCoordinates(newLocation.latitude(), newLocation.longitude())
            );

            AlertSeverity severity = speed > thresholdSpeed * 1.5 ?
                    AlertSeverity.CRITICAL : AlertSeverity.WARNING;

            return new AlertEvent(
                    ruleKey,
                    vehicleId,
                    message,
                    severity,
                    newLocation
            );
        }
        return null;
    }

    private String formatCoordinates(double lat, double lon) {
        return String.format("[%.6f, %.6f]", lat, lon);
    }

    @Override
    public String getRuleKey() { return ruleKey; }

    @Override
    public String getRuleName() { return ruleName; }

    @Override
    public boolean isEnabled() { return enabled; }

    @Override
    public void setEnabled(boolean enabled) { this.enabled = enabled; }

    @Override
    public int getPriority() { return priority; }

    public float getThresholdSpeed() { return thresholdSpeed; }
}```

=== ./src/main/java/com/jjenus/tracker/alerting/exception/AlertException.java ===
```.java
package com.jjenus.tracker.alerting.exception;

import com.jjenus.tracker.shared.exception.BusinessRuleException;

public class AlertException extends BusinessRuleException {

    public AlertException(String errorCode, String message) {
        super(errorCode, message);
    }

    public AlertException(String errorCode, String message, Throwable cause) {
        super(errorCode, message, cause);
    }

    public static AlertException ruleNotFound(String ruleKey) {
        return new AlertException(
            "ALERT_RULE_NOT_FOUND",
            String.format("Alert rule with key '%s' not found", ruleKey)
        );
    }

    public static AlertException ruleAlreadyExists(String ruleKey) {
        return new AlertException(
            "ALERT_RULE_EXISTS",
            String.format("Alert rule with key '%s' already exists", ruleKey)
        );
    }

    public static AlertException invalidConfiguration(String ruleKey, String detail) {
        return new AlertException(
            "ALERT_INVALID_CONFIG",
            String.format("Invalid configuration for rule '%s': %s", ruleKey, detail)
        );
    }

    public static AlertException geofenceNotFound(String geofenceId) {
        return new AlertException(
            "ALERT_GEOFENCE_NOT_FOUND",
            String.format("Geofence with ID '%s' not found", geofenceId)
        );
    }

    public static AlertException evaluationError(String ruleKey, String detail) {
        return new AlertException(
            "ALERT_EVALUATION_ERROR",
            String.format("Error evaluating rule '%s': %s", ruleKey, detail)
        );
    }
}
```

=== ./src/main/java/com/jjenus/tracker/alerting/infrastructure/cache/AlertRuleCacheService.java ===
```.java
package com.jjenus.tracker.alerting.infrastructure.cache;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.jjenus.tracker.alerting.domain.IAlertRule;
import com.jjenus.tracker.alerting.domain.entity.AlertRule;
import com.jjenus.tracker.alerting.infrastructure.repository.AlertRuleRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.data.redis.core.RedisCallback;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.stereotype.Service;

import java.util.*;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;

@Service
public class AlertRuleCacheService {

    private static final Logger logger = LoggerFactory.getLogger(AlertRuleCacheService.class);

    private final RedisTemplate<String, Object> redisTemplate;
    private final AlertRuleRepository ruleRepository;
    private final RedisKeyGenerator keyGenerator;
    private final ObjectMapper objectMapper;

    public AlertRuleCacheService(
            RedisTemplate<String, Object> redisTemplate,
            AlertRuleRepository ruleRepository,
            RedisKeyGenerator keyGenerator,
            ObjectMapper objectMapper) {
        this.redisTemplate = redisTemplate;
        this.ruleRepository = ruleRepository;
        this.keyGenerator = keyGenerator;
        this.objectMapper = objectMapper;
    }

    /**
     * Load all active rules into cache on startup or when rules change
     */
    public void loadAllActiveRules() {
        try {
            List<AlertRule> activeRules = ruleRepository.findActiveRulesOrderedByPriority();

            // Clear existing cache
            redisTemplate.delete(keyGenerator.getAllActiveRulesKey());

            // Store each rule
            for (AlertRule rule : activeRules) {
                cacheRule(rule);
            }

            logger.info("Loaded {} active alert rules into Redis cache", activeRules.size());

        } catch (Exception e) {
            logger.error("Failed to load active rules into cache", e);
        }
    }

    /**
     * Get all active rules from cache
     */
    public List<AlertRule> getAllActiveRules() {
        try {
            // Get all rule keys from the active rules set
            Set<Object> ruleKeys = redisTemplate.opsForSet()
                    .members(keyGenerator.getAllActiveRulesKey());

            if (ruleKeys == null || ruleKeys.isEmpty()) {
                return loadAllActiveRulesAndReturn();
            }

            // Fetch all rules in bulk using pipelining
            return redisTemplate.executePipelined((RedisCallback<?>) connection -> {
                        for (Object ruleKeyObj : ruleKeys) {
                            String ruleKey = (String) ruleKeyObj;
                            connection.stringCommands().get(
                                    keyGenerator.getRuleDetailKey(ruleKey).getBytes()
                            );
                        }
                        return null;
                    }).stream()
                    .filter(Objects::nonNull)
                    .map(data -> objectMapper.convertValue(data, AlertRule.class))
                    .sorted(Comparator.comparingInt(AlertRule::getPriority).reversed())
                    .collect(Collectors.toList());

        } catch (Exception e) {
            logger.error("Failed to get active rules from cache, falling back to DB", e);
            return ruleRepository.findActiveRulesOrderedByPriority();
        }
    }

    /**
     * Cache a single rule
     */
    public void cacheRule(AlertRule rule) {
        try {
            String ruleKey = rule.getRuleKey();

            // Store rule details with TTL
            redisTemplate.opsForValue().set(
                    keyGenerator.getRuleDetailKey(ruleKey),
                    rule,
                    RedisKeyGenerator.RULE_DETAIL_TTL,
                    TimeUnit.SECONDS
            );

            // Add to active rules set if enabled
            if (Boolean.TRUE.equals(rule.isEnabled())) {
                redisTemplate.opsForSet().add(
                        keyGenerator.getAllActiveRulesKey(),
                        ruleKey
                );
                // Set TTL on the set
                redisTemplate.expire(
                        keyGenerator.getAllActiveRulesKey(),
                        RedisKeyGenerator.RULE_DETAIL_TTL,
                        TimeUnit.SECONDS
                );
            }

            logger.debug("Cached rule: {}", ruleKey);

        } catch (Exception e) {
            logger.error("Failed to cache rule: {}", rule.getRuleKey(), e);
        }
    }

    /**
     * Remove rule from cache
     */
    public void evictRule(String ruleKey) {
        try {
            // Remove from active rules set
            redisTemplate.opsForSet().remove(
                    keyGenerator.getAllActiveRulesKey(),
                    ruleKey
            );

            // Remove rule details
            redisTemplate.delete(keyGenerator.getRuleDetailKey(ruleKey));

            logger.debug("Evicted rule from cache: {}", ruleKey);

        } catch (Exception e) {
            logger.error("Failed to evict rule from cache: {}", ruleKey, e);
        }
    }

    /**
     * Get rule by key from cache
     */
    public Optional<AlertRule> getRuleByKey(String ruleKey) {
        try {
            AlertRule rule = (AlertRule) redisTemplate.opsForValue()
                    .get(keyGenerator.getRuleDetailKey(ruleKey));

            if (rule != null) {
                // Refresh TTL
                redisTemplate.expire(
                        keyGenerator.getRuleDetailKey(ruleKey),
                        RedisKeyGenerator.RULE_DETAIL_TTL,
                        TimeUnit.SECONDS
                );
                return Optional.of(rule);
            }

        } catch (Exception e) {
            logger.error("Failed to get rule from cache: {}", ruleKey, e);
        }
        return Optional.empty();
    }

    /**
     * Clear all rule cache
     */
    public void clearAllCache() {
        try {
            // Get all cache keys matching the pattern
            Set<String> keys = redisTemplate.keys("alerting:*");
            if (keys != null && !keys.isEmpty()) {
                redisTemplate.delete(keys);
                logger.info("Cleared all alert rule cache entries");
            }
        } catch (Exception e) {
            logger.error("Failed to clear cache", e);
        }
    }

    private List<AlertRule> loadAllActiveRulesAndReturn() {
        List<AlertRule> rules = ruleRepository.findActiveRulesOrderedByPriority();
        loadAllActiveRules(); // Re-populate cache
        return rules;
    }
}```

=== ./src/main/java/com/jjenus/tracker/alerting/infrastructure/cache/GeofenceCacheService.java ===
```.java
package com.jjenus.tracker.alerting.infrastructure.cache;

import com.jjenus.tracker.alerting.domain.entity.Geofence;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.stereotype.Service;

import java.util.Arrays;
import java.util.List;
import java.util.Optional;
import java.util.Set;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;

@Service
public class GeofenceCacheService {

    private static final Logger logger = LoggerFactory.getLogger(GeofenceCacheService.class);

    private final RedisTemplate<String, Object> redisTemplate;
    private final RedisKeyGenerator keyGenerator;

    public GeofenceCacheService(
            RedisTemplate<String, Object> redisTemplate,
            RedisKeyGenerator keyGenerator) {
        this.redisTemplate = redisTemplate;
        this.keyGenerator = keyGenerator;
    }

    public void cacheGeofence(Geofence geofence) {
        try {
            String detailKey = keyGenerator.getGeofenceDetailKey(geofence.getGeofenceId());
            redisTemplate.opsForValue().set(
                    detailKey,
                    geofence,
                    RedisKeyGenerator.GEOFENCE_CACHE_TTL,
                    TimeUnit.SECONDS
            );

            // Invalidate vehicle caches
            invalidateVehicleGeofenceCaches(geofence.getVehicleIds());

        } catch (Exception e) {
            logger.error("Failed to cache geofence: {}", geofence.getGeofenceId(), e);
        }
    }

    public Optional<Geofence> getGeofenceById(Long geofenceId) {
        try {
            String cacheKey = keyGenerator.getGeofenceDetailKey(geofenceId);
            Geofence geofence = (Geofence) redisTemplate.opsForValue().get(cacheKey);

            if (geofence != null) {
                // Refresh TTL on access
                redisTemplate.expire(cacheKey,
                        RedisKeyGenerator.GEOFENCE_CACHE_TTL,
                        TimeUnit.SECONDS);
            }

            return Optional.ofNullable(geofence);

        } catch (Exception e) {
            logger.error("Failed to get geofence from cache: {}", geofenceId, e);
            return Optional.empty();
        }
    }

    public void cacheVehicleGeofences(String vehicleId, List<Geofence> geofences) {
        try {
            String cacheKey = keyGenerator.getVehicleGeofencesKey(vehicleId);

            // Delete existing cache
            redisTemplate.delete(cacheKey);

            if (!geofences.isEmpty()) {
                // Store as list
                redisTemplate.opsForList().rightPushAll(cacheKey, geofences.toArray());
                redisTemplate.expire(cacheKey,
                        RedisKeyGenerator.VEHICLE_GEOFENCE_CACHE_TTL,
                        TimeUnit.SECONDS);
            }

        } catch (Exception e) {
            logger.error("Failed to cache vehicle geofences: {}", vehicleId, e);
        }
    }

    public List<Geofence> getVehicleGeofences(String vehicleId) {
        try {
            String cacheKey = keyGenerator.getVehicleGeofencesKey(vehicleId);
            List<Object> cached = redisTemplate.opsForList().range(cacheKey, 0, -1);

            if (cached != null && !cached.isEmpty()) {
                return cached.stream()
                        .map(obj -> (Geofence) obj)
                        .collect(Collectors.toList());
            }

            return null; // Indicate cache miss

        } catch (Exception e) {
            logger.error("Failed to get vehicle geofences from cache: {}", vehicleId, e);
            return null;
        }
    }

    public void invalidateGeofence(Long geofenceId) {
        try {
            String detailKey = keyGenerator.getGeofenceDetailKey(geofenceId);
            redisTemplate.delete(detailKey);
        } catch (Exception e) {
            logger.error("Failed to invalidate geofence cache: {}", geofenceId, e);
        }
    }

    public void invalidateVehicleGeofenceCache(String vehicleId) {
        try {
            String allKey = keyGenerator.getVehicleGeofencesKey(vehicleId);
            String activeKey = keyGenerator.getActiveVehicleGeofencesKey(vehicleId);
            List<String> keysToDelete = Arrays.asList(allKey, activeKey);

            redisTemplate.delete(keysToDelete);
        } catch (Exception e) {
            logger.error("Failed to invalidate vehicle geofence cache: {}", vehicleId, e);
        }
    }

    public void invalidateVehicleGeofenceCaches(Set<String> vehicleIds) {
        try {
            for (String vehicleId : vehicleIds) {
                invalidateVehicleGeofenceCache(vehicleId);
            }
        } catch (Exception e) {
            logger.error("Failed to invalidate vehicle geofence caches", e);
        }
    }

    public void clearAll() {
        try {
            Set<String> keys = redisTemplate.keys("geofence:*");
            if (keys != null && !keys.isEmpty()) {
                redisTemplate.delete(keys);
            }
        } catch (Exception e) {
            logger.error("Failed to clear geofence cache", e);
        }
    }
}```

=== ./src/main/java/com/jjenus/tracker/alerting/infrastructure/cache/RedisKeyGenerator.java ===
```.java
package com.jjenus.tracker.alerting.infrastructure.cache;

import org.springframework.stereotype.Component;

@Component
public class RedisKeyGenerator {

    // ========== CACHE NAMESPACING & VERSIONING ==========
    public static final String CACHE_NAMESPACE = "tracker:alerting:";
    public static final String CACHE_VERSION = "v1:";

    // ========== ALERT RULE KEYS ==========
    private static final String RULES_PREFIX = "rules:";
    public static final String VEHICLE_RULES_KEY_PREFIX = RULES_PREFIX + "vehicle:";
    public static final String VEHICLES_WITH_RULES_KEY = RULES_PREFIX + "vehicles:with-rules";
    public static final String RULE_DETAIL_KEY_PREFIX = RULES_PREFIX + "detail:";
    public static final String ALL_ACTIVE_RULES_KEY = RULES_PREFIX + "active:all";
    public static final String RULE_VEHICLE_INDEX_KEY = RULES_PREFIX + "vehicle-index";

    // ========== GEOFENCE KEYS ==========
    private static final String GEOFENCE_PREFIX = "geofence:";
    public static final String GEOFENCE_DETAIL_KEY_PREFIX = GEOFENCE_PREFIX + "detail:";
    public static final String VEHICLE_GEOFENCES_KEY_PREFIX = GEOFENCE_PREFIX + "vehicle:all:";
    public static final String ACTIVE_VEHICLE_GEOFENCES_KEY_PREFIX = GEOFENCE_PREFIX + "vehicle:active:";
    public static final String GEOFENCE_VEHICLE_INDEX_KEY = GEOFENCE_PREFIX + "vehicle-index";

    // ========== ALERT DATA KEYS ==========
    private static final String ALERT_PREFIX = "alert:";
    public static final String VEHICLE_ALERT_DATA_KEY_PREFIX = ALERT_PREFIX + "vehicle:data:";
    public static final String ALERT_COOLDOWN_KEY_PREFIX = ALERT_PREFIX + "cooldown:";

    // ========== STATISTICS & METRICS KEYS ==========
    private static final String STATS_PREFIX = "stats:";
    public static final String RULE_TRIGGER_COUNT_KEY = STATS_PREFIX + "rule:trigger-count:";
    public static final String VEHICLE_ALERT_COUNT_KEY = STATS_PREFIX + "vehicle:alert-count:";

    // ========== PAGINATION KEYS ==========
    private static final String PAGINATION_PREFIX = "pagination:";
    public static final String PAGINATED_RULES_KEY_PREFIX = PAGINATION_PREFIX + "rules:";
    public static final String PAGINATED_GEOFENCES_KEY_PREFIX = PAGINATION_PREFIX + "geofences:";

    // ========== CACHE TTLs (in seconds) ==========
    public static final long VEHICLE_RULE_CACHE_TTL = 2 * 60 * 60; // 2 hours
    public static final long INDEX_CACHE_TTL = 30 * 60; // 30 minutes
    public static final long RULE_DETAIL_TTL = 24 * 60 * 60; // 24 hours
    public static final long GEOFENCE_CACHE_TTL = 4 * 60 * 60; // 4 hours
    public static final long VEHICLE_GEOFENCE_CACHE_TTL = 60 * 60; // 1 hour
    public static final long ALERT_COOLDOWN_TTL = 10 * 60; // 10 minutes
    public static final long STATS_TTL = 7 * 24 * 60 * 60; // 7 days
    public static final long PAGINATION_CACHE_TTL = 5 * 60; // 5 minutes

    // ========== ALERT RULE METHODS ==========
    public String getVehicleRulesKey(String vehicleId) {
        return buildKey(VEHICLE_RULES_KEY_PREFIX + vehicleId);
    }

    public String getVehiclesWithRulesKey() {
        return buildKey(VEHICLES_WITH_RULES_KEY);
    }

    public String getRuleDetailKey(String ruleKey) {
        return buildKey(RULE_DETAIL_KEY_PREFIX + ruleKey);
    }

    public String getAllActiveRulesKey() {
        return buildKey(ALL_ACTIVE_RULES_KEY);
    }

    public String getRuleVehicleIndexKey() {
        return buildKey(RULE_VEHICLE_INDEX_KEY);
    }

    // ========== GEOFENCE METHODS ==========
    public String getGeofenceDetailKey(Long geofenceId) {
        return buildKey(GEOFENCE_DETAIL_KEY_PREFIX + geofenceId);
    }

    public String getVehicleGeofencesKey(String vehicleId) {
        return buildKey(VEHICLE_GEOFENCES_KEY_PREFIX + vehicleId);
    }

    public String getActiveVehicleGeofencesKey(String vehicleId) {
        return buildKey(ACTIVE_VEHICLE_GEOFENCES_KEY_PREFIX + vehicleId);
    }

    public String getGeofenceVehicleIndexKey() {
        return buildKey(GEOFENCE_VEHICLE_INDEX_KEY);
    }

    // ========== ALERT DATA METHODS ==========
    public String getVehicleAlertDataKey(String vehicleId) {
        return buildKey(VEHICLE_ALERT_DATA_KEY_PREFIX + vehicleId);
    }

    public String getAlertCooldownKey(String ruleKey, String vehicleId) {
        return buildKey(ALERT_COOLDOWN_KEY_PREFIX + ruleKey + ":" + vehicleId);
    }

    // ========== STATISTICS METHODS ==========
    public String getRuleTriggerCountKey(String ruleKey) {
        return buildKey(RULE_TRIGGER_COUNT_KEY + ruleKey);
    }

    public String getVehicleAlertCountKey(String vehicleId) {
        return buildKey(VEHICLE_ALERT_COUNT_KEY + vehicleId);
    }

    // ========== PAGINATION METHODS ==========
    public String getPaginatedRulesKey(int page, int size, String sortBy, String sortDirection,
                                       String search, String ruleType, Boolean enabled) {
        String key = String.format("page:%d:size:%d:sort:%s:dir:%s",
                page, size, sortBy, sortDirection);
        if (search != null && !search.trim().isEmpty()) key += ":search:" + search.hashCode();
        if (ruleType != null) key += ":type:" + ruleType;
        if (enabled != null) key += ":enabled:" + enabled;
        return buildKey(PAGINATED_RULES_KEY_PREFIX + key);
    }

    public String getPaginatedGeofencesKey(int page, int size, String sortBy, String sortDirection,
                                           String search, String vehicleId, Boolean active) {
        String key = String.format("page:%d:size:%d:sort:%s:dir:%s",
                page, size, sortBy, sortDirection);
        if (search != null && !search.trim().isEmpty()) key += ":search:" + search.hashCode();
        if (vehicleId != null) key += ":vehicle:" + vehicleId;
        if (active != null) key += ":active:" + active;
        return buildKey(PAGINATED_GEOFENCES_KEY_PREFIX + key);
    }

    // ========== UTILITY METHODS ==========
    public String getLockKey(String resource, String identifier) {
        return buildKey("lock:" + resource + ":" + identifier);
    }

    public String getPatternKey(String pattern) {
        return buildKey(pattern + "*");
    }

    // ========== PRIVATE HELPER ==========
    private String buildKey(String key) {
        return CACHE_NAMESPACE + CACHE_VERSION + key;
    }

    // ========== PATTERN GENERATORS ==========
    public String getVehicleRulesPattern() {
        return buildKey(VEHICLE_RULES_KEY_PREFIX + "*");
    }

    public String getGeofenceDetailPattern() {
        return buildKey(GEOFENCE_DETAIL_KEY_PREFIX + "*");
    }

    public String getVehicleGeofencesPattern() {
        return buildKey(VEHICLE_GEOFENCES_KEY_PREFIX + "*");
    }

    public String getAllRuleKeysPattern() {
        return buildKey(RULE_DETAIL_KEY_PREFIX + "*");
    }

    public String getPaginatedRulesPattern() {
        return buildKey(PAGINATED_RULES_KEY_PREFIX + "*");
    }

    public String getPaginatedGeofencesPattern() {
        return buildKey(PAGINATED_GEOFENCES_KEY_PREFIX + "*");
    }

    // ========== SHORT TTL KEYS (For rate limiting, etc.) ==========
    public String getRateLimitKey(String vehicleId, String ruleType) {
        return buildKey("rate-limit:" + ruleType + ":" + vehicleId + ":" + System.currentTimeMillis() / 60000);
    }

    // ========== BATCH OPERATION KEYS ==========
    public String getBatchOperationKey(String operationId) {
        return buildKey("batch:" + operationId);
    }
}```

=== ./src/main/java/com/jjenus/tracker/alerting/infrastructure/cache/VehicleRuleCacheService.java ===
```.java
package com.jjenus.tracker.alerting.infrastructure.cache;

import com.jjenus.tracker.alerting.domain.entity.AlertRule;
import com.jjenus.tracker.alerting.infrastructure.repository.AlertRuleRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.stereotype.Service;

import java.util.*;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;

@Service
public class VehicleRuleCacheService {

    private static final Logger logger = LoggerFactory.getLogger(VehicleRuleCacheService.class);

    private final RedisTemplate<String, Object> redisTemplate;
    private final AlertRuleRepository ruleRepository;
    private final RedisKeyGenerator keyGenerator;

    public VehicleRuleCacheService(
            RedisTemplate<String, Object> redisTemplate,
            AlertRuleRepository ruleRepository,
            RedisKeyGenerator keyGenerator) {
        this.redisTemplate = redisTemplate;
        this.ruleRepository = ruleRepository;
        this.keyGenerator = keyGenerator;
    }

    /**
     * Get active rules for a specific vehicle
     */
    public List<AlertRule> getActiveRulesForVehicle(String vehicleId) {
        try {
            String cacheKey = keyGenerator.getVehicleRulesKey(vehicleId);

            // Check cache first
            List<Object> cachedRules = redisTemplate.opsForList().range(cacheKey, 0, -1);

            if (cachedRules != null && !cachedRules.isEmpty()) {
                return cachedRules.stream()
                        .map(obj -> (AlertRule) obj)
                        .collect(Collectors.toList());
            }

            // Cache miss - load from DB and cache
            return loadAndCacheRulesForVehicle(vehicleId);

        } catch (Exception e) {
            logger.error("Failed to get rules for vehicle {}", vehicleId, e);
            return Collections.emptyList();
        }
    }

    /**
     * Load and cache rules for vehicle
     */
    private List<AlertRule> loadAndCacheRulesForVehicle(String vehicleId) {
        try {
            // Query rules that apply to this vehicle
            List<AlertRule> rules = ruleRepository.findActiveRulesForVehicle(vehicleId);

            if (rules.isEmpty()) {
                // Cache empty result with short TTL
                cacheEmptyResult(vehicleId);
                return Collections.emptyList();
            }

            // Sort by priority descending and cache
            List<AlertRule> sortedRules = rules.stream()
                    .sorted(Comparator.comparingInt(AlertRule::getPriority).reversed())
                    .collect(Collectors.toList());

            cacheRules(vehicleId, sortedRules);

            logger.debug("Loaded {} rules for vehicle {}", sortedRules.size(), vehicleId);

            return sortedRules;

        } catch (Exception e) {
            logger.error("Failed to load rules for vehicle {}", vehicleId, e);
            return Collections.emptyList();
        }
    }

    /**
     * Cache rules for vehicle
     */
    private void cacheRules(String vehicleId, List<AlertRule> rules) {
        try {
            String cacheKey = keyGenerator.getVehicleRulesKey(vehicleId);

            // Delete existing
            redisTemplate.delete(cacheKey);

            if (!rules.isEmpty()) {
                // Push all rules to list
                redisTemplate.opsForList().rightPushAll(cacheKey, rules.toArray());

                // Set TTL
                redisTemplate.expire(cacheKey, RedisKeyGenerator.VEHICLE_RULE_CACHE_TTL, TimeUnit.SECONDS);
            }

            logger.debug("Cached {} rules for vehicle {}", rules.size(), vehicleId);

        } catch (Exception e) {
            logger.error("Failed to cache rules for vehicle {}", vehicleId, e);
        }
    }

    /**
     * Cache empty result (no rules for this vehicle)
     */
    private void cacheEmptyResult(String vehicleId) {
        try {
            String cacheKey = keyGenerator.getVehicleRulesKey(vehicleId);

            // Store special marker for empty result with short TTL
            redisTemplate.opsForValue().set(cacheKey, "EMPTY", 5, TimeUnit.MINUTES);

            logger.debug("Cached empty result for vehicle {}", vehicleId);

        } catch (Exception e) {
            logger.error("Failed to cache empty result for vehicle {}", vehicleId, e);
        }
    }

    /**
     * Check if vehicle has any active rules (quick cache check)
     */
    public boolean hasActiveRules(String vehicleId) {
        try {
            String cacheKey = keyGenerator.getVehicleRulesKey(vehicleId);
            Object cached = redisTemplate.opsForValue().get(cacheKey);

            if (cached != null) {
                if ("EMPTY".equals(cached)) {
                    return false;
                }
                return redisTemplate.opsForList().size(cacheKey) > 0;
            }

            // Cache miss - check if we should even try
            return !getActiveRulesForVehicle(vehicleId).isEmpty();

        } catch (Exception e) {
            logger.error("Failed to check rules for vehicle {}", vehicleId, e);
            return false; // Be conservative - assume no rules
        }
    }

    /**
     * Get all vehicles that have active rules (for bulk operations)
     */
    public Set<String> getVehiclesWithActiveRules() {
        try {
            // This could be cached separately for faster lookups
            Set<String> vehiclesWithRules = ruleRepository.findVehiclesWithActiveRules();

            // Cache this set as well for quick reference
            String key = keyGenerator.getVehiclesWithRulesKey();
            redisTemplate.delete(key);

            if (!vehiclesWithRules.isEmpty()) {
                redisTemplate.opsForSet().add(key, vehiclesWithRules.toArray());
                redisTemplate.expire(key, keyGenerator.INDEX_CACHE_TTL, TimeUnit.SECONDS);
            }

            return vehiclesWithRules;

        } catch (Exception e) {
            logger.error("Failed to get vehicles with active rules", e);
            return Collections.emptySet();
        }
    }

    /**
     * Quick check if vehicle has rules (using cached index)
     */
    public boolean hasRulesCached(String vehicleId) {
        try {
            String key = keyGenerator.getVehiclesWithRulesKey();
            Boolean hasRule = redisTemplate.opsForSet().isMember(key, vehicleId);
            return Boolean.TRUE.equals(hasRule);
        } catch (Exception e) {
            logger.error("Failed to check cached rules index for vehicle {}", vehicleId, e);
            return false;
        }
    }

    /**
     * Invalidate cache for specific vehicle
     */
    public void invalidateVehicleRules(String vehicleId) {
        try {
            String cacheKey = keyGenerator.getVehicleRulesKey(vehicleId);
            redisTemplate.delete(cacheKey);

            // Also remove from vehicles-with-rules index
            String indexKey = keyGenerator.getVehiclesWithRulesKey();
            redisTemplate.opsForSet().remove(indexKey, vehicleId);

            logger.debug("Invalidated cache for vehicle {}", vehicleId);
        } catch (Exception e) {
            logger.error("Failed to invalidate cache for vehicle {}", vehicleId, e);
        }
    }

    /**
     * Batch invalidate - when rules change
     */
    public void invalidateAllVehicleRules() {
        try {
            Set<String> keys = redisTemplate.keys(keyGenerator.getVehicleRulesKey("*"));
            if (keys != null && !keys.isEmpty()) {
                redisTemplate.delete(keys);
            }

            // Clear vehicles index
            String indexKey = keyGenerator.getVehiclesWithRulesKey();
            redisTemplate.delete(indexKey);

            logger.info("Invalidated all vehicle rule caches");
        } catch (Exception e) {
            logger.error("Failed to invalidate all vehicle caches", e);
        }
    }

    /**
     * Pre-warm cache for frequently accessed vehicles
     */
    public void prewarmCacheForHighPriorityVehicles() {
        try {
            Set<String> highPriorityVehicles = getHighPriorityVehicles();

            for (String vehicleId : highPriorityVehicles) {
                // Async load into cache
                loadAndCacheRulesForVehicle(vehicleId);
            }

            logger.info("Pre-warmed cache for {} vehicles", highPriorityVehicles.size());

        } catch (Exception e) {
            logger.error("Failed to pre-warm cache", e);
        }
    }

    private Set<String> getHighPriorityVehicles() {
        // Business logic: VIP vehicles, recently active, etc.
        // Could be from configuration, analytics, or recent activity
        return new HashSet<>(); // Implement based on your needs
    }
}```

=== ./src/main/java/com/jjenus/tracker/alerting/infrastructure/config/CacheConfig.java ===
```.java
package com.jjenus.tracker.alerting.infrastructure.config;

import org.springframework.cache.annotation.EnableCaching;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.cache.RedisCacheConfiguration;
import org.springframework.data.redis.cache.RedisCacheManager;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;
import org.springframework.data.redis.serializer.RedisSerializationContext;
import org.springframework.data.redis.serializer.StringRedisSerializer;

import java.time.Duration;

@Configuration
@EnableCaching
public class CacheConfig {

    @Bean
    public RedisCacheManager cacheManager(RedisConnectionFactory connectionFactory) {
        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()
                .entryTtl(Duration.ofHours(1))
                .serializeKeysWith(RedisSerializationContext.SerializationPair
                        .fromSerializer(new StringRedisSerializer()))
                .serializeValuesWith(RedisSerializationContext.SerializationPair
                        .fromSerializer(new GenericJackson2JsonRedisSerializer()))
                .disableCachingNullValues();

        return RedisCacheManager.builder(connectionFactory)
                .cacheDefaults(config)
                .build();
    }
}```

=== ./src/main/java/com/jjenus/tracker/alerting/infrastructure/repository/AlertRuleRepository.java ===
```.java
package com.jjenus.tracker.alerting.infrastructure.repository;

import com.jjenus.tracker.alerting.domain.entity.AlertRule;
import com.jjenus.tracker.alerting.domain.enums.AlertRuleType;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;
import java.util.Set;

@Repository
public interface AlertRuleRepository extends JpaRepository<AlertRule, Long> {

    Optional<AlertRule> findByRuleKey(String ruleKey);

    List<AlertRule> findByIsEnabled(boolean isEnabled);

    Page<AlertRule> findByIsEnabled(boolean isEnabled, Pageable pageable);

    List<AlertRule> findByRuleType(AlertRuleType ruleType);

    Page<AlertRule> findByRuleType(AlertRuleType ruleType, Pageable pageable);

    List<AlertRule> findByRuleTypeAndIsEnabled(AlertRuleType ruleType, boolean isEnabled);

    Page<AlertRule> findByRuleTypeAndIsEnabled(AlertRuleType ruleType, boolean isEnabled, Pageable pageable);

    @Query("SELECT ar FROM AlertRule ar WHERE ar.isEnabled = true " +
            "ORDER BY ar.priority DESC")
    List<AlertRule> findActiveRulesOrderedByPriority();

    @Query("SELECT ar FROM AlertRule ar WHERE ar.isEnabled = true " +
            "ORDER BY ar.priority DESC")
    Page<AlertRule> findActiveRulesOrderedByPriority(Pageable pageable);

    @Query("SELECT ar FROM AlertRule ar WHERE ar.isEnabled = true " +
            "AND (:vehicleId MEMBER OF ar.vehicleIds OR :vehicleId IS NULL) " +
            "ORDER BY ar.priority DESC")
    List<AlertRule> findActiveRulesForVehicle(@Param("vehicleId") String vehicleId);

    @Query("SELECT ar FROM AlertRule ar WHERE ar.isEnabled = true " +
            "AND (:vehicleId MEMBER OF ar.vehicleIds OR :vehicleId IS NULL)")
    Page<AlertRule> findActiveRulesForVehicle(@Param("vehicleId") String vehicleId, Pageable pageable);

    // Find all vehicles that have rules
    @Query("SELECT DISTINCT vid FROM AlertRule ar JOIN ar.vehicleIds vid WHERE ar.isEnabled = true")
    Set<String> findVehiclesWithActiveRules();

    boolean existsByRuleKey(String ruleKey);

    void deleteByRuleKey(String ruleKey);

    // Search methods with pagination
    @Query("SELECT ar FROM AlertRule ar WHERE " +
            "(:search IS NULL OR LOWER(ar.ruleName) LIKE LOWER(CONCAT('%', :search, '%'))) " +
            "AND (:ruleType IS NULL OR ar.ruleType = :ruleType) " +
            "AND (:enabled IS NULL OR ar.isEnabled = :enabled)")
    Page<AlertRule> searchAlertRules(
            @Param("search") String search,
            @Param("ruleType") AlertRuleType ruleType,
            @Param("enabled") Boolean enabled,
            Pageable pageable);
}```

=== ./src/main/java/com/jjenus/tracker/alerting/infrastructure/repository/GeofenceRepository.java ===
```.java
package com.jjenus.tracker.alerting.infrastructure.repository;

import com.jjenus.tracker.alerting.domain.entity.Geofence;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Set;

@Repository
public interface GeofenceRepository extends JpaRepository<Geofence, Long> {

    // Find all geofences that include a specific vehicle
    @Query("SELECT g FROM Geofence g WHERE :vehicleId MEMBER OF g.vehicleIds")
    List<Geofence> findByVehicleId(@Param("vehicleId") String vehicleId);

    @Query("SELECT g FROM Geofence g WHERE :vehicleId MEMBER OF g.vehicleIds")
    Page<Geofence> findByVehicleId(@Param("vehicleId") String vehicleId, Pageable pageable);

    // Find active geofences for a specific vehicle
    @Query("SELECT g FROM Geofence g WHERE g.isActive = true AND :vehicleId MEMBER OF g.vehicleIds")
    List<Geofence> findByVehicleIdAndIsActive(@Param("vehicleId") String vehicleId);

    @Query("SELECT g FROM Geofence g WHERE g.isActive = true AND :vehicleId MEMBER OF g.vehicleIds")
    Page<Geofence> findByVehicleIdAndIsActive(@Param("vehicleId") String vehicleId, Pageable pageable);

    // Find geofences by multiple vehicles
    @Query("SELECT DISTINCT g FROM Geofence g JOIN g.vehicleIds vid WHERE vid IN :vehicleIds AND g.isActive = true")
    List<Geofence> findByVehicleIds(@Param("vehicleIds") Set<String> vehicleIds);

    @Query("SELECT DISTINCT g FROM Geofence g JOIN g.vehicleIds vid WHERE vid IN :vehicleIds AND g.isActive = true")
    Page<Geofence> findByVehicleIds(@Param("vehicleIds") Set<String> vehicleIds, Pageable pageable);

    // Find nearby geofences (spatial query)
    @Query("SELECT g FROM Geofence g WHERE g.isActive = true " +
            "AND (:latitude BETWEEN g.centerLatitude - (g.radiusMeters / 111000.0) " +
            "AND g.centerLatitude + (g.radiusMeters / 111000.0)) " +
            "AND (:longitude BETWEEN g.centerLongitude - (g.radiusMeters / (111000.0 * COS(RADIANS(g.centerLatitude)))) " +
            "AND g.centerLongitude + (g.radiusMeters / (111000.0 * COS(RADIANS(g.centerLatitude)))))")
    List<Geofence> findNearbyGeofences(
            @Param("latitude") Double latitude,
            @Param("longitude") Double longitude);

    // Find nearby geofences for specific vehicles
    @Query("SELECT g FROM Geofence g WHERE g.isActive = true " +
            "AND (:vehicleId MEMBER OF g.vehicleIds) " +
            "AND (:latitude BETWEEN g.centerLatitude - (g.radiusMeters / 111000.0) " +
            "AND g.centerLatitude + (g.radiusMeters / 111000.0)) " +
            "AND (:longitude BETWEEN g.centerLongitude - (g.radiusMeters / (111000.0 * COS(RADIANS(g.centerLatitude)))) " +
            "AND g.centerLongitude + (g.radiusMeters / (111000.0 * COS(RADIANS(g.centerLatitude)))))")
    List<Geofence> findNearbyGeofencesForVehicle(
            @Param("vehicleId") String vehicleId,
            @Param("latitude") Double latitude,
            @Param("longitude") Double longitude);

    // Find all vehicles that have geofences
    @Query("SELECT DISTINCT vid FROM Geofence g JOIN g.vehicleIds vid WHERE g.isActive = true")
    Set<String> findVehiclesWithGeofences();

    // Check if vehicle has any geofences
    @Query("SELECT COUNT(g) > 0 FROM Geofence g WHERE :vehicleId MEMBER OF g.vehicleIds AND g.isActive = true")
    boolean hasActiveGeofencesForVehicle(@Param("vehicleId") String vehicleId);

    // Search methods with pagination
    @Query("SELECT g FROM Geofence g WHERE " +
            "(:vehicleId IS NULL OR :vehicleId MEMBER OF g.vehicleIds) " +
            "AND (:search IS NULL OR LOWER(g.name) LIKE LOWER(CONCAT('%', :search, '%'))) " +
            "AND (:active IS NULL OR g.isActive = :active)")
    Page<Geofence> searchGeofences(
            @Param("vehicleId") String vehicleId,
            @Param("search") String search,
            @Param("active") Boolean active,
            Pageable pageable);
}```

=== ./src/main/java/com/jjenus/tracker/alerting/infrastructure/repository/TrackerAlertRepository.java ===
```.java
package com.jjenus.tracker.alerting.infrastructure.repository;

import com.jjenus.tracker.alerting.domain.entity.TrackerAlert;
import com.jjenus.tracker.alerting.domain.enums.AlertSeverity;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.time.Instant;
import java.util.List;

@Repository
public interface TrackerAlertRepository extends JpaRepository<TrackerAlert, Long> {
    
    Page<TrackerAlert> findByVehicleId(String vehicleId, Pageable pageable);
    
    Page<TrackerAlert> findByTrackerId(String trackerId, Pageable pageable);
    
    List<TrackerAlert> findByAlertTypeAndTriggeredAtAfter(
        String alertType, Instant triggeredAfter);
    
    List<TrackerAlert> findBySeverityAndAcknowledged(
            AlertSeverity severity, boolean acknowledged);
    
    @Query("SELECT ta FROM TrackerAlert ta WHERE ta.vehicleId = :vehicleId " +
           "AND ta.triggeredAt >= :startTime AND ta.triggeredAt <= :endTime " +
           "ORDER BY ta.triggeredAt DESC")
    List<TrackerAlert> findVehicleAlertsInRange(
        @Param("vehicleId") String vehicleId,
        @Param("startTime") Instant startTime,
        @Param("endTime") Instant endTime);
    
    @Query("SELECT ta FROM TrackerAlert ta WHERE ta.acknowledged = false " +
           "AND ta.resolved = false " +
           "ORDER BY ta.severity DESC, ta.triggeredAt DESC")
    Page<TrackerAlert> findActiveAlerts(Pageable pageable);
    
    @Query("SELECT ta FROM TrackerAlert ta WHERE ta.vehicleId = :vehicleId " +
           "AND ta.acknowledged = false " +
           "AND ta.resolved = false " +
           "ORDER BY ta.triggeredAt DESC")
    List<TrackerAlert> findActiveVehicleAlerts(@Param("vehicleId") String vehicleId);
    
    @Query("SELECT COUNT(ta) FROM TrackerAlert ta WHERE ta.acknowledged = false " +
           "AND ta.severity = :severity")
    Long countUnacknowledgedBySeverity(@Param("severity") AlertSeverity severity);
    
    @Query("SELECT ta.alertType, COUNT(ta) FROM TrackerAlert ta " +
           "WHERE ta.triggeredAt >= :startTime " +
           "GROUP BY ta.alertType " +
           "ORDER BY COUNT(ta) DESC")
    List<Object[]> getAlertTypeStatistics(@Param("startTime") Instant startTime);
    
    @Query("SELECT ta FROM TrackerAlert ta WHERE ta.resolved = false " +
           "AND ta.triggeredAt < :cutoffTime")
    List<TrackerAlert> findStaleAlerts(@Param("cutoffTime") Instant cutoffTime);
}```

